2022-12-28 22:57:08,804 p=5871 u=kal n=ansible | PLAY [localhost] ***************************************************************
2022-12-28 22:57:08,811 p=5871 u=kal n=ansible | TASK [Gathering Facts] *********************************************************
2022-12-28 22:57:09,031 p=5871 u=kal n=ansible | fatal: [krpz]: FAILED! => {"ansible_facts": {}, "changed": false, "failed_modules": {"ansible.legacy.setup": {"ansible_facts": {"discovered_interpreter_python": "/usr/bin/python3"}, "failed": true, "module_stderr": "sudo: a password is required\n", "module_stdout": "", "msg": "MODULE FAILURE\nSee stdout/stderr for the exact error", "rc": 1}}, "msg": "The following modules failed to execute: ansible.legacy.setup\n"}
2022-12-28 22:57:09,031 p=5871 u=kal n=ansible | PLAY RECAP *********************************************************************
2022-12-28 22:57:09,031 p=5871 u=kal n=ansible | krpz                       : ok=0    changed=0    unreachable=0    failed=1    skipped=0    rescued=0    ignored=0   
2022-12-28 22:58:23,153 p=6104 u=kal n=ansible | PLAY [localhost] ***************************************************************
2022-12-28 22:58:23,160 p=6104 u=kal n=ansible | TASK [Gathering Facts] *********************************************************
2022-12-28 22:58:23,379 p=6104 u=kal n=ansible | fatal: [krpz]: FAILED! => {"ansible_facts": {}, "changed": false, "failed_modules": {"ansible.legacy.setup": {"ansible_facts": {"discovered_interpreter_python": "/usr/bin/python3"}, "failed": true, "module_stderr": "sudo: a password is required\n", "module_stdout": "", "msg": "MODULE FAILURE\nSee stdout/stderr for the exact error", "rc": 1}}, "msg": "The following modules failed to execute: ansible.legacy.setup\n"}
2022-12-28 22:58:23,380 p=6104 u=kal n=ansible | PLAY RECAP *********************************************************************
2022-12-28 22:58:23,380 p=6104 u=kal n=ansible | krpz                       : ok=0    changed=0    unreachable=0    failed=1    skipped=0    rescued=0    ignored=0   
2022-12-28 22:58:25,751 p=6146 u=kal n=ansible | PLAY [localhost] ***************************************************************
2022-12-28 22:58:25,758 p=6146 u=kal n=ansible | TASK [Gathering Facts] *********************************************************
2022-12-28 22:58:25,978 p=6146 u=kal n=ansible | fatal: [krpz]: FAILED! => {"ansible_facts": {}, "changed": false, "failed_modules": {"ansible.legacy.setup": {"ansible_facts": {"discovered_interpreter_python": "/usr/bin/python3"}, "failed": true, "module_stderr": "sudo: a password is required\n", "module_stdout": "", "msg": "MODULE FAILURE\nSee stdout/stderr for the exact error", "rc": 1}}, "msg": "The following modules failed to execute: ansible.legacy.setup\n"}
2022-12-28 22:58:25,979 p=6146 u=kal n=ansible | PLAY RECAP *********************************************************************
2022-12-28 22:58:25,979 p=6146 u=kal n=ansible | krpz                       : ok=0    changed=0    unreachable=0    failed=1    skipped=0    rescued=0    ignored=0   
2022-12-28 23:00:32,109 p=6313 u=kal n=ansible | PLAY [localhost] ***************************************************************
2022-12-28 23:00:32,115 p=6313 u=kal n=ansible | TASK [Gathering Facts] *********************************************************
2022-12-28 23:00:32,337 p=6313 u=kal n=ansible | fatal: [krpz]: FAILED! => {"ansible_facts": {}, "changed": false, "failed_modules": {"ansible.legacy.setup": {"ansible_facts": {"discovered_interpreter_python": "/usr/bin/python3"}, "failed": true, "module_stderr": "sudo: a password is required\n", "module_stdout": "", "msg": "MODULE FAILURE\nSee stdout/stderr for the exact error", "rc": 1}}, "msg": "The following modules failed to execute: ansible.legacy.setup\n"}
2022-12-28 23:00:32,337 p=6313 u=kal n=ansible | PLAY RECAP *********************************************************************
2022-12-28 23:00:32,337 p=6313 u=kal n=ansible | krpz                       : ok=0    changed=0    unreachable=0    failed=1    skipped=0    rescued=0    ignored=0   
2022-12-28 23:00:36,691 p=6364 u=kal n=ansible | PLAY [localhost] ***************************************************************
2022-12-28 23:00:36,697 p=6364 u=kal n=ansible | TASK [Gathering Facts] *********************************************************
2022-12-28 23:00:36,889 p=6364 u=kal n=ansible | fatal: [krpz]: FAILED! => {"ansible_facts": {}, "changed": false, "failed_modules": {"ansible.legacy.setup": {"failed": true, "module_stderr": "sudo: a password is required\n", "module_stdout": "", "msg": "MODULE FAILURE\nSee stdout/stderr for the exact error", "rc": 1}}, "msg": "The following modules failed to execute: ansible.legacy.setup\n"}
2022-12-28 23:00:36,890 p=6364 u=kal n=ansible | PLAY RECAP *********************************************************************
2022-12-28 23:00:36,890 p=6364 u=kal n=ansible | krpz                       : ok=0    changed=0    unreachable=0    failed=1    skipped=0    rescued=0    ignored=0   
2022-12-28 23:00:46,649 p=6404 u=kal n=ansible | PLAY [localhost] ***************************************************************
2022-12-28 23:00:46,655 p=6404 u=kal n=ansible | TASK [Gathering Facts] *********************************************************
2022-12-28 23:00:46,847 p=6404 u=kal n=ansible | fatal: [krpz]: FAILED! => {"ansible_facts": {}, "changed": false, "failed_modules": {"ansible.legacy.setup": {"failed": true, "module_stderr": "sudo: a password is required\n", "module_stdout": "", "msg": "MODULE FAILURE\nSee stdout/stderr for the exact error", "rc": 1}}, "msg": "The following modules failed to execute: ansible.legacy.setup\n"}
2022-12-28 23:00:46,848 p=6404 u=kal n=ansible | PLAY RECAP *********************************************************************
2022-12-28 23:00:46,848 p=6404 u=kal n=ansible | krpz                       : ok=0    changed=0    unreachable=0    failed=1    skipped=0    rescued=0    ignored=0   
2022-12-28 23:02:40,776 p=6628 u=kal n=ansible | PLAY [localhost] ***************************************************************
2022-12-28 23:02:40,782 p=6628 u=kal n=ansible | TASK [Gathering Facts] *********************************************************
2022-12-28 23:02:40,978 p=6628 u=kal n=ansible | fatal: [krpz]: FAILED! => {"ansible_facts": {}, "changed": false, "failed_modules": {"ansible.legacy.setup": {"failed": true, "module_stderr": "sudo: a password is required\n", "module_stdout": "", "msg": "MODULE FAILURE\nSee stdout/stderr for the exact error", "rc": 1}}, "msg": "The following modules failed to execute: ansible.legacy.setup\n"}
2022-12-28 23:02:40,978 p=6628 u=kal n=ansible | PLAY RECAP *********************************************************************
2022-12-28 23:02:40,978 p=6628 u=kal n=ansible | krpz                       : ok=0    changed=0    unreachable=0    failed=1    skipped=0    rescued=0    ignored=0   
2022-12-28 23:03:31,389 p=6729 u=kal n=ansible | PLAY [localhost] ***************************************************************
2022-12-28 23:03:31,396 p=6729 u=kal n=ansible | TASK [Gathering Facts] *********************************************************
2022-12-28 23:03:31,591 p=6729 u=kal n=ansible | fatal: [krpz]: FAILED! => {"ansible_facts": {}, "changed": false, "failed_modules": {"ansible.legacy.setup": {"failed": true, "module_stderr": "sudo: a password is required\n", "module_stdout": "", "msg": "MODULE FAILURE\nSee stdout/stderr for the exact error", "rc": 1}}, "msg": "The following modules failed to execute: ansible.legacy.setup\n"}
2022-12-28 23:03:31,592 p=6729 u=kal n=ansible | PLAY RECAP *********************************************************************
2022-12-28 23:03:31,592 p=6729 u=kal n=ansible | krpz                       : ok=0    changed=0    unreachable=0    failed=1    skipped=0    rescued=0    ignored=0   
2022-12-28 23:03:51,232 p=6767 u=kal n=ansible | PLAY [localhost] ***************************************************************
2022-12-28 23:03:51,239 p=6767 u=kal n=ansible | TASK [Gathering Facts] *********************************************************
2022-12-28 23:03:51,431 p=6767 u=kal n=ansible | fatal: [krpz]: FAILED! => {"ansible_facts": {}, "changed": false, "failed_modules": {"ansible.legacy.setup": {"failed": true, "module_stderr": "sudo: a password is required\n", "module_stdout": "", "msg": "MODULE FAILURE\nSee stdout/stderr for the exact error", "rc": 1}}, "msg": "The following modules failed to execute: ansible.legacy.setup\n"}
2022-12-28 23:03:51,432 p=6767 u=kal n=ansible | PLAY RECAP *********************************************************************
2022-12-28 23:03:51,432 p=6767 u=kal n=ansible | krpz                       : ok=0    changed=0    unreachable=0    failed=1    skipped=0    rescued=0    ignored=0   
2022-12-28 23:03:59,378 p=6807 u=kal n=ansible | PLAY [localhost] ***************************************************************
2022-12-28 23:03:59,385 p=6807 u=kal n=ansible | TASK [Gathering Facts] *********************************************************
2022-12-28 23:03:59,583 p=6807 u=kal n=ansible | fatal: [krpz]: FAILED! => {"ansible_facts": {}, "changed": false, "failed_modules": {"ansible.legacy.setup": {"failed": true, "module_stderr": "sudo: a password is required\n", "module_stdout": "", "msg": "MODULE FAILURE\nSee stdout/stderr for the exact error", "rc": 1}}, "msg": "The following modules failed to execute: ansible.legacy.setup\n"}
2022-12-28 23:03:59,583 p=6807 u=kal n=ansible | PLAY RECAP *********************************************************************
2022-12-28 23:03:59,583 p=6807 u=kal n=ansible | krpz                       : ok=0    changed=0    unreachable=0    failed=1    skipped=0    rescued=0    ignored=0   
2022-12-28 23:04:21,542 p=6846 u=kal n=ansible | PLAY [localhost] ***************************************************************
2022-12-28 23:04:21,549 p=6846 u=kal n=ansible | TASK [Gathering Facts] *********************************************************
2022-12-28 23:04:21,743 p=6846 u=kal n=ansible | fatal: [krpz]: FAILED! => {"ansible_facts": {}, "changed": false, "failed_modules": {"ansible.legacy.setup": {"failed": true, "module_stderr": "sudo: a password is required\n", "module_stdout": "", "msg": "MODULE FAILURE\nSee stdout/stderr for the exact error", "rc": 1}}, "msg": "The following modules failed to execute: ansible.legacy.setup\n"}
2022-12-28 23:04:21,744 p=6846 u=kal n=ansible | PLAY RECAP *********************************************************************
2022-12-28 23:04:21,744 p=6846 u=kal n=ansible | krpz                       : ok=0    changed=0    unreachable=0    failed=1    skipped=0    rescued=0    ignored=0   
2022-12-28 23:06:04,257 p=7166 u=kal n=ansible | [WARNING]: Unable to parse /home/kal/dots/playbooks/hosts as an inventory
source

2022-12-28 23:06:04,257 p=7166 u=kal n=ansible | [WARNING]: No inventory was parsed, only implicit localhost is available

2022-12-28 23:06:04,259 p=7166 u=kal n=ansible | [WARNING]: provided hosts list is empty, only localhost is available. Note that
the implicit localhost does not match 'all'

2022-12-28 23:06:04,322 p=7166 u=kal n=ansible | PLAY [localhost] ***************************************************************
2022-12-28 23:06:04,329 p=7166 u=kal n=ansible | TASK [Gathering Facts] *********************************************************
2022-12-28 23:06:04,523 p=7166 u=kal n=ansible | fatal: [localhost]: FAILED! => {"ansible_facts": {}, "changed": false, "failed_modules": {"ansible.legacy.setup": {"failed": true, "module_stderr": "sudo: a password is required\n", "module_stdout": "", "msg": "MODULE FAILURE\nSee stdout/stderr for the exact error", "rc": 1}}, "msg": "The following modules failed to execute: ansible.legacy.setup\n"}
2022-12-28 23:06:04,523 p=7166 u=kal n=ansible | PLAY RECAP *********************************************************************
2022-12-28 23:06:04,523 p=7166 u=kal n=ansible | localhost                  : ok=0    changed=0    unreachable=0    failed=1    skipped=0    rescued=0    ignored=0   
2022-12-28 23:06:12,549 p=7205 u=kal n=ansible | PLAY [localhost] ***************************************************************
2022-12-28 23:06:12,556 p=7205 u=kal n=ansible | TASK [Gathering Facts] *********************************************************
2022-12-28 23:06:12,748 p=7205 u=kal n=ansible | fatal: [krpz]: FAILED! => {"ansible_facts": {}, "changed": false, "failed_modules": {"ansible.legacy.setup": {"failed": true, "module_stderr": "sudo: a password is required\n", "module_stdout": "", "msg": "MODULE FAILURE\nSee stdout/stderr for the exact error", "rc": 1}}, "msg": "The following modules failed to execute: ansible.legacy.setup\n"}
2022-12-28 23:06:12,749 p=7205 u=kal n=ansible | PLAY RECAP *********************************************************************
2022-12-28 23:06:12,749 p=7205 u=kal n=ansible | krpz                       : ok=0    changed=0    unreachable=0    failed=1    skipped=0    rescued=0    ignored=0   
2022-12-28 23:06:35,548 p=7259 u=kal n=ansible | ERROR! the playbook: playbook.yml could not be found
2022-12-28 23:06:40,856 p=7264 u=kal n=ansible | [WARNING]: Unable to parse /home/kal/dots/playbooks/hosts as an inventory
source

2022-12-28 23:06:40,856 p=7264 u=kal n=ansible | [WARNING]: No inventory was parsed, only implicit localhost is available

2022-12-28 23:06:40,859 p=7264 u=kal n=ansible | [WARNING]: provided hosts list is empty, only localhost is available. Note that
the implicit localhost does not match 'all'

2022-12-28 23:06:40,918 p=7264 u=kal n=ansible | PLAY [all] *********************************************************************
2022-12-28 23:06:40,918 p=7264 u=kal n=ansible | skipping: no hosts matched
2022-12-28 23:06:40,918 p=7264 u=kal n=ansible | PLAY RECAP *********************************************************************
2022-12-28 23:07:04,570 p=7286 u=kal n=ansible | PLAY [localhost] ***************************************************************
2022-12-28 23:07:04,577 p=7286 u=kal n=ansible | TASK [Gathering Facts] *********************************************************
2022-12-28 23:07:04,772 p=7286 u=kal n=ansible | fatal: [krpz]: FAILED! => {"ansible_facts": {}, "changed": false, "failed_modules": {"ansible.legacy.setup": {"failed": true, "module_stderr": "sudo: a password is required\n", "module_stdout": "", "msg": "MODULE FAILURE\nSee stdout/stderr for the exact error", "rc": 1}}, "msg": "The following modules failed to execute: ansible.legacy.setup\n"}
2022-12-28 23:07:04,773 p=7286 u=kal n=ansible | PLAY RECAP *********************************************************************
2022-12-28 23:07:04,773 p=7286 u=kal n=ansible | krpz                       : ok=0    changed=0    unreachable=0    failed=1    skipped=0    rescued=0    ignored=0   
2022-12-28 23:07:27,232 p=7331 u=kal n=ansible | PLAY [localhost] ***************************************************************
2022-12-28 23:07:27,239 p=7331 u=kal n=ansible | TASK [Gathering Facts] *********************************************************
2022-12-28 23:07:27,434 p=7331 u=kal n=ansible | fatal: [krpz]: FAILED! => {"ansible_facts": {}, "changed": false, "failed_modules": {"ansible.legacy.setup": {"failed": true, "module_stderr": "sudo: a password is required\n", "module_stdout": "", "msg": "MODULE FAILURE\nSee stdout/stderr for the exact error", "rc": 1}}, "msg": "The following modules failed to execute: ansible.legacy.setup\n"}
2022-12-28 23:07:27,435 p=7331 u=kal n=ansible | PLAY RECAP *********************************************************************
2022-12-28 23:07:27,435 p=7331 u=kal n=ansible | krpz                       : ok=0    changed=0    unreachable=0    failed=1    skipped=0    rescued=0    ignored=0   
2022-12-28 23:09:00,056 p=7422 u=kal n=ansible | ERROR! 'become_pass' is not a valid attribute for a Play

The error appears to be in '/home/kal/dots/playbooks/all.yaml': line 1, column 3, but may
be elsewhere in the file depending on the exact syntax problem.

The offending line appears to be:


- hosts: localhost
  ^ here

2022-12-28 23:09:32,922 p=7457 u=kal n=ansible | PLAY [localhost] ***************************************************************
2022-12-28 23:09:32,929 p=7457 u=kal n=ansible | TASK [Gathering Facts] *********************************************************
2022-12-28 23:09:33,120 p=7457 u=kal n=ansible | fatal: [krpz]: FAILED! => {"ansible_facts": {}, "changed": false, "failed_modules": {"ansible.legacy.setup": {"failed": true, "module_stderr": "sudo: a password is required\n", "module_stdout": "", "msg": "MODULE FAILURE\nSee stdout/stderr for the exact error", "rc": 1}}, "msg": "The following modules failed to execute: ansible.legacy.setup\n"}
2022-12-28 23:09:33,121 p=7457 u=kal n=ansible | PLAY RECAP *********************************************************************
2022-12-28 23:09:33,121 p=7457 u=kal n=ansible | krpz                       : ok=0    changed=0    unreachable=0    failed=1    skipped=0    rescued=0    ignored=0   
2022-12-28 23:09:46,033 p=8280 u=kal n=ansible | PLAY [localhost] ***************************************************************
2022-12-28 23:09:46,040 p=8280 u=kal n=ansible | TASK [Gathering Facts] *********************************************************
2022-12-28 23:09:49,789 p=8280 u=kal n=ansible | ok: [krpz]
2022-12-28 23:09:49,809 p=8280 u=kal n=ansible | TASK [Install shell utilities w/ apt] ******************************************
2022-12-28 23:09:51,002 p=8280 u=kal n=ansible | ok: [krpz]
2022-12-28 23:09:51,010 p=8280 u=kal n=ansible | TASK [Ensure the user has a zsh shell.] ****************************************
2022-12-28 23:09:51,264 p=8280 u=kal n=ansible | ok: [krpz]
2022-12-28 23:09:51,273 p=8280 u=kal n=ansible | TASK [Install shell utilities w/ apt] ******************************************
2022-12-28 23:09:52,458 p=8280 u=kal n=ansible | ok: [krpz]
2022-12-28 23:09:52,467 p=8280 u=kal n=ansible | TASK [Set environment managers] ************************************************
2022-12-28 23:09:53,242 p=8280 u=kal n=ansible | fatal: [krpz]: FAILED! => {"changed": false, "msg": "No package matching 'nvm' is available"}
2022-12-28 23:09:53,243 p=8280 u=kal n=ansible | PLAY RECAP *********************************************************************
2022-12-28 23:09:53,243 p=8280 u=kal n=ansible | krpz                       : ok=4    changed=0    unreachable=0    failed=1    skipped=0    rescued=0    ignored=0   
2022-12-28 23:10:02,897 p=8549 u=kal n=ansible | PLAY [localhost] ***************************************************************
2022-12-28 23:10:02,904 p=8549 u=kal n=ansible | TASK [Gathering Facts] *********************************************************
2022-12-28 23:10:06,587 p=8549 u=kal n=ansible | ok: [krpz]
2022-12-28 23:10:06,607 p=8549 u=kal n=ansible | TASK [Install shell utilities w/ apt] ******************************************
2022-12-28 23:10:07,776 p=8549 u=kal n=ansible | ok: [krpz]
2022-12-28 23:10:07,784 p=8549 u=kal n=ansible | TASK [Ensure the user has a zsh shell.] ****************************************
2022-12-28 23:10:08,002 p=8549 u=kal n=ansible | ok: [krpz]
2022-12-28 23:10:08,010 p=8549 u=kal n=ansible | TASK [Install shell utilities w/ apt] ******************************************
2022-12-28 23:10:09,033 p=8549 u=kal n=ansible | ok: [krpz]
2022-12-28 23:10:09,040 p=8549 u=kal n=ansible | TASK [Set environment managers] ************************************************
2022-12-28 23:10:12,921 p=8549 u=kal n=ansible | changed: [krpz]
2022-12-28 23:10:12,928 p=8549 u=kal n=ansible | TASK [Set environment managers] ************************************************
2022-12-28 23:10:16,564 p=8549 u=kal n=ansible | changed: [krpz]
2022-12-28 23:10:16,591 p=8549 u=kal n=ansible | PLAY RECAP *********************************************************************
2022-12-28 23:10:16,591 p=8549 u=kal n=ansible | krpz                       : ok=6    changed=2    unreachable=0    failed=0    skipped=0    rescued=0    ignored=0   
2022-12-28 23:14:23,248 p=9562 u=kal n=ansible | PLAY [localhost] ***************************************************************
2022-12-28 23:14:23,255 p=9562 u=kal n=ansible | TASK [Gathering Facts] *********************************************************
2022-12-28 23:14:26,924 p=9562 u=kal n=ansible | ok: [krpz]
2022-12-28 23:14:26,945 p=9562 u=kal n=ansible | TASK [Install shell utilities w/ apt] ******************************************
2022-12-28 23:14:28,094 p=9562 u=kal n=ansible | ok: [krpz]
2022-12-28 23:14:28,105 p=9562 u=kal n=ansible | TASK [Ensure the user has a zsh shell.] ****************************************
2022-12-28 23:14:28,322 p=9562 u=kal n=ansible | ok: [krpz]
2022-12-28 23:14:28,329 p=9562 u=kal n=ansible | TASK [Install shell utilities w/ apt] ******************************************
2022-12-28 23:14:29,347 p=9562 u=kal n=ansible | ok: [krpz]
2022-12-28 23:14:29,354 p=9562 u=kal n=ansible | TASK [Set environment managers] ************************************************
2022-12-28 23:14:30,395 p=9562 u=kal n=ansible | ok: [krpz]
2022-12-28 23:14:30,403 p=9562 u=kal n=ansible | TASK [Set environment managers] ************************************************
2022-12-28 23:14:31,418 p=9562 u=kal n=ansible | ok: [krpz]
2022-12-28 23:14:31,427 p=9562 u=kal n=ansible | TASK [Install VM techs] ********************************************************
2022-12-28 23:15:16,007 p=9562 u=kal n=ansible | changed: [krpz]
2022-12-28 23:15:16,035 p=9562 u=kal n=ansible | PLAY RECAP *********************************************************************
2022-12-28 23:15:16,035 p=9562 u=kal n=ansible | krpz                       : ok=7    changed=1    unreachable=0    failed=0    skipped=0    rescued=0    ignored=0   
2022-12-28 23:16:19,221 p=21619 u=kal n=ansible | PLAY [localhost] ***************************************************************
2022-12-28 23:16:19,229 p=21619 u=kal n=ansible | TASK [Gathering Facts] *********************************************************
2022-12-28 23:16:23,174 p=21619 u=kal n=ansible | ok: [krpz]
2022-12-28 23:16:23,195 p=21619 u=kal n=ansible | TASK [Install shell utilities w/ apt] ******************************************
2022-12-28 23:16:24,324 p=21619 u=kal n=ansible | ok: [krpz]
2022-12-28 23:16:24,332 p=21619 u=kal n=ansible | TASK [Ensure the user has a zsh shell.] ****************************************
2022-12-28 23:16:24,575 p=21619 u=kal n=ansible | ok: [krpz]
2022-12-28 23:16:24,583 p=21619 u=kal n=ansible | TASK [Install shell utilities w/ apt] ******************************************
2022-12-28 23:16:25,602 p=21619 u=kal n=ansible | ok: [krpz]
2022-12-28 23:16:25,610 p=21619 u=kal n=ansible | TASK [Set environment managers] ************************************************
2022-12-28 23:16:26,633 p=21619 u=kal n=ansible | ok: [krpz]
2022-12-28 23:16:26,641 p=21619 u=kal n=ansible | TASK [Set environment managers] ************************************************
2022-12-28 23:16:27,706 p=21619 u=kal n=ansible | ok: [krpz]
2022-12-28 23:16:27,714 p=21619 u=kal n=ansible | TASK [Install VM techs] ********************************************************
2022-12-28 23:16:28,755 p=21619 u=kal n=ansible | ok: [krpz]
2022-12-28 23:16:28,783 p=21619 u=kal n=ansible | PLAY RECAP *********************************************************************
2022-12-28 23:16:28,783 p=21619 u=kal n=ansible | krpz                       : ok=7    changed=0    unreachable=0    failed=0    skipped=0    rescued=0    ignored=0   
2022-12-28 23:17:44,518 p=22014 u=kal n=ansible | PLAY [localhost] ***************************************************************
2022-12-28 23:17:44,525 p=22014 u=kal n=ansible | TASK [Gathering Facts] *********************************************************
2022-12-28 23:17:48,469 p=22014 u=kal n=ansible | ok: [krpz]
2022-12-28 23:17:48,497 p=22014 u=kal n=ansible | TASK [Install shell utilities w/ apt] ******************************************
2022-12-28 23:17:49,651 p=22014 u=kal n=ansible | ok: [krpz]
2022-12-28 23:17:49,659 p=22014 u=kal n=ansible | TASK [Ensure the user has a zsh shell.] ****************************************
2022-12-28 23:17:49,903 p=22014 u=kal n=ansible | ok: [krpz]
2022-12-28 23:17:49,911 p=22014 u=kal n=ansible | TASK [Install shell utilities w/ apt] ******************************************
2022-12-28 23:17:51,037 p=22014 u=kal n=ansible | ok: [krpz]
2022-12-28 23:17:51,046 p=22014 u=kal n=ansible | TASK [Set environment managers] ************************************************
2022-12-28 23:17:52,104 p=22014 u=kal n=ansible | ok: [krpz]
2022-12-28 23:17:52,112 p=22014 u=kal n=ansible | TASK [Set environment managers] ************************************************
2022-12-28 23:17:53,161 p=22014 u=kal n=ansible | ok: [krpz]
2022-12-28 23:17:53,169 p=22014 u=kal n=ansible | TASK [Install VM techs] ********************************************************
2022-12-28 23:17:54,228 p=22014 u=kal n=ansible | ok: [krpz]
2022-12-28 23:17:54,236 p=22014 u=kal n=ansible | TASK [Creates directory] *******************************************************
2022-12-28 23:17:54,861 p=22014 u=kal n=ansible | changed: [krpz]
2022-12-28 23:17:54,888 p=22014 u=kal n=ansible | PLAY RECAP *********************************************************************
2022-12-28 23:17:54,889 p=22014 u=kal n=ansible | krpz                       : ok=8    changed=1    unreachable=0    failed=0    skipped=0    rescued=0    ignored=0   
2022-12-28 23:20:20,684 p=22464 u=kal n=ansible | ERROR! no module/action detected in task.

The error appears to be in '/home/kal/dots/playbooks/all.yaml': line 23, column 5, but may
be elsewhere in the file depending on the exact syntax problem.

The offending line appears to be:

        - openssh-server
  - name: Install other utilities (wget, curl, git, etc.)
    ^ here

2022-12-28 23:21:13,694 p=22492 u=kal n=ansible | PLAY [localhost] ***************************************************************
2022-12-28 23:21:13,701 p=22492 u=kal n=ansible | TASK [Gathering Facts] *********************************************************
2022-12-28 23:21:17,648 p=22492 u=kal n=ansible | ok: [krpz]
2022-12-28 23:21:17,669 p=22492 u=kal n=ansible | TASK [Install shell utilities w/ apt] ******************************************
2022-12-28 23:21:18,873 p=22492 u=kal n=ansible | ok: [krpz]
2022-12-28 23:21:18,881 p=22492 u=kal n=ansible | TASK [Ensure the user has a zsh shell.] ****************************************
2022-12-28 23:21:19,101 p=22492 u=kal n=ansible | ok: [krpz]
2022-12-28 23:21:19,109 p=22492 u=kal n=ansible | TASK [Install shell utilities w/ apt] ******************************************
2022-12-28 23:21:20,166 p=22492 u=kal n=ansible | ok: [krpz]
2022-12-28 23:21:20,174 p=22492 u=kal n=ansible | TASK [Install other utilities (wget, curl, git, etc.)] *************************
2022-12-28 23:21:21,282 p=22492 u=kal n=ansible | ok: [krpz]
2022-12-28 23:21:21,291 p=22492 u=kal n=ansible | TASK [Set environment managers] ************************************************
2022-12-28 23:21:22,328 p=22492 u=kal n=ansible | ok: [krpz]
2022-12-28 23:21:22,336 p=22492 u=kal n=ansible | TASK [Set environment managers] ************************************************
2022-12-28 23:21:23,400 p=22492 u=kal n=ansible | ok: [krpz]
2022-12-28 23:21:23,408 p=22492 u=kal n=ansible | TASK [Install VM techs] ********************************************************
2022-12-28 23:21:24,484 p=22492 u=kal n=ansible | ok: [krpz]
2022-12-28 23:21:24,492 p=22492 u=kal n=ansible | TASK [Creates MyApplications and bin directory] ********************************
2022-12-28 23:21:24,686 p=22492 u=kal n=ansible | ok: [krpz]
2022-12-28 23:21:24,695 p=22492 u=kal n=ansible | TASK [Install via shell scripts (Rust, tailscale)] *****************************
2022-12-28 23:21:37,347 p=22492 u=kal n=ansible | changed: [krpz]
2022-12-28 23:21:37,382 p=22492 u=kal n=ansible | PLAY RECAP *********************************************************************
2022-12-28 23:21:37,382 p=22492 u=kal n=ansible | krpz                       : ok=10   changed=1    unreachable=0    failed=0    skipped=0    rescued=0    ignored=0   
2022-12-28 23:22:01,814 p=24092 u=kal n=ansible | ERROR! unexpected parameter type in action: <class 'ansible.parsing.yaml.objects.AnsibleSequence'>

The error appears to be in '/home/kal/dots/playbooks/all.yaml': line 69, column 5, but may
be elsewhere in the file depending on the exact syntax problem.

The offending line appears to be:

  #     depth: 1
  - name: Install via shell scripts (Rust, tailscale)
    ^ here

2022-12-28 23:22:14,924 p=24101 u=kal n=ansible | ERROR! We were unable to read either as JSON nor YAML, these are the errors we got from each:
JSON: Expecting value: line 1 column 1 (char 0)

Syntax Error while loading YAML.
  did not find expected key

The error appears to be in '/home/kal/dots/playbooks/all.yaml': line 72, column 6, but may
be elsewhere in the file depending on the exact syntax problem.

The offending line appears to be:

      cmd: curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
     shell:
     ^ here

2022-12-28 23:22:40,101 p=24115 u=kal n=ansible | ERROR! unexpected parameter type in action: <class 'ansible.parsing.yaml.objects.AnsibleSequence'>

The error appears to be in '/home/kal/dots/playbooks/all.yaml': line 72, column 5, but may
be elsewhere in the file depending on the exact syntax problem.

The offending line appears to be:

      cmd: curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
  - name: Installl tailscale
    ^ here

2022-12-28 23:22:45,594 p=24124 u=kal n=ansible | PLAY [localhost] ***************************************************************
2022-12-28 23:22:45,602 p=24124 u=kal n=ansible | TASK [Gathering Facts] *********************************************************
2022-12-28 23:22:49,538 p=24124 u=kal n=ansible | ok: [krpz]
2022-12-28 23:22:49,563 p=24124 u=kal n=ansible | TASK [Install shell utilities w/ apt] ******************************************
2022-12-28 23:22:50,705 p=24124 u=kal n=ansible | ok: [krpz]
2022-12-28 23:22:50,713 p=24124 u=kal n=ansible | TASK [Ensure the user has a zsh shell.] ****************************************
2022-12-28 23:22:50,933 p=24124 u=kal n=ansible | ok: [krpz]
2022-12-28 23:22:50,941 p=24124 u=kal n=ansible | TASK [Install shell utilities w/ apt] ******************************************
2022-12-28 23:22:51,970 p=24124 u=kal n=ansible | ok: [krpz]
2022-12-28 23:22:51,978 p=24124 u=kal n=ansible | TASK [Install other utilities (wget, curl, git, etc.)] *************************
2022-12-28 23:22:53,104 p=24124 u=kal n=ansible | ok: [krpz]
2022-12-28 23:22:53,115 p=24124 u=kal n=ansible | TASK [Set environment managers] ************************************************
2022-12-28 23:22:54,283 p=24124 u=kal n=ansible | ok: [krpz]
2022-12-28 23:22:54,291 p=24124 u=kal n=ansible | TASK [Set environment managers] ************************************************
2022-12-28 23:22:55,344 p=24124 u=kal n=ansible | ok: [krpz]
2022-12-28 23:22:55,352 p=24124 u=kal n=ansible | TASK [Install VM techs] ********************************************************
2022-12-28 23:22:56,398 p=24124 u=kal n=ansible | ok: [krpz]
2022-12-28 23:22:56,405 p=24124 u=kal n=ansible | TASK [Creates MyApplications and bin directory] ********************************
2022-12-28 23:22:56,586 p=24124 u=kal n=ansible | ok: [krpz]
2022-12-28 23:22:56,593 p=24124 u=kal n=ansible | TASK [Install Rust] ************************************************************
2022-12-28 23:22:58,585 p=24124 u=kal n=ansible | fatal: [krpz]: FAILED! => {"changed": true, "cmd": "curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh", "delta": "0:00:01.816444", "end": "2022-12-28 23:22:58.567297", "msg": "non-zero return code", "rc": 1, "start": "2022-12-28 23:22:56.750853", "stderr": "info: downloading installer\nrustup: Unable to run interactively. Run with -y to accept defaults, --help for additional options", "stderr_lines": ["info: downloading installer", "rustup: Unable to run interactively. Run with -y to accept defaults, --help for additional options"], "stdout": "", "stdout_lines": []}
2022-12-28 23:22:58,586 p=24124 u=kal n=ansible | PLAY RECAP *********************************************************************
2022-12-28 23:22:58,586 p=24124 u=kal n=ansible | krpz                       : ok=9    changed=0    unreachable=0    failed=1    skipped=0    rescued=0    ignored=0   
2022-12-28 23:23:14,761 p=24619 u=kal n=ansible | PLAY [localhost] ***************************************************************
2022-12-28 23:23:14,768 p=24619 u=kal n=ansible | TASK [Gathering Facts] *********************************************************
2022-12-28 23:23:18,768 p=24619 u=kal n=ansible | ok: [krpz]
2022-12-28 23:23:18,789 p=24619 u=kal n=ansible | TASK [Install shell utilities w/ apt] ******************************************
2022-12-28 23:23:19,947 p=24619 u=kal n=ansible | ok: [krpz]
2022-12-28 23:23:19,955 p=24619 u=kal n=ansible | TASK [Ensure the user has a zsh shell.] ****************************************
2022-12-28 23:23:20,176 p=24619 u=kal n=ansible | ok: [krpz]
2022-12-28 23:23:20,184 p=24619 u=kal n=ansible | TASK [Install shell utilities w/ apt] ******************************************
2022-12-28 23:23:21,208 p=24619 u=kal n=ansible | ok: [krpz]
2022-12-28 23:23:21,215 p=24619 u=kal n=ansible | TASK [Install other utilities (wget, curl, git, etc.)] *************************
2022-12-28 23:23:22,232 p=24619 u=kal n=ansible | ok: [krpz]
2022-12-28 23:23:22,240 p=24619 u=kal n=ansible | TASK [Set environment managers] ************************************************
2022-12-28 23:23:23,250 p=24619 u=kal n=ansible | ok: [krpz]
2022-12-28 23:23:23,257 p=24619 u=kal n=ansible | TASK [Set environment managers] ************************************************
2022-12-28 23:23:24,293 p=24619 u=kal n=ansible | ok: [krpz]
2022-12-28 23:23:24,301 p=24619 u=kal n=ansible | TASK [Install VM techs] ********************************************************
2022-12-28 23:23:25,328 p=24619 u=kal n=ansible | ok: [krpz]
2022-12-28 23:23:25,335 p=24619 u=kal n=ansible | TASK [Install Rust] ************************************************************
2022-12-28 23:23:26,680 p=24619 u=kal n=ansible | fatal: [krpz]: FAILED! => {"changed": true, "cmd": "curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh", "delta": "0:00:01.146122", "end": "2022-12-28 23:23:26.639524", "msg": "non-zero return code", "rc": 1, "start": "2022-12-28 23:23:25.493402", "stderr": "info: downloading installer\nrustup: Unable to run interactively. Run with -y to accept defaults, --help for additional options", "stderr_lines": ["info: downloading installer", "rustup: Unable to run interactively. Run with -y to accept defaults, --help for additional options"], "stdout": "", "stdout_lines": []}
2022-12-28 23:23:26,682 p=24619 u=kal n=ansible | PLAY RECAP *********************************************************************
2022-12-28 23:23:26,683 p=24619 u=kal n=ansible | krpz                       : ok=8    changed=0    unreachable=0    failed=1    skipped=0    rescued=0    ignored=0   
2022-12-28 23:23:36,061 p=25078 u=kal n=ansible | PLAY [localhost] ***************************************************************
2022-12-28 23:23:36,068 p=25078 u=kal n=ansible | TASK [Gathering Facts] *********************************************************
2022-12-28 23:23:40,141 p=25078 u=kal n=ansible | ok: [krpz]
2022-12-28 23:23:40,162 p=25078 u=kal n=ansible | TASK [Install shell utilities w/ apt] ******************************************
2022-12-28 23:23:41,327 p=25078 u=kal n=ansible | ok: [krpz]
2022-12-28 23:23:41,335 p=25078 u=kal n=ansible | TASK [Ensure the user has a zsh shell.] ****************************************
2022-12-28 23:23:41,558 p=25078 u=kal n=ansible | ok: [krpz]
2022-12-28 23:23:41,565 p=25078 u=kal n=ansible | TASK [Install shell utilities w/ apt] ******************************************
2022-12-28 23:23:42,609 p=25078 u=kal n=ansible | ok: [krpz]
2022-12-28 23:23:42,617 p=25078 u=kal n=ansible | TASK [Install other utilities (wget, curl, git, etc.)] *************************
2022-12-28 23:23:43,637 p=25078 u=kal n=ansible | ok: [krpz]
2022-12-28 23:23:43,645 p=25078 u=kal n=ansible | TASK [Set environment managers] ************************************************
2022-12-28 23:23:44,681 p=25078 u=kal n=ansible | ok: [krpz]
2022-12-28 23:23:44,689 p=25078 u=kal n=ansible | TASK [Set environment managers] ************************************************
2022-12-28 23:23:45,701 p=25078 u=kal n=ansible | ok: [krpz]
2022-12-28 23:23:45,709 p=25078 u=kal n=ansible | TASK [Install VM techs] ********************************************************
2022-12-28 23:23:46,726 p=25078 u=kal n=ansible | ok: [krpz]
2022-12-28 23:23:46,734 p=25078 u=kal n=ansible | TASK [Install Rust] ************************************************************
2022-12-28 23:23:47,106 p=25078 u=kal n=ansible | fatal: [krpz]: FAILED! => {"changed": true, "cmd": "curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh -y", "delta": "0:00:00.179145", "end": "2022-12-28 23:23:47.071544", "msg": "non-zero return code", "rc": 2, "start": "2022-12-28 23:23:46.892399", "stderr": "sh: 0: Illegal option -y\ncurl: (23) Failure writing output to destination", "stderr_lines": ["sh: 0: Illegal option -y", "curl: (23) Failure writing output to destination"], "stdout": "", "stdout_lines": []}
2022-12-28 23:23:47,108 p=25078 u=kal n=ansible | PLAY RECAP *********************************************************************
2022-12-28 23:23:47,109 p=25078 u=kal n=ansible | krpz                       : ok=8    changed=0    unreachable=0    failed=1    skipped=0    rescued=0    ignored=0   
2022-12-28 23:26:40,016 p=26103 u=kal n=ansible | ERROR! We were unable to read either as JSON nor YAML, these are the errors we got from each:
JSON: Expecting value: line 1 column 1 (char 0)

Syntax Error while loading YAML.
  could not find expected ':'

The error appears to be in '/home/kal/dots/playbooks/all.yaml': line 22, column 3, but may
be elsewhere in the file depending on the exact syntax problem.

The offending line appears to be:

    $HOME/.zshrc
  - name: Install shell utilities w/ apt
  ^ here

2022-12-28 23:26:50,392 p=26128 u=kal n=ansible | ERROR! conflicting action statements: ansible.builtin.get_url, url

The error appears to be in '/home/kal/dots/playbooks/all.yaml': line 15, column 5, but may
be elsewhere in the file depending on the exact syntax problem.

The offending line appears to be:

      state: present
  - name: Download default .zshrc
    ^ here

2022-12-28 23:27:09,958 p=26153 u=kal n=ansible | PLAY [localhost] ***************************************************************
2022-12-28 23:27:09,966 p=26153 u=kal n=ansible | TASK [Gathering Facts] *********************************************************
2022-12-28 23:27:13,960 p=26153 u=kal n=ansible | ok: [krpz]
2022-12-28 23:27:13,981 p=26153 u=kal n=ansible | TASK [Install shell utilities w/ apt] ******************************************
2022-12-28 23:27:15,138 p=26153 u=kal n=ansible | ok: [krpz]
2022-12-28 23:27:15,146 p=26153 u=kal n=ansible | TASK [Ensure the user has a zsh shell.] ****************************************
2022-12-28 23:27:15,367 p=26153 u=kal n=ansible | ok: [krpz]
2022-12-28 23:27:15,375 p=26153 u=kal n=ansible | TASK [Download default .zshrc] *************************************************
2022-12-28 23:27:15,893 p=26153 u=kal n=ansible | changed: [krpz]
2022-12-28 23:27:15,902 p=26153 u=kal n=ansible | TASK [Install shell utilities w/ apt] ******************************************
2022-12-28 23:27:16,953 p=26153 u=kal n=ansible | ok: [krpz]
2022-12-28 23:27:16,961 p=26153 u=kal n=ansible | TASK [Install other utilities (wget, curl, git, etc.)] *************************
2022-12-28 23:27:18,001 p=26153 u=kal n=ansible | ok: [krpz]
2022-12-28 23:27:18,009 p=26153 u=kal n=ansible | TASK [Set environment managers] ************************************************
2022-12-28 23:27:19,042 p=26153 u=kal n=ansible | ok: [krpz]
2022-12-28 23:27:19,050 p=26153 u=kal n=ansible | TASK [Set environment managers] ************************************************
2022-12-28 23:27:20,088 p=26153 u=kal n=ansible | ok: [krpz]
2022-12-28 23:27:20,096 p=26153 u=kal n=ansible | TASK [Install VM techs] ********************************************************
2022-12-28 23:27:21,128 p=26153 u=kal n=ansible | ok: [krpz]
2022-12-28 23:27:21,137 p=26153 u=kal n=ansible | TASK [Install Rust] ************************************************************
2022-12-28 23:27:23,456 p=26153 u=kal n=ansible | fatal: [krpz]: FAILED! => {"changed": true, "cmd": "curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh", "delta": "0:00:02.146054", "end": "2022-12-28 23:27:23.444587", "msg": "non-zero return code", "rc": 1, "start": "2022-12-28 23:27:21.298533", "stderr": "info: downloading installer\nrustup: Unable to run interactively. Run with -y to accept defaults, --help for additional options", "stderr_lines": ["info: downloading installer", "rustup: Unable to run interactively. Run with -y to accept defaults, --help for additional options"], "stdout": "", "stdout_lines": []}
2022-12-28 23:27:23,457 p=26153 u=kal n=ansible | PLAY RECAP *********************************************************************
2022-12-28 23:27:23,457 p=26153 u=kal n=ansible | krpz                       : ok=9    changed=1    unreachable=0    failed=1    skipped=0    rescued=0    ignored=0   
2022-12-28 23:29:48,782 p=27064 u=kal n=ansible | ERROR! We were unable to read either as JSON nor YAML, these are the errors we got from each:
JSON: Expecting value: line 1 column 1 (char 0)

Syntax Error while loading YAML.
  did not find expected key

The error appears to be in '/home/kal/dots/playbooks/all.yaml': line 43, column 4, but may
be elsewhere in the file depending on the exact syntax problem.

The offending line appears to be:

  - name: Install NVM
   shell:
   ^ here

2022-12-28 23:29:55,211 p=27072 u=kal n=ansible | PLAY [localhost] ***************************************************************
2022-12-28 23:29:55,219 p=27072 u=kal n=ansible | TASK [Gathering Facts] *********************************************************
2022-12-28 23:29:59,164 p=27072 u=kal n=ansible | ok: [krpz]
2022-12-28 23:29:59,188 p=27072 u=kal n=ansible | TASK [Install shell utilities w/ apt] ******************************************
2022-12-28 23:30:00,328 p=27072 u=kal n=ansible | ok: [krpz]
2022-12-28 23:30:00,336 p=27072 u=kal n=ansible | TASK [Ensure the user has a zsh shell.] ****************************************
2022-12-28 23:30:00,579 p=27072 u=kal n=ansible | ok: [krpz]
2022-12-28 23:30:00,586 p=27072 u=kal n=ansible | TASK [Download default .zshrc] *************************************************
2022-12-28 23:30:00,929 p=27072 u=kal n=ansible | ok: [krpz]
2022-12-28 23:30:00,938 p=27072 u=kal n=ansible | TASK [Install shell utilities w/ apt] ******************************************
2022-12-28 23:30:02,023 p=27072 u=kal n=ansible | ok: [krpz]
2022-12-28 23:30:02,032 p=27072 u=kal n=ansible | TASK [Install other utilities (wget, curl, git, etc.)] *************************
2022-12-28 23:30:03,098 p=27072 u=kal n=ansible | ok: [krpz]
2022-12-28 23:30:03,106 p=27072 u=kal n=ansible | TASK [Set environment managers (direnv, npm, conda)] ***************************
2022-12-28 23:30:04,127 p=27072 u=kal n=ansible | ok: [krpz]
2022-12-28 23:30:04,134 p=27072 u=kal n=ansible | TASK [Install NVM] *************************************************************
2022-12-28 23:30:04,517 p=27072 u=kal n=ansible | fatal: [krpz]: FAILED! => {"changed": true, "cmd": "curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.3/install.sh | zsh", "delta": "0:00:00.138486", "end": "2022-12-28 23:30:04.484880", "msg": "non-zero return code", "rc": 1, "start": "2022-12-28 23:30:04.346394", "stderr": "  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current\n                                 Dload  Upload   Total   Spent    Left  Speed\n\r  0     0    0     0    0     0      0      0 --:--:-- --:--:-- --:--:--     0\r100 15916  100 15916    0     0   120k      0 --:--:-- --:--:-- --:--:--  120k\nError: the install instructions explicitly say to pipe the install script to `bash`; please follow them", "stderr_lines": ["  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current", "                                 Dload  Upload   Total   Spent    Left  Speed", "", "  0     0    0     0    0     0      0      0 --:--:-- --:--:-- --:--:--     0", "100 15916  100 15916    0     0   120k      0 --:--:-- --:--:-- --:--:--  120k", "Error: the install instructions explicitly say to pipe the install script to `bash`; please follow them"], "stdout": "", "stdout_lines": []}
2022-12-28 23:30:04,519 p=27072 u=kal n=ansible | PLAY RECAP *********************************************************************
2022-12-28 23:30:04,520 p=27072 u=kal n=ansible | krpz                       : ok=7    changed=0    unreachable=0    failed=1    skipped=0    rescued=0    ignored=0   
2022-12-28 23:30:25,485 p=27473 u=kal n=ansible | PLAY [localhost] ***************************************************************
2022-12-28 23:30:25,493 p=27473 u=kal n=ansible | TASK [Gathering Facts] *********************************************************
2022-12-28 23:30:29,411 p=27473 u=kal n=ansible | ok: [krpz]
2022-12-28 23:30:29,434 p=27473 u=kal n=ansible | TASK [Install shell utilities w/ apt] ******************************************
2022-12-28 23:30:30,570 p=27473 u=kal n=ansible | ok: [krpz]
2022-12-28 23:30:30,578 p=27473 u=kal n=ansible | TASK [Ensure the user has a zsh shell.] ****************************************
2022-12-28 23:30:30,799 p=27473 u=kal n=ansible | ok: [krpz]
2022-12-28 23:30:30,806 p=27473 u=kal n=ansible | TASK [Download default .zshrc] *************************************************
2022-12-28 23:30:31,212 p=27473 u=kal n=ansible | ok: [krpz]
2022-12-28 23:30:31,221 p=27473 u=kal n=ansible | TASK [Install shell utilities w/ apt] ******************************************
2022-12-28 23:30:32,272 p=27473 u=kal n=ansible | ok: [krpz]
2022-12-28 23:30:32,280 p=27473 u=kal n=ansible | TASK [Install other utilities (wget, curl, git, etc.)] *************************
2022-12-28 23:30:33,311 p=27473 u=kal n=ansible | ok: [krpz]
2022-12-28 23:30:33,318 p=27473 u=kal n=ansible | TASK [Set environment managers (direnv, npm, conda)] ***************************
2022-12-28 23:30:34,374 p=27473 u=kal n=ansible | ok: [krpz]
2022-12-28 23:30:34,382 p=27473 u=kal n=ansible | TASK [Install NVM] *************************************************************
2022-12-28 23:30:34,735 p=27473 u=kal n=ansible | fatal: [krpz]: FAILED! => {"changed": true, "cmd": "curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.3/install.sh | sh", "delta": "0:00:00.159678", "end": "2022-12-28 23:30:34.698904", "msg": "non-zero return code", "rc": 1, "start": "2022-12-28 23:30:34.539226", "stderr": "  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current\n                                 Dload  Upload   Total   Spent    Left  Speed\n\r  0     0    0     0    0     0      0      0 --:--:-- --:--:-- --:--:--     0\r100 15916  100 15916    0     0   103k      0 --:--:-- --:--:-- --:--:--  104k\nError: the install instructions explicitly say to pipe the install script to `bash`; please follow them", "stderr_lines": ["  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current", "                                 Dload  Upload   Total   Spent    Left  Speed", "", "  0     0    0     0    0     0      0      0 --:--:-- --:--:-- --:--:--     0", "100 15916  100 15916    0     0   103k      0 --:--:-- --:--:-- --:--:--  104k", "Error: the install instructions explicitly say to pipe the install script to `bash`; please follow them"], "stdout": "", "stdout_lines": []}
2022-12-28 23:30:34,736 p=27473 u=kal n=ansible | PLAY RECAP *********************************************************************
2022-12-28 23:30:34,736 p=27473 u=kal n=ansible | krpz                       : ok=7    changed=0    unreachable=0    failed=1    skipped=0    rescued=0    ignored=0   
2022-12-28 23:30:44,149 p=27848 u=kal n=ansible | PLAY [localhost] ***************************************************************
2022-12-28 23:30:44,157 p=27848 u=kal n=ansible | TASK [Gathering Facts] *********************************************************
2022-12-28 23:30:48,157 p=27848 u=kal n=ansible | ok: [krpz]
2022-12-28 23:30:48,178 p=27848 u=kal n=ansible | TASK [Install shell utilities w/ apt] ******************************************
2022-12-28 23:30:49,342 p=27848 u=kal n=ansible | ok: [krpz]
2022-12-28 23:30:49,351 p=27848 u=kal n=ansible | TASK [Ensure the user has a zsh shell.] ****************************************
2022-12-28 23:30:49,574 p=27848 u=kal n=ansible | ok: [krpz]
2022-12-28 23:30:49,582 p=27848 u=kal n=ansible | TASK [Download default .zshrc] *************************************************
2022-12-28 23:30:49,938 p=27848 u=kal n=ansible | ok: [krpz]
2022-12-28 23:30:49,967 p=27848 u=kal n=ansible | TASK [Install shell utilities w/ apt] ******************************************
2022-12-28 23:30:51,045 p=27848 u=kal n=ansible | ok: [krpz]
2022-12-28 23:30:51,053 p=27848 u=kal n=ansible | TASK [Install other utilities (wget, curl, git, etc.)] *************************
2022-12-28 23:30:52,184 p=27848 u=kal n=ansible | ok: [krpz]
2022-12-28 23:30:52,192 p=27848 u=kal n=ansible | TASK [Set environment managers (direnv, npm, conda)] ***************************
2022-12-28 23:30:53,428 p=27848 u=kal n=ansible | ok: [krpz]
2022-12-28 23:30:53,436 p=27848 u=kal n=ansible | TASK [Install NVM] *************************************************************
2022-12-28 23:30:54,713 p=27848 u=kal n=ansible | changed: [krpz]
2022-12-28 23:30:54,720 p=27848 u=kal n=ansible | TASK [Install utilities (htop, tree, pstree, etc.)] ****************************
2022-12-28 23:30:55,916 p=27848 u=kal n=ansible | ok: [krpz]
2022-12-28 23:30:55,924 p=27848 u=kal n=ansible | TASK [Install VM techs] ********************************************************
2022-12-28 23:30:56,960 p=27848 u=kal n=ansible | ok: [krpz]
2022-12-28 23:30:56,968 p=27848 u=kal n=ansible | TASK [Install Rust] ************************************************************
2022-12-28 23:30:59,105 p=27848 u=kal n=ansible | fatal: [krpz]: FAILED! => {"changed": true, "cmd": "curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh", "delta": "0:00:02.040437", "end": "2022-12-28 23:30:59.088148", "msg": "non-zero return code", "rc": 1, "start": "2022-12-28 23:30:57.047711", "stderr": "info: downloading installer\nrustup: Unable to run interactively. Run with -y to accept defaults, --help for additional options", "stderr_lines": ["info: downloading installer", "rustup: Unable to run interactively. Run with -y to accept defaults, --help for additional options"], "stdout": "", "stdout_lines": []}
2022-12-28 23:30:59,105 p=27848 u=kal n=ansible | PLAY RECAP *********************************************************************
2022-12-28 23:30:59,105 p=27848 u=kal n=ansible | krpz                       : ok=10   changed=1    unreachable=0    failed=1    skipped=0    rescued=0    ignored=0   
2022-12-28 23:37:24,883 p=29534 u=kal n=ansible | PLAY [localhost] ***************************************************************
2022-12-28 23:37:24,891 p=29534 u=kal n=ansible | TASK [Gathering Facts] *********************************************************
2022-12-28 23:37:28,802 p=29534 u=kal n=ansible | ok: [krpz]
2022-12-28 23:37:28,823 p=29534 u=kal n=ansible | TASK [Install shell utilities w/ apt] ******************************************
2022-12-28 23:37:29,983 p=29534 u=kal n=ansible | ok: [krpz]
2022-12-28 23:37:29,992 p=29534 u=kal n=ansible | TASK [Ensure the user has a zsh shell.] ****************************************
2022-12-28 23:37:30,214 p=29534 u=kal n=ansible | ok: [krpz]
2022-12-28 23:37:30,222 p=29534 u=kal n=ansible | TASK [Download default .zshrc] *************************************************
2022-12-28 23:37:30,648 p=29534 u=kal n=ansible | ok: [krpz]
2022-12-28 23:37:30,677 p=29534 u=kal n=ansible | TASK [Install shell utilities w/ apt] ******************************************
2022-12-28 23:37:31,759 p=29534 u=kal n=ansible | ok: [krpz]
2022-12-28 23:37:31,767 p=29534 u=kal n=ansible | TASK [Install other utilities (wget, curl, git, etc.)] *************************
2022-12-28 23:37:32,817 p=29534 u=kal n=ansible | ok: [krpz]
2022-12-28 23:37:32,825 p=29534 u=kal n=ansible | TASK [Set environment managers (direnv, npm, conda)] ***************************
2022-12-28 23:37:33,882 p=29534 u=kal n=ansible | ok: [krpz]
2022-12-28 23:37:33,890 p=29534 u=kal n=ansible | TASK [Install NVM] *************************************************************
2022-12-28 23:37:34,712 p=29534 u=kal n=ansible | changed: [krpz]
2022-12-28 23:37:34,719 p=29534 u=kal n=ansible | TASK [Install utilities (htop, tree, pstree, etc.)] ****************************
2022-12-28 23:37:35,830 p=29534 u=kal n=ansible | ok: [krpz]
2022-12-28 23:37:35,840 p=29534 u=kal n=ansible | TASK [Install VM techs] ********************************************************
2022-12-28 23:37:36,883 p=29534 u=kal n=ansible | ok: [krpz]
2022-12-28 23:37:36,891 p=29534 u=kal n=ansible | TASK [Install Rust] ************************************************************
2022-12-28 23:37:38,173 p=29534 u=kal n=ansible | fatal: [krpz]: FAILED! => {"changed": true, "cmd": "curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh", "delta": "0:00:01.198078", "end": "2022-12-28 23:37:38.161487", "msg": "non-zero return code", "rc": 1, "start": "2022-12-28 23:37:36.963409", "stderr": "info: downloading installer\nrustup: Unable to run interactively. Run with -y to accept defaults, --help for additional options", "stderr_lines": ["info: downloading installer", "rustup: Unable to run interactively. Run with -y to accept defaults, --help for additional options"], "stdout": "", "stdout_lines": []}
2022-12-28 23:37:38,174 p=29534 u=kal n=ansible | PLAY RECAP *********************************************************************
2022-12-28 23:37:38,174 p=29534 u=kal n=ansible | krpz                       : ok=10   changed=1    unreachable=0    failed=1    skipped=0    rescued=0    ignored=0   
2022-12-28 23:37:39,673 p=30093 u=kal n=ansible | PLAY [localhost] ***************************************************************
2022-12-28 23:37:39,681 p=30093 u=kal n=ansible | TASK [Gathering Facts] *********************************************************
2022-12-28 23:37:42,099 p=30093 u=kal n=ansible | ok: [krpz]
2022-12-28 23:37:42,120 p=30093 u=kal n=ansible | TASK [Install shell utilities w/ apt] ******************************************
2022-12-28 23:37:43,245 p=30093 u=kal n=ansible | ok: [krpz]
2022-12-28 23:37:43,253 p=30093 u=kal n=ansible | TASK [Ensure the user has a zsh shell.] ****************************************
2022-12-28 23:37:43,473 p=30093 u=kal n=ansible | ok: [krpz]
2022-12-28 23:37:43,480 p=30093 u=kal n=ansible | TASK [Download default .zshrc] *************************************************
2022-12-28 23:37:43,995 p=30093 u=kal n=ansible | ok: [krpz]
2022-12-28 23:37:44,022 p=30093 u=kal n=ansible | TASK [Install shell utilities w/ apt] ******************************************
2022-12-28 23:37:45,059 p=30093 u=kal n=ansible | ok: [krpz]
2022-12-28 23:37:45,067 p=30093 u=kal n=ansible | TASK [Install other utilities (wget, curl, git, etc.)] *************************
2022-12-28 23:37:46,093 p=30093 u=kal n=ansible | ok: [krpz]
2022-12-28 23:37:46,101 p=30093 u=kal n=ansible | TASK [Set environment managers (direnv, npm, conda)] ***************************
2022-12-28 23:37:47,148 p=30093 u=kal n=ansible | ok: [krpz]
2022-12-28 23:37:47,156 p=30093 u=kal n=ansible | TASK [Install NVM] *************************************************************
2022-12-28 23:37:48,022 p=30093 u=kal n=ansible | changed: [krpz]
2022-12-28 23:37:48,047 p=30093 u=kal n=ansible | TASK [Install utilities (htop, tree, pstree, etc.)] ****************************
2022-12-28 23:37:49,105 p=30093 u=kal n=ansible | ok: [krpz]
2022-12-28 23:37:49,113 p=30093 u=kal n=ansible | TASK [Install VM techs] ********************************************************
2022-12-28 23:37:50,154 p=30093 u=kal n=ansible | ok: [krpz]
2022-12-28 23:37:50,162 p=30093 u=kal n=ansible | TASK [Installl tailscale] ******************************************************
2022-12-28 23:37:55,355 p=30093 u=kal n=ansible | changed: [krpz]
2022-12-28 23:37:55,363 p=30093 u=kal n=ansible | TASK [Creates MyApplications and bin directory] ********************************
2022-12-28 23:37:55,544 p=30093 u=kal n=ansible | ok: [krpz]
2022-12-28 23:37:55,584 p=30093 u=kal n=ansible | PLAY RECAP *********************************************************************
2022-12-28 23:37:55,584 p=30093 u=kal n=ansible | krpz                       : ok=12   changed=2    unreachable=0    failed=0    skipped=0    rescued=0    ignored=0   
2022-12-28 23:39:24,519 p=31549 u=kal n=ansible | PLAY [localhost] ***************************************************************
2022-12-28 23:39:24,526 p=31549 u=kal n=ansible | TASK [Gathering Facts] *********************************************************
2022-12-28 23:39:28,506 p=31549 u=kal n=ansible | ok: [krpz]
2022-12-28 23:39:28,527 p=31549 u=kal n=ansible | TASK [Install shell utilities w/ apt] ******************************************
2022-12-28 23:39:29,672 p=31549 u=kal n=ansible | ok: [krpz]
2022-12-28 23:39:29,680 p=31549 u=kal n=ansible | TASK [Ensure the user has a zsh shell.] ****************************************
2022-12-28 23:39:29,900 p=31549 u=kal n=ansible | ok: [krpz]
2022-12-28 23:39:29,907 p=31549 u=kal n=ansible | TASK [Download default .zshrc] *************************************************
2022-12-28 23:39:30,301 p=31549 u=kal n=ansible | ok: [krpz]
2022-12-28 23:39:30,330 p=31549 u=kal n=ansible | TASK [Install shell utilities w/ apt] ******************************************
2022-12-28 23:39:31,396 p=31549 u=kal n=ansible | ok: [krpz]
2022-12-28 23:39:31,404 p=31549 u=kal n=ansible | TASK [Install other utilities (wget, curl, git, etc.)] *************************
2022-12-28 23:39:32,428 p=31549 u=kal n=ansible | ok: [krpz]
2022-12-28 23:39:32,436 p=31549 u=kal n=ansible | TASK [Set environment managers (direnv, npm, conda)] ***************************
2022-12-28 23:39:33,471 p=31549 u=kal n=ansible | ok: [krpz]
2022-12-28 23:39:33,479 p=31549 u=kal n=ansible | TASK [Install NVM] *************************************************************
2022-12-28 23:39:34,415 p=31549 u=kal n=ansible | changed: [krpz]
2022-12-28 23:39:34,433 p=31549 u=kal n=ansible | TASK [Install utilities (htop, tree, pstree, etc.)] ****************************
2022-12-28 23:39:35,502 p=31549 u=kal n=ansible | ok: [krpz]
2022-12-28 23:39:35,509 p=31549 u=kal n=ansible | TASK [Install VM techs] ********************************************************
2022-12-28 23:39:36,534 p=31549 u=kal n=ansible | ok: [krpz]
2022-12-28 23:39:36,542 p=31549 u=kal n=ansible | TASK [Install tailscale] *******************************************************
2022-12-28 23:39:40,410 p=31549 u=kal n=ansible | changed: [krpz]
2022-12-28 23:39:40,418 p=31549 u=kal n=ansible | TASK [Install editor, markdown tools, etc. (pandoc, lynx, etc.)] ***************
2022-12-28 23:39:46,026 p=31549 u=kal n=ansible | changed: [krpz]
2022-12-28 23:39:46,034 p=31549 u=kal n=ansible | TASK [Creates MyApplications and bin directory] ********************************
2022-12-28 23:39:46,212 p=31549 u=kal n=ansible | ok: [krpz]
2022-12-28 23:39:46,253 p=31549 u=kal n=ansible | PLAY RECAP *********************************************************************
2022-12-28 23:39:46,253 p=31549 u=kal n=ansible | krpz                       : ok=13   changed=3    unreachable=0    failed=0    skipped=0    rescued=0    ignored=0   
2022-12-29 23:19:01,299 p=67958 u=kal n=ansible | ERROR! the playbook: playbooks/all.yaml could not be found
2022-12-29 23:19:09,733 p=67962 u=kal n=ansible | PLAY [localhost] *************************************************************************************************************************************
2022-12-29 23:19:09,741 p=67962 u=kal n=ansible | TASK [Gathering Facts] *******************************************************************************************************************************
2022-12-29 23:19:13,649 p=67962 u=kal n=ansible | ok: [krpz]
2022-12-29 23:19:13,673 p=67962 u=kal n=ansible | TASK [Install shell utilities w/ apt] ****************************************************************************************************************
2022-12-29 23:19:14,841 p=67962 u=kal n=ansible | ok: [krpz]
2022-12-29 23:19:14,849 p=67962 u=kal n=ansible | TASK [Ensure the user has a zsh shell.] **************************************************************************************************************
2022-12-29 23:19:15,071 p=67962 u=kal n=ansible | ok: [krpz]
2022-12-29 23:19:15,078 p=67962 u=kal n=ansible | TASK [Download default .zshrc] ***********************************************************************************************************************
2022-12-29 23:19:15,538 p=67962 u=kal n=ansible | ok: [krpz]
2022-12-29 23:19:15,565 p=67962 u=kal n=ansible | TASK [Install shell utilities w/ apt] ****************************************************************************************************************
2022-12-29 23:19:16,625 p=67962 u=kal n=ansible | ok: [krpz]
2022-12-29 23:19:16,633 p=67962 u=kal n=ansible | TASK [Install other utilities (wget, curl, git, etc.)] ***********************************************************************************************
2022-12-29 23:19:20,474 p=67962 u=kal n=ansible | changed: [krpz]
2022-12-29 23:19:20,482 p=67962 u=kal n=ansible | TASK [Set environment managers (direnv, npm, conda)] *************************************************************************************************
2022-12-29 23:19:21,509 p=67962 u=kal n=ansible | ok: [krpz]
2022-12-29 23:19:21,517 p=67962 u=kal n=ansible | TASK [Install NVM] ***********************************************************************************************************************************
2022-12-29 23:19:21,689 p=67962 u=kal n=ansible | ok: [krpz]
2022-12-29 23:19:21,696 p=67962 u=kal n=ansible | TASK [Install utilities (htop, tree, pstree, etc.)] **************************************************************************************************
2022-12-29 23:19:22,715 p=67962 u=kal n=ansible | ok: [krpz]
2022-12-29 23:19:22,723 p=67962 u=kal n=ansible | TASK [Install VM techs] ******************************************************************************************************************************
2022-12-29 23:19:23,721 p=67962 u=kal n=ansible | ok: [krpz]
2022-12-29 23:19:23,729 p=67962 u=kal n=ansible | TASK [Install Rust] **********************************************************************************************************************************
2022-12-29 23:19:23,913 p=67962 u=kal n=ansible | An exception occurred during task execution. To see the full traceback, use -vvv. The error was: ImportError: No module named pexpect
2022-12-29 23:19:23,913 p=67962 u=kal n=ansible | fatal: [krpz]: FAILED! => {"changed": false, "msg": "Failed to import the required Python library (pexpect) on KRPZ's Python /usr/bin/python2. Please read the module documentation and install it in the appropriate location. If the required library is installed, but Ansible is using the wrong Python interpreter, please consult the documentation on ansible_python_interpreter"}
2022-12-29 23:19:23,914 p=67962 u=kal n=ansible | PLAY RECAP *******************************************************************************************************************************************
2022-12-29 23:19:23,914 p=67962 u=kal n=ansible | krpz                       : ok=10   changed=1    unreachable=0    failed=1    skipped=0    rescued=0    ignored=0   
2022-12-29 23:21:41,105 p=68966 u=kal n=ansible | ERROR! We were unable to read either as JSON nor YAML, these are the errors we got from each:
JSON: Expecting value: line 1 column 1 (char 0)

Syntax Error while loading YAML.
  did not find expected key

The error appears to be in '/home/kal/MyApplications/dotfiles/playbooks/all.yaml': line 74, column 5, but may
be elsewhere in the file depending on the exact syntax problem.

The offending line appears to be:

  - name: Install Rust
    - expect:
    ^ here

2022-12-29 23:22:06,507 p=69013 u=kal n=ansible | ERROR! We were unable to read either as JSON nor YAML, these are the errors we got from each:
JSON: Expecting value: line 1 column 1 (char 0)

Syntax Error while loading YAML.
  did not find expected key

The error appears to be in '/home/kal/MyApplications/dotfiles/playbooks/all.yaml': line 74, column 5, but may
be elsewhere in the file depending on the exact syntax problem.

The offending line appears to be:

  - name: Install Rust
    - ansible.builtin.expect:
    ^ here

2022-12-29 23:22:17,992 p=69042 u=kal n=ansible | PLAY [localhost] *************************************************************************************************************************************
2022-12-29 23:22:17,999 p=69042 u=kal n=ansible | TASK [Gathering Facts] *******************************************************************************************************************************
2022-12-29 23:22:21,981 p=69042 u=kal n=ansible | ok: [krpz]
2022-12-29 23:22:22,003 p=69042 u=kal n=ansible | TASK [Install shell utilities w/ apt] ****************************************************************************************************************
2022-12-29 23:22:23,163 p=69042 u=kal n=ansible | ok: [krpz]
2022-12-29 23:22:23,171 p=69042 u=kal n=ansible | TASK [Ensure the user has a zsh shell.] **************************************************************************************************************
2022-12-29 23:22:23,391 p=69042 u=kal n=ansible | ok: [krpz]
2022-12-29 23:22:23,399 p=69042 u=kal n=ansible | TASK [Download default .zshrc] ***********************************************************************************************************************
2022-12-29 23:22:23,797 p=69042 u=kal n=ansible | ok: [krpz]
2022-12-29 23:22:23,806 p=69042 u=kal n=ansible | TASK [Install shell utilities w/ apt] ****************************************************************************************************************
2022-12-29 23:22:24,839 p=69042 u=kal n=ansible | ok: [krpz]
2022-12-29 23:22:24,847 p=69042 u=kal n=ansible | TASK [Install other utilities (wget, curl, git, etc.)] ***********************************************************************************************
2022-12-29 23:22:25,878 p=69042 u=kal n=ansible | ok: [krpz]
2022-12-29 23:22:25,886 p=69042 u=kal n=ansible | TASK [Set environment managers (direnv, npm, conda)] *************************************************************************************************
2022-12-29 23:22:26,906 p=69042 u=kal n=ansible | ok: [krpz]
2022-12-29 23:22:26,913 p=69042 u=kal n=ansible | TASK [Install NVM] ***********************************************************************************************************************************
2022-12-29 23:22:27,084 p=69042 u=kal n=ansible | ok: [krpz]
2022-12-29 23:22:27,091 p=69042 u=kal n=ansible | TASK [Install utilities (htop, tree, pstree, etc.)] **************************************************************************************************
2022-12-29 23:22:28,105 p=69042 u=kal n=ansible | ok: [krpz]
2022-12-29 23:22:28,113 p=69042 u=kal n=ansible | TASK [Install VM techs] ******************************************************************************************************************************
2022-12-29 23:22:29,149 p=69042 u=kal n=ansible | ok: [krpz]
2022-12-29 23:22:29,157 p=69042 u=kal n=ansible | TASK [Install Rust] **********************************************************************************************************************************
2022-12-29 23:22:29,326 p=69042 u=kal n=ansible | An exception occurred during task execution. To see the full traceback, use -vvv. The error was: ImportError: No module named pexpect
2022-12-29 23:22:29,326 p=69042 u=kal n=ansible | fatal: [krpz]: FAILED! => {"changed": false, "msg": "Failed to import the required Python library (pexpect) on KRPZ's Python /usr/bin/python2. Please read the module documentation and install it in the appropriate location. If the required library is installed, but Ansible is using the wrong Python interpreter, please consult the documentation on ansible_python_interpreter"}
2022-12-29 23:22:29,327 p=69042 u=kal n=ansible | PLAY RECAP *******************************************************************************************************************************************
2022-12-29 23:22:29,327 p=69042 u=kal n=ansible | krpz                       : ok=10   changed=0    unreachable=0    failed=1    skipped=0    rescued=0    ignored=0   
2022-12-29 23:24:47,934 p=69647 u=kal n=ansible | PLAY [localhost] *************************************************************************************************************************************
2022-12-29 23:24:47,942 p=69647 u=kal n=ansible | TASK [Gathering Facts] *******************************************************************************************************************************
2022-12-29 23:24:51,894 p=69647 u=kal n=ansible | ok: [krpz]
2022-12-29 23:24:51,922 p=69647 u=kal n=ansible | TASK [Install shell utilities w/ apt] ****************************************************************************************************************
2022-12-29 23:24:53,066 p=69647 u=kal n=ansible | ok: [krpz]
2022-12-29 23:24:53,074 p=69647 u=kal n=ansible | TASK [Ensure the user has a zsh shell.] **************************************************************************************************************
2022-12-29 23:24:53,292 p=69647 u=kal n=ansible | ok: [krpz]
2022-12-29 23:24:53,300 p=69647 u=kal n=ansible | TASK [Download default .zshrc] ***********************************************************************************************************************
2022-12-29 23:24:53,791 p=69647 u=kal n=ansible | ok: [krpz]
2022-12-29 23:24:53,800 p=69647 u=kal n=ansible | TASK [Install shell utilities w/ apt] ****************************************************************************************************************
2022-12-29 23:24:54,881 p=69647 u=kal n=ansible | ok: [krpz]
2022-12-29 23:24:54,889 p=69647 u=kal n=ansible | TASK [Install other utilities (wget, curl, git, etc.)] ***********************************************************************************************
2022-12-29 23:24:55,918 p=69647 u=kal n=ansible | ok: [krpz]
2022-12-29 23:24:55,926 p=69647 u=kal n=ansible | TASK [Set environment managers (direnv, npm, conda)] *************************************************************************************************
2022-12-29 23:24:56,938 p=69647 u=kal n=ansible | ok: [krpz]
2022-12-29 23:24:56,946 p=69647 u=kal n=ansible | TASK [Install NVM] ***********************************************************************************************************************************
2022-12-29 23:24:57,115 p=69647 u=kal n=ansible | ok: [krpz]
2022-12-29 23:24:57,122 p=69647 u=kal n=ansible | TASK [Install utilities (htop, tree, pstree, etc.)] **************************************************************************************************
2022-12-29 23:24:58,133 p=69647 u=kal n=ansible | ok: [krpz]
2022-12-29 23:24:58,141 p=69647 u=kal n=ansible | TASK [Install VM techs] ******************************************************************************************************************************
2022-12-29 23:24:59,154 p=69647 u=kal n=ansible | ok: [krpz]
2022-12-29 23:24:59,161 p=69647 u=kal n=ansible | TASK [Install Rust] **********************************************************************************************************************************
2022-12-29 23:24:59,357 p=69647 u=kal n=ansible | An exception occurred during task execution. To see the full traceback, use -vvv. The error was: ImportError: No module named pexpect
2022-12-29 23:24:59,357 p=69647 u=kal n=ansible | fatal: [krpz]: FAILED! => {"changed": false, "msg": "Failed to import the required Python library (pexpect) on KRPZ's Python /usr/bin/python2. Please read the module documentation and install it in the appropriate location. If the required library is installed, but Ansible is using the wrong Python interpreter, please consult the documentation on ansible_python_interpreter"}
2022-12-29 23:24:59,358 p=69647 u=kal n=ansible | PLAY RECAP *******************************************************************************************************************************************
2022-12-29 23:24:59,358 p=69647 u=kal n=ansible | krpz                       : ok=10   changed=0    unreachable=0    failed=1    skipped=0    rescued=0    ignored=0   
2022-12-29 23:26:31,557 p=70226 u=kal n=ansible | ansible-playbook [core 2.14.1]
  config file = /home/kal/MyApplications/dotfiles/playbooks/ansible.cfg
  configured module search path = ['/home/kal/.ansible/plugins/modules', '/usr/share/ansible/plugins/modules']
  ansible python module location = /home/kal/.local/lib/python3.10/site-packages/ansible
  ansible collection location = /home/kal/.ansible/collections:/usr/share/ansible/collections
  executable location = /home/kal/.local/bin/ansible-playbook
  python version = 3.10.6 (main, Nov 14 2022, 16:10:14) [GCC 11.3.0] (/usr/bin/python3)
  jinja version = 3.1.2
  libyaml = True
2022-12-29 23:26:31,557 p=70226 u=kal n=ansible | Using /home/kal/MyApplications/dotfiles/playbooks/ansible.cfg as config file
2022-12-29 23:26:31,562 p=70226 u=kal n=ansible | host_list declined parsing /home/kal/MyApplications/dotfiles/playbooks/inventory.ini as it did not pass its verify_file() method
2022-12-29 23:26:31,562 p=70226 u=kal n=ansible | script declined parsing /home/kal/MyApplications/dotfiles/playbooks/inventory.ini as it did not pass its verify_file() method
2022-12-29 23:26:31,562 p=70226 u=kal n=ansible | auto declined parsing /home/kal/MyApplications/dotfiles/playbooks/inventory.ini as it did not pass its verify_file() method
2022-12-29 23:26:31,562 p=70226 u=kal n=ansible | yaml declined parsing /home/kal/MyApplications/dotfiles/playbooks/inventory.ini as it did not pass its verify_file() method
2022-12-29 23:26:31,563 p=70226 u=kal n=ansible | Parsed /home/kal/MyApplications/dotfiles/playbooks/inventory.ini inventory source with ini plugin
2022-12-29 23:26:31,634 p=70226 u=kal n=ansible | Skipping callback 'default', as we already have a stdout callback.
2022-12-29 23:26:31,635 p=70226 u=kal n=ansible | Skipping callback 'minimal', as we already have a stdout callback.
2022-12-29 23:26:31,635 p=70226 u=kal n=ansible | Skipping callback 'oneline', as we already have a stdout callback.
2022-12-29 23:26:31,635 p=70226 u=kal n=ansible | PLAYBOOK: all.yaml ***********************************************************************************************************************************
2022-12-29 23:26:31,635 p=70226 u=kal n=ansible | 1 plays in all.yaml
2022-12-29 23:26:31,636 p=70226 u=kal n=ansible | PLAY [localhost] *************************************************************************************************************************************
2022-12-29 23:26:31,643 p=70226 u=kal n=ansible | TASK [Gathering Facts] *******************************************************************************************************************************
2022-12-29 23:26:31,655 p=70226 u=kal n=ansible | <127.0.0.1> ESTABLISH LOCAL CONNECTION FOR USER: kal
2022-12-29 23:26:31,655 p=70226 u=kal n=ansible | <127.0.0.1> EXEC /bin/sh -c 'echo ~kal && sleep 0'
2022-12-29 23:26:31,656 p=70226 u=kal n=ansible | <127.0.0.1> EXEC /bin/sh -c '( umask 77 && mkdir -p "` echo /home/kal/.ansible/tmp `"&& mkdir "` echo /home/kal/.ansible/tmp/ansible-tmp-1672374391.6559312-70230-85757047291806 `" && echo ansible-tmp-1672374391.6559312-70230-85757047291806="` echo /home/kal/.ansible/tmp/ansible-tmp-1672374391.6559312-70230-85757047291806 `" ) && sleep 0'
2022-12-29 23:26:31,827 p=70226 u=kal n=ansible | Using module file /home/kal/.local/lib/python3.10/site-packages/ansible/modules/setup.py
2022-12-29 23:26:31,827 p=70226 u=kal n=ansible | <127.0.0.1> PUT /home/kal/.ansible/tmp/ansible-local-70226td9wx4dc/tmphjc69gck TO /home/kal/.ansible/tmp/ansible-tmp-1672374391.6559312-70230-85757047291806/AnsiballZ_setup.py
2022-12-29 23:26:31,828 p=70226 u=kal n=ansible | <127.0.0.1> EXEC /bin/sh -c 'chmod u+x /home/kal/.ansible/tmp/ansible-tmp-1672374391.6559312-70230-85757047291806/ /home/kal/.ansible/tmp/ansible-tmp-1672374391.6559312-70230-85757047291806/AnsiballZ_setup.py && sleep 0'
2022-12-29 23:26:31,829 p=70226 u=kal n=ansible | <127.0.0.1> EXEC /bin/sh -c 'sudo -H -S -n  -u root /bin/sh -c '"'"'echo BECOME-SUCCESS-juaegbvfpzfkqlgumsgnvqmleyyiduvj ; /usr/bin/python2 /home/kal/.ansible/tmp/ansible-tmp-1672374391.6559312-70230-85757047291806/AnsiballZ_setup.py'"'"' && sleep 0'
2022-12-29 23:26:35,614 p=70226 u=kal n=ansible | <127.0.0.1> EXEC /bin/sh -c 'rm -f -r /home/kal/.ansible/tmp/ansible-tmp-1672374391.6559312-70230-85757047291806/ > /dev/null 2>&1 && sleep 0'
2022-12-29 23:26:35,635 p=70226 u=kal n=ansible | ok: [krpz]
2022-12-29 23:26:35,657 p=70226 u=kal n=ansible | TASK [Install shell utilities w/ apt] ****************************************************************************************************************
2022-12-29 23:26:35,666 p=70226 u=kal n=ansible | <127.0.0.1> ESTABLISH LOCAL CONNECTION FOR USER: kal
2022-12-29 23:26:35,667 p=70226 u=kal n=ansible | <127.0.0.1> EXEC /bin/sh -c 'echo ~kal && sleep 0'
2022-12-29 23:26:35,668 p=70226 u=kal n=ansible | <127.0.0.1> EXEC /bin/sh -c '( umask 77 && mkdir -p "` echo /home/kal/.ansible/tmp `"&& mkdir "` echo /home/kal/.ansible/tmp/ansible-tmp-1672374395.6678526-70342-98644498889368 `" && echo ansible-tmp-1672374395.6678526-70342-98644498889368="` echo /home/kal/.ansible/tmp/ansible-tmp-1672374395.6678526-70342-98644498889368 `" ) && sleep 0'
2022-12-29 23:26:35,779 p=70226 u=kal n=ansible | Using module file /home/kal/.local/lib/python3.10/site-packages/ansible/modules/apt.py
2022-12-29 23:26:35,780 p=70226 u=kal n=ansible | <127.0.0.1> PUT /home/kal/.ansible/tmp/ansible-local-70226td9wx4dc/tmp_utz5dl9 TO /home/kal/.ansible/tmp/ansible-tmp-1672374395.6678526-70342-98644498889368/AnsiballZ_apt.py
2022-12-29 23:26:35,780 p=70226 u=kal n=ansible | <127.0.0.1> EXEC /bin/sh -c 'chmod u+x /home/kal/.ansible/tmp/ansible-tmp-1672374395.6678526-70342-98644498889368/ /home/kal/.ansible/tmp/ansible-tmp-1672374395.6678526-70342-98644498889368/AnsiballZ_apt.py && sleep 0'
2022-12-29 23:26:35,782 p=70226 u=kal n=ansible | <127.0.0.1> EXEC /bin/sh -c 'sudo -H -S -n  -u root /bin/sh -c '"'"'echo BECOME-SUCCESS-dfiyudncidiwfsdupthvmpzrdxouvbed ; /usr/bin/python2 /home/kal/.ansible/tmp/ansible-tmp-1672374395.6678526-70342-98644498889368/AnsiballZ_apt.py'"'"' && sleep 0'
2022-12-29 23:26:36,792 p=70226 u=kal n=ansible | <127.0.0.1> EXEC /bin/sh -c 'rm -f -r /home/kal/.ansible/tmp/ansible-tmp-1672374395.6678526-70342-98644498889368/ > /dev/null 2>&1 && sleep 0'
2022-12-29 23:26:36,798 p=70226 u=kal n=ansible | ok: [krpz] => {
    "cache_update_time": 1672373899,
    "cache_updated": false,
    "changed": false,
    "invocation": {
        "module_args": {
            "allow_change_held_packages": false,
            "allow_downgrade": false,
            "allow_unauthenticated": false,
            "autoclean": false,
            "autoremove": false,
            "cache_valid_time": 0,
            "clean": false,
            "deb": null,
            "default_release": null,
            "dpkg_options": "force-confdef,force-confold",
            "fail_on_autoremove": false,
            "force": false,
            "force_apt_get": false,
            "install_recommends": null,
            "lock_timeout": 60,
            "name": [
                "zsh"
            ],
            "only_upgrade": false,
            "package": [
                "zsh"
            ],
            "policy_rc_d": null,
            "purge": false,
            "state": "latest",
            "update_cache": null,
            "update_cache_retries": 5,
            "update_cache_retry_max_delay": 12,
            "upgrade": null
        }
    }
}
2022-12-29 23:26:36,806 p=70226 u=kal n=ansible | TASK [Ensure the user has a zsh shell.] **************************************************************************************************************
2022-12-29 23:26:36,817 p=70226 u=kal n=ansible | <127.0.0.1> ESTABLISH LOCAL CONNECTION FOR USER: kal
2022-12-29 23:26:36,817 p=70226 u=kal n=ansible | <127.0.0.1> EXEC /bin/sh -c 'echo ~kal && sleep 0'
2022-12-29 23:26:36,819 p=70226 u=kal n=ansible | <127.0.0.1> EXEC /bin/sh -c '( umask 77 && mkdir -p "` echo /home/kal/.ansible/tmp `"&& mkdir "` echo /home/kal/.ansible/tmp/ansible-tmp-1672374396.8187716-70380-274894962722507 `" && echo ansible-tmp-1672374396.8187716-70380-274894962722507="` echo /home/kal/.ansible/tmp/ansible-tmp-1672374396.8187716-70380-274894962722507 `" ) && sleep 0'
2022-12-29 23:26:36,930 p=70226 u=kal n=ansible | Using module file /home/kal/.local/lib/python3.10/site-packages/ansible/modules/user.py
2022-12-29 23:26:36,931 p=70226 u=kal n=ansible | <127.0.0.1> PUT /home/kal/.ansible/tmp/ansible-local-70226td9wx4dc/tmpvdn89yhf TO /home/kal/.ansible/tmp/ansible-tmp-1672374396.8187716-70380-274894962722507/AnsiballZ_user.py
2022-12-29 23:26:36,931 p=70226 u=kal n=ansible | <127.0.0.1> EXEC /bin/sh -c 'chmod u+x /home/kal/.ansible/tmp/ansible-tmp-1672374396.8187716-70380-274894962722507/ /home/kal/.ansible/tmp/ansible-tmp-1672374396.8187716-70380-274894962722507/AnsiballZ_user.py && sleep 0'
2022-12-29 23:26:36,933 p=70226 u=kal n=ansible | <127.0.0.1> EXEC /bin/sh -c 'sudo -H -S -n  -u root /bin/sh -c '"'"'echo BECOME-SUCCESS-insiojswxpiwjtrwkwbbzqreeyuyhmur ; /usr/bin/python2 /home/kal/.ansible/tmp/ansible-tmp-1672374396.8187716-70380-274894962722507/AnsiballZ_user.py'"'"' && sleep 0'
2022-12-29 23:26:37,025 p=70226 u=kal n=ansible | <127.0.0.1> EXEC /bin/sh -c 'rm -f -r /home/kal/.ansible/tmp/ansible-tmp-1672374396.8187716-70380-274894962722507/ > /dev/null 2>&1 && sleep 0'
2022-12-29 23:26:37,030 p=70226 u=kal n=ansible | ok: [krpz] => {
    "append": false,
    "changed": false,
    "comment": "Kalyan Parajuli,,,",
    "group": 1000,
    "home": "/home/kal",
    "invocation": {
        "module_args": {
            "append": false,
            "authorization": null,
            "comment": null,
            "create_home": true,
            "expires": null,
            "force": false,
            "generate_ssh_key": null,
            "group": null,
            "groups": null,
            "hidden": null,
            "home": null,
            "local": null,
            "login_class": null,
            "move_home": false,
            "name": "kal",
            "non_unique": false,
            "password": null,
            "password_expire_max": null,
            "password_expire_min": null,
            "password_lock": null,
            "profile": null,
            "remove": false,
            "role": null,
            "seuser": null,
            "shell": "/usr/bin/zsh",
            "skeleton": null,
            "ssh_key_bits": 0,
            "ssh_key_comment": "ansible-generated on KRPZ",
            "ssh_key_file": null,
            "ssh_key_passphrase": null,
            "ssh_key_type": "rsa",
            "state": "present",
            "system": false,
            "uid": null,
            "umask": null,
            "update_password": "always"
        }
    },
    "move_home": false,
    "name": "kal",
    "shell": "/usr/bin/zsh",
    "state": "present",
    "uid": 1000
}
2022-12-29 23:26:37,038 p=70226 u=kal n=ansible | TASK [Download default .zshrc] ***********************************************************************************************************************
2022-12-29 23:26:37,047 p=70226 u=kal n=ansible | <127.0.0.1> ESTABLISH LOCAL CONNECTION FOR USER: kal
2022-12-29 23:26:37,047 p=70226 u=kal n=ansible | <127.0.0.1> EXEC /bin/sh -c 'echo ~kal && sleep 0'
2022-12-29 23:26:37,049 p=70226 u=kal n=ansible | <127.0.0.1> EXEC /bin/sh -c '( umask 77 && mkdir -p "` echo /home/kal/.ansible/tmp `"&& mkdir "` echo /home/kal/.ansible/tmp/ansible-tmp-1672374397.0489287-70413-89311608633789 `" && echo ansible-tmp-1672374397.0489287-70413-89311608633789="` echo /home/kal/.ansible/tmp/ansible-tmp-1672374397.0489287-70413-89311608633789 `" ) && sleep 0'
2022-12-29 23:26:37,155 p=70226 u=kal n=ansible | Using module file /home/kal/.local/lib/python3.10/site-packages/ansible/modules/get_url.py
2022-12-29 23:26:37,156 p=70226 u=kal n=ansible | <127.0.0.1> PUT /home/kal/.ansible/tmp/ansible-local-70226td9wx4dc/tmpkbiwx6ie TO /home/kal/.ansible/tmp/ansible-tmp-1672374397.0489287-70413-89311608633789/AnsiballZ_get_url.py
2022-12-29 23:26:37,156 p=70226 u=kal n=ansible | <127.0.0.1> EXEC /bin/sh -c 'chmod u+x /home/kal/.ansible/tmp/ansible-tmp-1672374397.0489287-70413-89311608633789/ /home/kal/.ansible/tmp/ansible-tmp-1672374397.0489287-70413-89311608633789/AnsiballZ_get_url.py && sleep 0'
2022-12-29 23:26:37,158 p=70226 u=kal n=ansible | <127.0.0.1> EXEC /bin/sh -c 'sudo -H -S -n  -u root /bin/sh -c '"'"'echo BECOME-SUCCESS-hdgqxbeoltmofcwosdgjbqbstiktojqv ; /usr/bin/python2 /home/kal/.ansible/tmp/ansible-tmp-1672374397.0489287-70413-89311608633789/AnsiballZ_get_url.py'"'"' && sleep 0'
2022-12-29 23:26:37,428 p=70226 u=kal n=ansible | <127.0.0.1> EXEC /bin/sh -c 'rm -f -r /home/kal/.ansible/tmp/ansible-tmp-1672374397.0489287-70413-89311608633789/ > /dev/null 2>&1 && sleep 0'
2022-12-29 23:26:37,437 p=70226 u=kal n=ansible | ok: [krpz] => {
    "changed": false,
    "checksum_dest": "b460da243c86531bffcab465b29a79f8aee49396",
    "checksum_src": "b460da243c86531bffcab465b29a79f8aee49396",
    "dest": "/root/.zshrc",
    "elapsed": 0,
    "gid": 0,
    "group": "root",
    "invocation": {
        "module_args": {
            "attributes": null,
            "backup": false,
            "checksum": "",
            "ciphers": null,
            "client_cert": null,
            "client_key": null,
            "decompress": true,
            "dest": "/root/.zshrc",
            "force": false,
            "force_basic_auth": false,
            "group": null,
            "headers": null,
            "http_agent": "ansible-httpget",
            "mode": "0440",
            "owner": null,
            "selevel": null,
            "serole": null,
            "setype": null,
            "seuser": null,
            "timeout": 10,
            "tmp_dest": null,
            "unredirected_headers": [],
            "unsafe_writes": false,
            "url": "https://gist.githubusercontent.com/kpbeta/39cc785da0898096f2e3d38b2c344359/raw/e856dd98e24427ba0d48729ac17a03ad23456021/default-zshrc",
            "url_password": null,
            "url_username": null,
            "use_gssapi": false,
            "use_netrc": true,
            "use_proxy": true,
            "validate_certs": true
        }
    },
    "md5sum": "dac3563a2ddd13e8027b1861d415f3d4",
    "mode": "0440",
    "msg": "OK (1295 bytes)",
    "owner": "root",
    "size": 1295,
    "src": "/home/kal/.ansible/tmp/ansible-tmp-1672374397.0489287-70413-89311608633789/tmpMyOkwK",
    "state": "file",
    "status_code": 200,
    "uid": 0,
    "url": "https://gist.githubusercontent.com/kpbeta/39cc785da0898096f2e3d38b2c344359/raw/e856dd98e24427ba0d48729ac17a03ad23456021/default-zshrc"
}
2022-12-29 23:26:37,457 p=70226 u=kal n=ansible | TASK [Install shell utilities w/ apt] ****************************************************************************************************************
2022-12-29 23:26:37,471 p=70226 u=kal n=ansible | <127.0.0.1> ESTABLISH LOCAL CONNECTION FOR USER: kal
2022-12-29 23:26:37,472 p=70226 u=kal n=ansible | <127.0.0.1> EXEC /bin/sh -c 'echo ~kal && sleep 0'
2022-12-29 23:26:37,472 p=70226 u=kal n=ansible | <127.0.0.1> EXEC /bin/sh -c '( umask 77 && mkdir -p "` echo /home/kal/.ansible/tmp `"&& mkdir "` echo /home/kal/.ansible/tmp/ansible-tmp-1672374397.4727445-70444-79115596758389 `" && echo ansible-tmp-1672374397.4727445-70444-79115596758389="` echo /home/kal/.ansible/tmp/ansible-tmp-1672374397.4727445-70444-79115596758389 `" ) && sleep 0'
2022-12-29 23:26:37,477 p=70226 u=kal n=ansible | Using module file /home/kal/.local/lib/python3.10/site-packages/ansible/modules/apt.py
2022-12-29 23:26:37,477 p=70226 u=kal n=ansible | <127.0.0.1> PUT /home/kal/.ansible/tmp/ansible-local-70226td9wx4dc/tmp2vi1sy0u TO /home/kal/.ansible/tmp/ansible-tmp-1672374397.4727445-70444-79115596758389/AnsiballZ_apt.py
2022-12-29 23:26:37,478 p=70226 u=kal n=ansible | <127.0.0.1> EXEC /bin/sh -c 'chmod u+x /home/kal/.ansible/tmp/ansible-tmp-1672374397.4727445-70444-79115596758389/ /home/kal/.ansible/tmp/ansible-tmp-1672374397.4727445-70444-79115596758389/AnsiballZ_apt.py && sleep 0'
2022-12-29 23:26:37,480 p=70226 u=kal n=ansible | <127.0.0.1> EXEC /bin/sh -c 'sudo -H -S -n  -u root /bin/sh -c '"'"'echo BECOME-SUCCESS-ambmlecdzlwzcukqtenzirtjxwntxkbg ; /usr/bin/python2 /home/kal/.ansible/tmp/ansible-tmp-1672374397.4727445-70444-79115596758389/AnsiballZ_apt.py'"'"' && sleep 0'
2022-12-29 23:26:38,502 p=70226 u=kal n=ansible | <127.0.0.1> EXEC /bin/sh -c 'rm -f -r /home/kal/.ansible/tmp/ansible-tmp-1672374397.4727445-70444-79115596758389/ > /dev/null 2>&1 && sleep 0'
2022-12-29 23:26:38,507 p=70226 u=kal n=ansible | ok: [krpz] => {
    "cache_update_time": 1672373899,
    "cache_updated": false,
    "changed": false,
    "invocation": {
        "module_args": {
            "allow_change_held_packages": false,
            "allow_downgrade": false,
            "allow_unauthenticated": false,
            "autoclean": false,
            "autoremove": false,
            "cache_valid_time": 0,
            "clean": false,
            "deb": null,
            "default_release": null,
            "dpkg_options": "force-confdef,force-confold",
            "fail_on_autoremove": false,
            "force": false,
            "force_apt_get": false,
            "install_recommends": null,
            "lock_timeout": 60,
            "name": [
                "tmux",
                "xclip",
                "xcape",
                "openssh-server"
            ],
            "only_upgrade": false,
            "package": [
                "tmux",
                "xclip",
                "xcape",
                "openssh-server"
            ],
            "policy_rc_d": null,
            "purge": false,
            "state": "latest",
            "update_cache": null,
            "update_cache_retries": 5,
            "update_cache_retry_max_delay": 12,
            "upgrade": null
        }
    }
}
2022-12-29 23:26:38,515 p=70226 u=kal n=ansible | TASK [Install other utilities (wget, curl, git, etc.)] ***********************************************************************************************
2022-12-29 23:26:38,524 p=70226 u=kal n=ansible | <127.0.0.1> ESTABLISH LOCAL CONNECTION FOR USER: kal
2022-12-29 23:26:38,524 p=70226 u=kal n=ansible | <127.0.0.1> EXEC /bin/sh -c 'echo ~kal && sleep 0'
2022-12-29 23:26:38,526 p=70226 u=kal n=ansible | <127.0.0.1> EXEC /bin/sh -c '( umask 77 && mkdir -p "` echo /home/kal/.ansible/tmp `"&& mkdir "` echo /home/kal/.ansible/tmp/ansible-tmp-1672374398.5259335-70483-130809548225804 `" && echo ansible-tmp-1672374398.5259335-70483-130809548225804="` echo /home/kal/.ansible/tmp/ansible-tmp-1672374398.5259335-70483-130809548225804 `" ) && sleep 0'
2022-12-29 23:26:38,530 p=70226 u=kal n=ansible | Using module file /home/kal/.local/lib/python3.10/site-packages/ansible/modules/apt.py
2022-12-29 23:26:38,530 p=70226 u=kal n=ansible | <127.0.0.1> PUT /home/kal/.ansible/tmp/ansible-local-70226td9wx4dc/tmpmqf4vwwk TO /home/kal/.ansible/tmp/ansible-tmp-1672374398.5259335-70483-130809548225804/AnsiballZ_apt.py
2022-12-29 23:26:38,531 p=70226 u=kal n=ansible | <127.0.0.1> EXEC /bin/sh -c 'chmod u+x /home/kal/.ansible/tmp/ansible-tmp-1672374398.5259335-70483-130809548225804/ /home/kal/.ansible/tmp/ansible-tmp-1672374398.5259335-70483-130809548225804/AnsiballZ_apt.py && sleep 0'
2022-12-29 23:26:38,533 p=70226 u=kal n=ansible | <127.0.0.1> EXEC /bin/sh -c 'sudo -H -S -n  -u root /bin/sh -c '"'"'echo BECOME-SUCCESS-tsjeyxhsmmbetrjhepaqvazylqnjrncc ; /usr/bin/python2 /home/kal/.ansible/tmp/ansible-tmp-1672374398.5259335-70483-130809548225804/AnsiballZ_apt.py'"'"' && sleep 0'
2022-12-29 23:26:39,568 p=70226 u=kal n=ansible | <127.0.0.1> EXEC /bin/sh -c 'rm -f -r /home/kal/.ansible/tmp/ansible-tmp-1672374398.5259335-70483-130809548225804/ > /dev/null 2>&1 && sleep 0'
2022-12-29 23:26:39,573 p=70226 u=kal n=ansible | ok: [krpz] => {
    "cache_update_time": 1672373899,
    "cache_updated": false,
    "changed": false,
    "invocation": {
        "module_args": {
            "allow_change_held_packages": false,
            "allow_downgrade": false,
            "allow_unauthenticated": false,
            "autoclean": false,
            "autoremove": false,
            "cache_valid_time": 0,
            "clean": false,
            "deb": null,
            "default_release": null,
            "dpkg_options": "force-confdef,force-confold",
            "fail_on_autoremove": false,
            "force": false,
            "force_apt_get": false,
            "install_recommends": null,
            "lock_timeout": 60,
            "name": [
                "python3",
                "python2",
                "curl",
                "wget",
                "git",
                "bat",
                "exa",
                "zoxide",
                "ripgrep",
                "fd-find"
            ],
            "only_upgrade": false,
            "package": [
                "python3",
                "python2",
                "curl",
                "wget",
                "git",
                "bat",
                "exa",
                "zoxide",
                "ripgrep",
                "fd-find"
            ],
            "policy_rc_d": null,
            "purge": false,
            "state": "latest",
            "update_cache": null,
            "update_cache_retries": 5,
            "update_cache_retry_max_delay": 12,
            "upgrade": null
        }
    }
}
2022-12-29 23:26:39,581 p=70226 u=kal n=ansible | TASK [Set environment managers (direnv, npm, conda)] *************************************************************************************************
2022-12-29 23:26:39,590 p=70226 u=kal n=ansible | <127.0.0.1> ESTABLISH LOCAL CONNECTION FOR USER: kal
2022-12-29 23:26:39,590 p=70226 u=kal n=ansible | <127.0.0.1> EXEC /bin/sh -c 'echo ~kal && sleep 0'
2022-12-29 23:26:39,592 p=70226 u=kal n=ansible | <127.0.0.1> EXEC /bin/sh -c '( umask 77 && mkdir -p "` echo /home/kal/.ansible/tmp `"&& mkdir "` echo /home/kal/.ansible/tmp/ansible-tmp-1672374399.59182-70522-266498416257933 `" && echo ansible-tmp-1672374399.59182-70522-266498416257933="` echo /home/kal/.ansible/tmp/ansible-tmp-1672374399.59182-70522-266498416257933 `" ) && sleep 0'
2022-12-29 23:26:39,596 p=70226 u=kal n=ansible | Using module file /home/kal/.local/lib/python3.10/site-packages/ansible/modules/apt.py
2022-12-29 23:26:39,596 p=70226 u=kal n=ansible | <127.0.0.1> PUT /home/kal/.ansible/tmp/ansible-local-70226td9wx4dc/tmpqzi0lcwe TO /home/kal/.ansible/tmp/ansible-tmp-1672374399.59182-70522-266498416257933/AnsiballZ_apt.py
2022-12-29 23:26:39,596 p=70226 u=kal n=ansible | <127.0.0.1> EXEC /bin/sh -c 'chmod u+x /home/kal/.ansible/tmp/ansible-tmp-1672374399.59182-70522-266498416257933/ /home/kal/.ansible/tmp/ansible-tmp-1672374399.59182-70522-266498416257933/AnsiballZ_apt.py && sleep 0'
2022-12-29 23:26:39,599 p=70226 u=kal n=ansible | <127.0.0.1> EXEC /bin/sh -c 'sudo -H -S -n  -u root /bin/sh -c '"'"'echo BECOME-SUCCESS-ymplplthyuwgcdoizjmlgizgtndxeids ; /usr/bin/python2 /home/kal/.ansible/tmp/ansible-tmp-1672374399.59182-70522-266498416257933/AnsiballZ_apt.py'"'"' && sleep 0'
2022-12-29 23:26:40,602 p=70226 u=kal n=ansible | <127.0.0.1> EXEC /bin/sh -c 'rm -f -r /home/kal/.ansible/tmp/ansible-tmp-1672374399.59182-70522-266498416257933/ > /dev/null 2>&1 && sleep 0'
2022-12-29 23:26:40,606 p=70226 u=kal n=ansible | ok: [krpz] => {
    "cache_update_time": 1672373899,
    "cache_updated": false,
    "changed": false,
    "invocation": {
        "module_args": {
            "allow_change_held_packages": false,
            "allow_downgrade": false,
            "allow_unauthenticated": false,
            "autoclean": false,
            "autoremove": false,
            "cache_valid_time": 0,
            "clean": false,
            "deb": null,
            "default_release": null,
            "dpkg_options": "force-confdef,force-confold",
            "fail_on_autoremove": false,
            "force": false,
            "force_apt_get": false,
            "install_recommends": null,
            "lock_timeout": 60,
            "name": [
                "direnv"
            ],
            "only_upgrade": false,
            "package": [
                "direnv"
            ],
            "policy_rc_d": null,
            "purge": false,
            "state": "latest",
            "update_cache": null,
            "update_cache_retries": 5,
            "update_cache_retry_max_delay": 12,
            "upgrade": null
        }
    }
}
2022-12-29 23:26:40,615 p=70226 u=kal n=ansible | TASK [Install NVM] ***********************************************************************************************************************************
2022-12-29 23:26:40,626 p=70226 u=kal n=ansible | <127.0.0.1> ESTABLISH LOCAL CONNECTION FOR USER: kal
2022-12-29 23:26:40,626 p=70226 u=kal n=ansible | <127.0.0.1> EXEC /bin/sh -c 'echo ~kal && sleep 0'
2022-12-29 23:26:40,627 p=70226 u=kal n=ansible | <127.0.0.1> EXEC /bin/sh -c '( umask 77 && mkdir -p "` echo /home/kal/.ansible/tmp `"&& mkdir "` echo /home/kal/.ansible/tmp/ansible-tmp-1672374400.6275547-70564-57455790668481 `" && echo ansible-tmp-1672374400.6275547-70564-57455790668481="` echo /home/kal/.ansible/tmp/ansible-tmp-1672374400.6275547-70564-57455790668481 `" ) && sleep 0'
2022-12-29 23:26:40,720 p=70226 u=kal n=ansible | Using module file /home/kal/.local/lib/python3.10/site-packages/ansible/modules/command.py
2022-12-29 23:26:40,720 p=70226 u=kal n=ansible | <127.0.0.1> PUT /home/kal/.ansible/tmp/ansible-local-70226td9wx4dc/tmpnai3ft7n TO /home/kal/.ansible/tmp/ansible-tmp-1672374400.6275547-70564-57455790668481/AnsiballZ_command.py
2022-12-29 23:26:40,721 p=70226 u=kal n=ansible | <127.0.0.1> EXEC /bin/sh -c 'chmod u+x /home/kal/.ansible/tmp/ansible-tmp-1672374400.6275547-70564-57455790668481/ /home/kal/.ansible/tmp/ansible-tmp-1672374400.6275547-70564-57455790668481/AnsiballZ_command.py && sleep 0'
2022-12-29 23:26:40,723 p=70226 u=kal n=ansible | <127.0.0.1> EXEC /bin/sh -c 'sudo -H -S -n  -u root /bin/sh -c '"'"'echo BECOME-SUCCESS-kezdbuiictdpzdabsjjakemmchskiptz ; /usr/bin/python2 /home/kal/.ansible/tmp/ansible-tmp-1672374400.6275547-70564-57455790668481/AnsiballZ_command.py'"'"' && sleep 0'
2022-12-29 23:26:40,785 p=70226 u=kal n=ansible | <127.0.0.1> EXEC /bin/sh -c 'rm -f -r /home/kal/.ansible/tmp/ansible-tmp-1672374400.6275547-70564-57455790668481/ > /dev/null 2>&1 && sleep 0'
2022-12-29 23:26:40,789 p=70226 u=kal n=ansible | ok: [krpz] => {
    "changed": false,
    "cmd": "curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.3/install.sh | bash\n",
    "delta": null,
    "end": null,
    "invocation": {
        "module_args": {
            "_raw_params": "curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.3/install.sh | bash\n",
            "_uses_shell": true,
            "argv": null,
            "chdir": null,
            "creates": "/root/.nvm/nvm.sh",
            "executable": null,
            "removes": null,
            "stdin": null,
            "stdin_add_newline": true,
            "strip_empty_ends": true
        }
    },
    "msg": "Did not run command since '/root/.nvm/nvm.sh' exists",
    "rc": 0,
    "start": null,
    "stderr": "",
    "stderr_lines": [],
    "stdout": "skipped, since /root/.nvm/nvm.sh exists",
    "stdout_lines": [
        "skipped, since /root/.nvm/nvm.sh exists"
    ]
}
2022-12-29 23:26:40,797 p=70226 u=kal n=ansible | TASK [Install utilities (htop, tree, pstree, etc.)] **************************************************************************************************
2022-12-29 23:26:40,805 p=70226 u=kal n=ansible | <127.0.0.1> ESTABLISH LOCAL CONNECTION FOR USER: kal
2022-12-29 23:26:40,805 p=70226 u=kal n=ansible | <127.0.0.1> EXEC /bin/sh -c 'echo ~kal && sleep 0'
2022-12-29 23:26:40,807 p=70226 u=kal n=ansible | <127.0.0.1> EXEC /bin/sh -c '( umask 77 && mkdir -p "` echo /home/kal/.ansible/tmp `"&& mkdir "` echo /home/kal/.ansible/tmp/ansible-tmp-1672374400.8072321-70593-161609352905474 `" && echo ansible-tmp-1672374400.8072321-70593-161609352905474="` echo /home/kal/.ansible/tmp/ansible-tmp-1672374400.8072321-70593-161609352905474 `" ) && sleep 0'
2022-12-29 23:26:40,811 p=70226 u=kal n=ansible | Using module file /home/kal/.local/lib/python3.10/site-packages/ansible/modules/apt.py
2022-12-29 23:26:40,811 p=70226 u=kal n=ansible | <127.0.0.1> PUT /home/kal/.ansible/tmp/ansible-local-70226td9wx4dc/tmpcrd6mv1f TO /home/kal/.ansible/tmp/ansible-tmp-1672374400.8072321-70593-161609352905474/AnsiballZ_apt.py
2022-12-29 23:26:40,812 p=70226 u=kal n=ansible | <127.0.0.1> EXEC /bin/sh -c 'chmod u+x /home/kal/.ansible/tmp/ansible-tmp-1672374400.8072321-70593-161609352905474/ /home/kal/.ansible/tmp/ansible-tmp-1672374400.8072321-70593-161609352905474/AnsiballZ_apt.py && sleep 0'
2022-12-29 23:26:40,814 p=70226 u=kal n=ansible | <127.0.0.1> EXEC /bin/sh -c 'sudo -H -S -n  -u root /bin/sh -c '"'"'echo BECOME-SUCCESS-qpnbrtjenlucnhoohgxmxlnntqriprnd ; /usr/bin/python2 /home/kal/.ansible/tmp/ansible-tmp-1672374400.8072321-70593-161609352905474/AnsiballZ_apt.py'"'"' && sleep 0'
2022-12-29 23:26:41,822 p=70226 u=kal n=ansible | <127.0.0.1> EXEC /bin/sh -c 'rm -f -r /home/kal/.ansible/tmp/ansible-tmp-1672374400.8072321-70593-161609352905474/ > /dev/null 2>&1 && sleep 0'
2022-12-29 23:26:41,827 p=70226 u=kal n=ansible | ok: [krpz] => {
    "cache_update_time": 1672373899,
    "cache_updated": false,
    "changed": false,
    "invocation": {
        "module_args": {
            "allow_change_held_packages": false,
            "allow_downgrade": false,
            "allow_unauthenticated": false,
            "autoclean": false,
            "autoremove": false,
            "cache_valid_time": 0,
            "clean": false,
            "deb": null,
            "default_release": null,
            "dpkg_options": "force-confdef,force-confold",
            "fail_on_autoremove": false,
            "force": false,
            "force_apt_get": false,
            "install_recommends": null,
            "lock_timeout": 60,
            "name": [
                "htop",
                "tree",
                "net-tools",
                "psmisc",
                "trash-cli"
            ],
            "only_upgrade": false,
            "package": [
                "htop",
                "tree",
                "net-tools",
                "psmisc",
                "trash-cli"
            ],
            "policy_rc_d": null,
            "purge": false,
            "state": "latest",
            "update_cache": null,
            "update_cache_retries": 5,
            "update_cache_retry_max_delay": 12,
            "upgrade": null
        }
    }
}
2022-12-29 23:26:41,835 p=70226 u=kal n=ansible | TASK [Install VM techs] ******************************************************************************************************************************
2022-12-29 23:26:41,845 p=70226 u=kal n=ansible | <127.0.0.1> ESTABLISH LOCAL CONNECTION FOR USER: kal
2022-12-29 23:26:41,845 p=70226 u=kal n=ansible | <127.0.0.1> EXEC /bin/sh -c 'echo ~kal && sleep 0'
2022-12-29 23:26:41,846 p=70226 u=kal n=ansible | <127.0.0.1> EXEC /bin/sh -c '( umask 77 && mkdir -p "` echo /home/kal/.ansible/tmp `"&& mkdir "` echo /home/kal/.ansible/tmp/ansible-tmp-1672374401.846132-70631-103852585112938 `" && echo ansible-tmp-1672374401.846132-70631-103852585112938="` echo /home/kal/.ansible/tmp/ansible-tmp-1672374401.846132-70631-103852585112938 `" ) && sleep 0'
2022-12-29 23:26:41,851 p=70226 u=kal n=ansible | Using module file /home/kal/.local/lib/python3.10/site-packages/ansible/modules/apt.py
2022-12-29 23:26:41,851 p=70226 u=kal n=ansible | <127.0.0.1> PUT /home/kal/.ansible/tmp/ansible-local-70226td9wx4dc/tmpsqbwmish TO /home/kal/.ansible/tmp/ansible-tmp-1672374401.846132-70631-103852585112938/AnsiballZ_apt.py
2022-12-29 23:26:41,852 p=70226 u=kal n=ansible | <127.0.0.1> EXEC /bin/sh -c 'chmod u+x /home/kal/.ansible/tmp/ansible-tmp-1672374401.846132-70631-103852585112938/ /home/kal/.ansible/tmp/ansible-tmp-1672374401.846132-70631-103852585112938/AnsiballZ_apt.py && sleep 0'
2022-12-29 23:26:41,854 p=70226 u=kal n=ansible | <127.0.0.1> EXEC /bin/sh -c 'sudo -H -S -n  -u root /bin/sh -c '"'"'echo BECOME-SUCCESS-wxqlimcddyvwxrhtirsztizwidxirwkz ; /usr/bin/python2 /home/kal/.ansible/tmp/ansible-tmp-1672374401.846132-70631-103852585112938/AnsiballZ_apt.py'"'"' && sleep 0'
2022-12-29 23:26:42,858 p=70226 u=kal n=ansible | <127.0.0.1> EXEC /bin/sh -c 'rm -f -r /home/kal/.ansible/tmp/ansible-tmp-1672374401.846132-70631-103852585112938/ > /dev/null 2>&1 && sleep 0'
2022-12-29 23:26:42,863 p=70226 u=kal n=ansible | ok: [krpz] => {
    "cache_update_time": 1672373899,
    "cache_updated": false,
    "changed": false,
    "invocation": {
        "module_args": {
            "allow_change_held_packages": false,
            "allow_downgrade": false,
            "allow_unauthenticated": false,
            "autoclean": false,
            "autoremove": false,
            "cache_valid_time": 0,
            "clean": false,
            "deb": null,
            "default_release": null,
            "dpkg_options": "force-confdef,force-confold",
            "fail_on_autoremove": false,
            "force": false,
            "force_apt_get": false,
            "install_recommends": null,
            "lock_timeout": 60,
            "name": [
                "vagrant",
                "docker.io"
            ],
            "only_upgrade": false,
            "package": [
                "vagrant",
                "docker.io"
            ],
            "policy_rc_d": null,
            "purge": false,
            "state": "latest",
            "update_cache": null,
            "update_cache_retries": 5,
            "update_cache_retry_max_delay": 12,
            "upgrade": null
        }
    }
}
2022-12-29 23:26:42,871 p=70226 u=kal n=ansible | TASK [Install Rust] **********************************************************************************************************************************
2022-12-29 23:26:42,880 p=70226 u=kal n=ansible | <127.0.0.1> ESTABLISH LOCAL CONNECTION FOR USER: kal
2022-12-29 23:26:42,880 p=70226 u=kal n=ansible | <127.0.0.1> EXEC /bin/sh -c 'echo ~kal && sleep 0'
2022-12-29 23:26:42,881 p=70226 u=kal n=ansible | <127.0.0.1> EXEC /bin/sh -c '( umask 77 && mkdir -p "` echo /home/kal/.ansible/tmp `"&& mkdir "` echo /home/kal/.ansible/tmp/ansible-tmp-1672374402.881044-70670-180755987630757 `" && echo ansible-tmp-1672374402.881044-70670-180755987630757="` echo /home/kal/.ansible/tmp/ansible-tmp-1672374402.881044-70670-180755987630757 `" ) && sleep 0'
2022-12-29 23:26:42,970 p=70226 u=kal n=ansible | Using module file /home/kal/.local/lib/python3.10/site-packages/ansible/modules/expect.py
2022-12-29 23:26:42,970 p=70226 u=kal n=ansible | <127.0.0.1> PUT /home/kal/.ansible/tmp/ansible-local-70226td9wx4dc/tmp49wljo7v TO /home/kal/.ansible/tmp/ansible-tmp-1672374402.881044-70670-180755987630757/AnsiballZ_expect.py
2022-12-29 23:26:42,971 p=70226 u=kal n=ansible | <127.0.0.1> EXEC /bin/sh -c 'chmod u+x /home/kal/.ansible/tmp/ansible-tmp-1672374402.881044-70670-180755987630757/ /home/kal/.ansible/tmp/ansible-tmp-1672374402.881044-70670-180755987630757/AnsiballZ_expect.py && sleep 0'
2022-12-29 23:26:42,973 p=70226 u=kal n=ansible | <127.0.0.1> EXEC /bin/sh -c 'sudo -H -S -n  -u root /bin/sh -c '"'"'echo BECOME-SUCCESS-mbzfvykpaehixkqwbokfbgkdfuonlzxj ; /usr/bin/python2 /home/kal/.ansible/tmp/ansible-tmp-1672374402.881044-70670-180755987630757/AnsiballZ_expect.py'"'"' && sleep 0'
2022-12-29 23:26:43,036 p=70226 u=kal n=ansible | <127.0.0.1> EXEC /bin/sh -c 'rm -f -r /home/kal/.ansible/tmp/ansible-tmp-1672374402.881044-70670-180755987630757/ > /dev/null 2>&1 && sleep 0'
2022-12-29 23:26:43,041 p=70226 u=kal n=ansible | The full traceback is:
Traceback (most recent call last):
  File "/tmp/ansible_expect_payload_jh5DCz/ansible_expect_payload.zip/ansible/modules/expect.py", line 115, in <module>
ImportError: No module named pexpect

2022-12-29 23:26:43,041 p=70226 u=kal n=ansible | fatal: [krpz]: FAILED! => {
    "changed": false,
    "invocation": {
        "module_args": {
            "chdir": null,
            "command": "curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh",
            "creates": null,
            "echo": false,
            "removes": null,
            "responses": {
                "Question": [
                    1
                ]
            },
            "timeout": 30
        }
    },
    "msg": "Failed to import the required Python library (pexpect) on KRPZ's Python /usr/bin/python2. Please read the module documentation and install it in the appropriate location. If the required library is installed, but Ansible is using the wrong Python interpreter, please consult the documentation on ansible_python_interpreter"
}
2022-12-29 23:26:43,042 p=70226 u=kal n=ansible | PLAY RECAP *******************************************************************************************************************************************
2022-12-29 23:26:43,042 p=70226 u=kal n=ansible | krpz                       : ok=10   changed=0    unreachable=0    failed=1    skipped=0    rescued=0    ignored=0   
2022-12-29 23:31:35,773 p=71284 u=kal n=ansible | ansible-playbook [core 2.14.1]
  config file = /home/kal/MyApplications/dotfiles/playbooks/ansible.cfg
  configured module search path = ['/home/kal/.ansible/plugins/modules', '/usr/share/ansible/plugins/modules']
  ansible python module location = /home/kal/.local/lib/python3.10/site-packages/ansible
  ansible collection location = /home/kal/.ansible/collections:/usr/share/ansible/collections
  executable location = /home/kal/.local/bin/ansible-playbook
  python version = 3.10.6 (main, Nov 14 2022, 16:10:14) [GCC 11.3.0] (/usr/bin/python3)
  jinja version = 3.1.2
  libyaml = True
2022-12-29 23:31:35,773 p=71284 u=kal n=ansible | Using /home/kal/MyApplications/dotfiles/playbooks/ansible.cfg as config file
2022-12-29 23:31:35,777 p=71284 u=kal n=ansible | host_list declined parsing /home/kal/MyApplications/dotfiles/playbooks/inventory.ini as it did not pass its verify_file() method
2022-12-29 23:31:35,777 p=71284 u=kal n=ansible | script declined parsing /home/kal/MyApplications/dotfiles/playbooks/inventory.ini as it did not pass its verify_file() method
2022-12-29 23:31:35,777 p=71284 u=kal n=ansible | auto declined parsing /home/kal/MyApplications/dotfiles/playbooks/inventory.ini as it did not pass its verify_file() method
2022-12-29 23:31:35,778 p=71284 u=kal n=ansible | yaml declined parsing /home/kal/MyApplications/dotfiles/playbooks/inventory.ini as it did not pass its verify_file() method
2022-12-29 23:31:35,778 p=71284 u=kal n=ansible | Parsed /home/kal/MyApplications/dotfiles/playbooks/inventory.ini inventory source with ini plugin
2022-12-29 23:31:35,851 p=71284 u=kal n=ansible | Skipping callback 'default', as we already have a stdout callback.
2022-12-29 23:31:35,851 p=71284 u=kal n=ansible | Skipping callback 'minimal', as we already have a stdout callback.
2022-12-29 23:31:35,852 p=71284 u=kal n=ansible | Skipping callback 'oneline', as we already have a stdout callback.
2022-12-29 23:31:35,852 p=71284 u=kal n=ansible | PLAYBOOK: all.yaml ***********************************************************************************************************************************
2022-12-29 23:31:35,852 p=71284 u=kal n=ansible | 1 plays in all.yaml
2022-12-29 23:31:35,853 p=71284 u=kal n=ansible | PLAY [localhost] *************************************************************************************************************************************
2022-12-29 23:31:35,860 p=71284 u=kal n=ansible | TASK [Gathering Facts] *******************************************************************************************************************************
2022-12-29 23:31:35,870 p=71284 u=kal n=ansible | <127.0.0.1> ESTABLISH LOCAL CONNECTION FOR USER: kal
2022-12-29 23:31:35,870 p=71284 u=kal n=ansible | <127.0.0.1> EXEC /bin/sh -c 'echo ~kal && sleep 0'
2022-12-29 23:31:35,872 p=71284 u=kal n=ansible | <127.0.0.1> EXEC /bin/sh -c '( umask 77 && mkdir -p "` echo /home/kal/.ansible/tmp `"&& mkdir "` echo /home/kal/.ansible/tmp/ansible-tmp-1672374695.8719127-71288-278000321725817 `" && echo ansible-tmp-1672374695.8719127-71288-278000321725817="` echo /home/kal/.ansible/tmp/ansible-tmp-1672374695.8719127-71288-278000321725817 `" ) && sleep 0'
2022-12-29 23:31:36,047 p=71284 u=kal n=ansible | Using module file /home/kal/.local/lib/python3.10/site-packages/ansible/modules/setup.py
2022-12-29 23:31:36,047 p=71284 u=kal n=ansible | <127.0.0.1> PUT /home/kal/.ansible/tmp/ansible-local-712841piedbjp/tmpqxw_1iv8 TO /home/kal/.ansible/tmp/ansible-tmp-1672374695.8719127-71288-278000321725817/AnsiballZ_setup.py
2022-12-29 23:31:36,048 p=71284 u=kal n=ansible | <127.0.0.1> EXEC /bin/sh -c 'chmod u+x /home/kal/.ansible/tmp/ansible-tmp-1672374695.8719127-71288-278000321725817/ /home/kal/.ansible/tmp/ansible-tmp-1672374695.8719127-71288-278000321725817/AnsiballZ_setup.py && sleep 0'
2022-12-29 23:31:36,049 p=71284 u=kal n=ansible | <127.0.0.1> EXEC /bin/sh -c 'sudo -H -S -n  -u root /bin/sh -c '"'"'echo BECOME-SUCCESS-euuldhkglumvqzvewzlsrcrrhftfpkqo ; /usr/bin/python2 /home/kal/.ansible/tmp/ansible-tmp-1672374695.8719127-71288-278000321725817/AnsiballZ_setup.py'"'"' && sleep 0'
2022-12-29 23:31:39,864 p=71284 u=kal n=ansible | <127.0.0.1> EXEC /bin/sh -c 'rm -f -r /home/kal/.ansible/tmp/ansible-tmp-1672374695.8719127-71288-278000321725817/ > /dev/null 2>&1 && sleep 0'
2022-12-29 23:31:39,885 p=71284 u=kal n=ansible | ok: [krpz]
2022-12-29 23:31:39,908 p=71284 u=kal n=ansible | TASK [Install shell utilities w/ apt] ****************************************************************************************************************
2022-12-29 23:31:39,917 p=71284 u=kal n=ansible | <127.0.0.1> ESTABLISH LOCAL CONNECTION FOR USER: kal
2022-12-29 23:31:39,917 p=71284 u=kal n=ansible | <127.0.0.1> EXEC /bin/sh -c 'echo ~kal && sleep 0'
2022-12-29 23:31:39,918 p=71284 u=kal n=ansible | <127.0.0.1> EXEC /bin/sh -c '( umask 77 && mkdir -p "` echo /home/kal/.ansible/tmp `"&& mkdir "` echo /home/kal/.ansible/tmp/ansible-tmp-1672374699.9184387-71408-257266608706374 `" && echo ansible-tmp-1672374699.9184387-71408-257266608706374="` echo /home/kal/.ansible/tmp/ansible-tmp-1672374699.9184387-71408-257266608706374 `" ) && sleep 0'
2022-12-29 23:31:40,030 p=71284 u=kal n=ansible | Using module file /home/kal/.local/lib/python3.10/site-packages/ansible/modules/apt.py
2022-12-29 23:31:40,031 p=71284 u=kal n=ansible | <127.0.0.1> PUT /home/kal/.ansible/tmp/ansible-local-712841piedbjp/tmpvd8ouvmw TO /home/kal/.ansible/tmp/ansible-tmp-1672374699.9184387-71408-257266608706374/AnsiballZ_apt.py
2022-12-29 23:31:40,031 p=71284 u=kal n=ansible | <127.0.0.1> EXEC /bin/sh -c 'chmod u+x /home/kal/.ansible/tmp/ansible-tmp-1672374699.9184387-71408-257266608706374/ /home/kal/.ansible/tmp/ansible-tmp-1672374699.9184387-71408-257266608706374/AnsiballZ_apt.py && sleep 0'
2022-12-29 23:31:40,033 p=71284 u=kal n=ansible | <127.0.0.1> EXEC /bin/sh -c 'sudo -H -S -n  -u root /bin/sh -c '"'"'echo BECOME-SUCCESS-ntbrglxnrbvekteiuowgfqjxdsqoprjh ; /usr/bin/python2 /home/kal/.ansible/tmp/ansible-tmp-1672374699.9184387-71408-257266608706374/AnsiballZ_apt.py'"'"' && sleep 0'
2022-12-29 23:31:41,056 p=71284 u=kal n=ansible | <127.0.0.1> EXEC /bin/sh -c 'rm -f -r /home/kal/.ansible/tmp/ansible-tmp-1672374699.9184387-71408-257266608706374/ > /dev/null 2>&1 && sleep 0'
2022-12-29 23:31:41,061 p=71284 u=kal n=ansible | ok: [krpz] => {
    "cache_update_time": 1672373899,
    "cache_updated": false,
    "changed": false,
    "invocation": {
        "module_args": {
            "allow_change_held_packages": false,
            "allow_downgrade": false,
            "allow_unauthenticated": false,
            "autoclean": false,
            "autoremove": false,
            "cache_valid_time": 0,
            "clean": false,
            "deb": null,
            "default_release": null,
            "dpkg_options": "force-confdef,force-confold",
            "fail_on_autoremove": false,
            "force": false,
            "force_apt_get": false,
            "install_recommends": null,
            "lock_timeout": 60,
            "name": [
                "zsh"
            ],
            "only_upgrade": false,
            "package": [
                "zsh"
            ],
            "policy_rc_d": null,
            "purge": false,
            "state": "latest",
            "update_cache": null,
            "update_cache_retries": 5,
            "update_cache_retry_max_delay": 12,
            "upgrade": null
        }
    }
}
2022-12-29 23:31:41,070 p=71284 u=kal n=ansible | TASK [Ensure the user has a zsh shell.] **************************************************************************************************************
2022-12-29 23:31:41,083 p=71284 u=kal n=ansible | <127.0.0.1> ESTABLISH LOCAL CONNECTION FOR USER: kal
2022-12-29 23:31:41,084 p=71284 u=kal n=ansible | <127.0.0.1> EXEC /bin/sh -c 'echo ~kal && sleep 0'
2022-12-29 23:31:41,085 p=71284 u=kal n=ansible | <127.0.0.1> EXEC /bin/sh -c '( umask 77 && mkdir -p "` echo /home/kal/.ansible/tmp `"&& mkdir "` echo /home/kal/.ansible/tmp/ansible-tmp-1672374701.0854769-71446-61008634432258 `" && echo ansible-tmp-1672374701.0854769-71446-61008634432258="` echo /home/kal/.ansible/tmp/ansible-tmp-1672374701.0854769-71446-61008634432258 `" ) && sleep 0'
2022-12-29 23:31:41,203 p=71284 u=kal n=ansible | Using module file /home/kal/.local/lib/python3.10/site-packages/ansible/modules/user.py
2022-12-29 23:31:41,203 p=71284 u=kal n=ansible | <127.0.0.1> PUT /home/kal/.ansible/tmp/ansible-local-712841piedbjp/tmp5jo6qt2p TO /home/kal/.ansible/tmp/ansible-tmp-1672374701.0854769-71446-61008634432258/AnsiballZ_user.py
2022-12-29 23:31:41,204 p=71284 u=kal n=ansible | <127.0.0.1> EXEC /bin/sh -c 'chmod u+x /home/kal/.ansible/tmp/ansible-tmp-1672374701.0854769-71446-61008634432258/ /home/kal/.ansible/tmp/ansible-tmp-1672374701.0854769-71446-61008634432258/AnsiballZ_user.py && sleep 0'
2022-12-29 23:31:41,206 p=71284 u=kal n=ansible | <127.0.0.1> EXEC /bin/sh -c 'sudo -H -S -n  -u root /bin/sh -c '"'"'echo BECOME-SUCCESS-uofqidwabslyeaslsbuynwpissynyetz ; /usr/bin/python2 /home/kal/.ansible/tmp/ansible-tmp-1672374701.0854769-71446-61008634432258/AnsiballZ_user.py'"'"' && sleep 0'
2022-12-29 23:31:41,299 p=71284 u=kal n=ansible | <127.0.0.1> EXEC /bin/sh -c 'rm -f -r /home/kal/.ansible/tmp/ansible-tmp-1672374701.0854769-71446-61008634432258/ > /dev/null 2>&1 && sleep 0'
2022-12-29 23:31:41,303 p=71284 u=kal n=ansible | ok: [krpz] => {
    "append": false,
    "changed": false,
    "comment": "Kalyan Parajuli,,,",
    "group": 1000,
    "home": "/home/kal",
    "invocation": {
        "module_args": {
            "append": false,
            "authorization": null,
            "comment": null,
            "create_home": true,
            "expires": null,
            "force": false,
            "generate_ssh_key": null,
            "group": null,
            "groups": null,
            "hidden": null,
            "home": null,
            "local": null,
            "login_class": null,
            "move_home": false,
            "name": "kal",
            "non_unique": false,
            "password": null,
            "password_expire_max": null,
            "password_expire_min": null,
            "password_lock": null,
            "profile": null,
            "remove": false,
            "role": null,
            "seuser": null,
            "shell": "/usr/bin/zsh",
            "skeleton": null,
            "ssh_key_bits": 0,
            "ssh_key_comment": "ansible-generated on KRPZ",
            "ssh_key_file": null,
            "ssh_key_passphrase": null,
            "ssh_key_type": "rsa",
            "state": "present",
            "system": false,
            "uid": null,
            "umask": null,
            "update_password": "always"
        }
    },
    "move_home": false,
    "name": "kal",
    "shell": "/usr/bin/zsh",
    "state": "present",
    "uid": 1000
}
2022-12-29 23:31:41,311 p=71284 u=kal n=ansible | TASK [Download default .zshrc] ***********************************************************************************************************************
2022-12-29 23:31:41,321 p=71284 u=kal n=ansible | <127.0.0.1> ESTABLISH LOCAL CONNECTION FOR USER: kal
2022-12-29 23:31:41,321 p=71284 u=kal n=ansible | <127.0.0.1> EXEC /bin/sh -c 'echo ~kal && sleep 0'
2022-12-29 23:31:41,322 p=71284 u=kal n=ansible | <127.0.0.1> EXEC /bin/sh -c '( umask 77 && mkdir -p "` echo /home/kal/.ansible/tmp `"&& mkdir "` echo /home/kal/.ansible/tmp/ansible-tmp-1672374701.3224034-71479-272199720853912 `" && echo ansible-tmp-1672374701.3224034-71479-272199720853912="` echo /home/kal/.ansible/tmp/ansible-tmp-1672374701.3224034-71479-272199720853912 `" ) && sleep 0'
2022-12-29 23:31:41,429 p=71284 u=kal n=ansible | Using module file /home/kal/.local/lib/python3.10/site-packages/ansible/modules/get_url.py
2022-12-29 23:31:41,429 p=71284 u=kal n=ansible | <127.0.0.1> PUT /home/kal/.ansible/tmp/ansible-local-712841piedbjp/tmp3jmi3vqc TO /home/kal/.ansible/tmp/ansible-tmp-1672374701.3224034-71479-272199720853912/AnsiballZ_get_url.py
2022-12-29 23:31:41,429 p=71284 u=kal n=ansible | <127.0.0.1> EXEC /bin/sh -c 'chmod u+x /home/kal/.ansible/tmp/ansible-tmp-1672374701.3224034-71479-272199720853912/ /home/kal/.ansible/tmp/ansible-tmp-1672374701.3224034-71479-272199720853912/AnsiballZ_get_url.py && sleep 0'
2022-12-29 23:31:41,432 p=71284 u=kal n=ansible | <127.0.0.1> EXEC /bin/sh -c 'sudo -H -S -n  -u root /bin/sh -c '"'"'echo BECOME-SUCCESS-kjpnnypsdtwiohivgnyrssbdagrxqcvf ; /usr/bin/python2 /home/kal/.ansible/tmp/ansible-tmp-1672374701.3224034-71479-272199720853912/AnsiballZ_get_url.py'"'"' && sleep 0'
2022-12-29 23:31:41,758 p=71284 u=kal n=ansible | <127.0.0.1> EXEC /bin/sh -c 'rm -f -r /home/kal/.ansible/tmp/ansible-tmp-1672374701.3224034-71479-272199720853912/ > /dev/null 2>&1 && sleep 0'
2022-12-29 23:31:41,780 p=71284 u=kal n=ansible | ok: [krpz] => {
    "changed": false,
    "checksum_dest": "b460da243c86531bffcab465b29a79f8aee49396",
    "checksum_src": "b460da243c86531bffcab465b29a79f8aee49396",
    "dest": "/root/.zshrc",
    "elapsed": 0,
    "gid": 0,
    "group": "root",
    "invocation": {
        "module_args": {
            "attributes": null,
            "backup": false,
            "checksum": "",
            "ciphers": null,
            "client_cert": null,
            "client_key": null,
            "decompress": true,
            "dest": "/root/.zshrc",
            "force": false,
            "force_basic_auth": false,
            "group": null,
            "headers": null,
            "http_agent": "ansible-httpget",
            "mode": "0440",
            "owner": null,
            "selevel": null,
            "serole": null,
            "setype": null,
            "seuser": null,
            "timeout": 10,
            "tmp_dest": null,
            "unredirected_headers": [],
            "unsafe_writes": false,
            "url": "https://gist.githubusercontent.com/kpbeta/39cc785da0898096f2e3d38b2c344359/raw/e856dd98e24427ba0d48729ac17a03ad23456021/default-zshrc",
            "url_password": null,
            "url_username": null,
            "use_gssapi": false,
            "use_netrc": true,
            "use_proxy": true,
            "validate_certs": true
        }
    },
    "md5sum": "dac3563a2ddd13e8027b1861d415f3d4",
    "mode": "0440",
    "msg": "OK (1295 bytes)",
    "owner": "root",
    "size": 1295,
    "src": "/home/kal/.ansible/tmp/ansible-tmp-1672374701.3224034-71479-272199720853912/tmpzexrNH",
    "state": "file",
    "status_code": 200,
    "uid": 0,
    "url": "https://gist.githubusercontent.com/kpbeta/39cc785da0898096f2e3d38b2c344359/raw/e856dd98e24427ba0d48729ac17a03ad23456021/default-zshrc"
}
2022-12-29 23:31:41,809 p=71284 u=kal n=ansible | TASK [Install shell utilities w/ apt] ****************************************************************************************************************
2022-12-29 23:31:41,824 p=71284 u=kal n=ansible | <127.0.0.1> ESTABLISH LOCAL CONNECTION FOR USER: kal
2022-12-29 23:31:41,825 p=71284 u=kal n=ansible | <127.0.0.1> EXEC /bin/sh -c 'echo ~kal && sleep 0'
2022-12-29 23:31:41,828 p=71284 u=kal n=ansible | <127.0.0.1> EXEC /bin/sh -c '( umask 77 && mkdir -p "` echo /home/kal/.ansible/tmp `"&& mkdir "` echo /home/kal/.ansible/tmp/ansible-tmp-1672374701.827443-71510-220868000948154 `" && echo ansible-tmp-1672374701.827443-71510-220868000948154="` echo /home/kal/.ansible/tmp/ansible-tmp-1672374701.827443-71510-220868000948154 `" ) && sleep 0'
2022-12-29 23:31:41,834 p=71284 u=kal n=ansible | Using module file /home/kal/.local/lib/python3.10/site-packages/ansible/modules/apt.py
2022-12-29 23:31:41,835 p=71284 u=kal n=ansible | <127.0.0.1> PUT /home/kal/.ansible/tmp/ansible-local-712841piedbjp/tmprbsr1tg_ TO /home/kal/.ansible/tmp/ansible-tmp-1672374701.827443-71510-220868000948154/AnsiballZ_apt.py
2022-12-29 23:31:41,835 p=71284 u=kal n=ansible | <127.0.0.1> EXEC /bin/sh -c 'chmod u+x /home/kal/.ansible/tmp/ansible-tmp-1672374701.827443-71510-220868000948154/ /home/kal/.ansible/tmp/ansible-tmp-1672374701.827443-71510-220868000948154/AnsiballZ_apt.py && sleep 0'
2022-12-29 23:31:41,838 p=71284 u=kal n=ansible | <127.0.0.1> EXEC /bin/sh -c 'sudo -H -S -n  -u root /bin/sh -c '"'"'echo BECOME-SUCCESS-idwcowgusecsbhiyhoxjfomsoqhjvvyc ; /usr/bin/python2 /home/kal/.ansible/tmp/ansible-tmp-1672374701.827443-71510-220868000948154/AnsiballZ_apt.py'"'"' && sleep 0'
2022-12-29 23:31:42,890 p=71284 u=kal n=ansible | <127.0.0.1> EXEC /bin/sh -c 'rm -f -r /home/kal/.ansible/tmp/ansible-tmp-1672374701.827443-71510-220868000948154/ > /dev/null 2>&1 && sleep 0'
2022-12-29 23:31:42,895 p=71284 u=kal n=ansible | ok: [krpz] => {
    "cache_update_time": 1672373899,
    "cache_updated": false,
    "changed": false,
    "invocation": {
        "module_args": {
            "allow_change_held_packages": false,
            "allow_downgrade": false,
            "allow_unauthenticated": false,
            "autoclean": false,
            "autoremove": false,
            "cache_valid_time": 0,
            "clean": false,
            "deb": null,
            "default_release": null,
            "dpkg_options": "force-confdef,force-confold",
            "fail_on_autoremove": false,
            "force": false,
            "force_apt_get": false,
            "install_recommends": null,
            "lock_timeout": 60,
            "name": [
                "tmux",
                "xclip",
                "xcape",
                "openssh-server"
            ],
            "only_upgrade": false,
            "package": [
                "tmux",
                "xclip",
                "xcape",
                "openssh-server"
            ],
            "policy_rc_d": null,
            "purge": false,
            "state": "latest",
            "update_cache": null,
            "update_cache_retries": 5,
            "update_cache_retry_max_delay": 12,
            "upgrade": null
        }
    }
}
2022-12-29 23:31:42,904 p=71284 u=kal n=ansible | TASK [Install other utilities (wget, curl, git, etc.)] ***********************************************************************************************
2022-12-29 23:31:42,913 p=71284 u=kal n=ansible | <127.0.0.1> ESTABLISH LOCAL CONNECTION FOR USER: kal
2022-12-29 23:31:42,913 p=71284 u=kal n=ansible | <127.0.0.1> EXEC /bin/sh -c 'echo ~kal && sleep 0'
2022-12-29 23:31:42,914 p=71284 u=kal n=ansible | <127.0.0.1> EXEC /bin/sh -c '( umask 77 && mkdir -p "` echo /home/kal/.ansible/tmp `"&& mkdir "` echo /home/kal/.ansible/tmp/ansible-tmp-1672374702.9144363-71549-221283384351107 `" && echo ansible-tmp-1672374702.9144363-71549-221283384351107="` echo /home/kal/.ansible/tmp/ansible-tmp-1672374702.9144363-71549-221283384351107 `" ) && sleep 0'
2022-12-29 23:31:42,918 p=71284 u=kal n=ansible | Using module file /home/kal/.local/lib/python3.10/site-packages/ansible/modules/apt.py
2022-12-29 23:31:42,919 p=71284 u=kal n=ansible | <127.0.0.1> PUT /home/kal/.ansible/tmp/ansible-local-712841piedbjp/tmpccyivq_u TO /home/kal/.ansible/tmp/ansible-tmp-1672374702.9144363-71549-221283384351107/AnsiballZ_apt.py
2022-12-29 23:31:42,919 p=71284 u=kal n=ansible | <127.0.0.1> EXEC /bin/sh -c 'chmod u+x /home/kal/.ansible/tmp/ansible-tmp-1672374702.9144363-71549-221283384351107/ /home/kal/.ansible/tmp/ansible-tmp-1672374702.9144363-71549-221283384351107/AnsiballZ_apt.py && sleep 0'
2022-12-29 23:31:42,921 p=71284 u=kal n=ansible | <127.0.0.1> EXEC /bin/sh -c 'sudo -H -S -n  -u root /bin/sh -c '"'"'echo BECOME-SUCCESS-gmvtivtkctzxcsbqdncelgerbgvyumug ; /usr/bin/python2 /home/kal/.ansible/tmp/ansible-tmp-1672374702.9144363-71549-221283384351107/AnsiballZ_apt.py'"'"' && sleep 0'
2022-12-29 23:31:43,980 p=71284 u=kal n=ansible | <127.0.0.1> EXEC /bin/sh -c 'rm -f -r /home/kal/.ansible/tmp/ansible-tmp-1672374702.9144363-71549-221283384351107/ > /dev/null 2>&1 && sleep 0'
2022-12-29 23:31:43,985 p=71284 u=kal n=ansible | ok: [krpz] => {
    "cache_update_time": 1672373899,
    "cache_updated": false,
    "changed": false,
    "invocation": {
        "module_args": {
            "allow_change_held_packages": false,
            "allow_downgrade": false,
            "allow_unauthenticated": false,
            "autoclean": false,
            "autoremove": false,
            "cache_valid_time": 0,
            "clean": false,
            "deb": null,
            "default_release": null,
            "dpkg_options": "force-confdef,force-confold",
            "fail_on_autoremove": false,
            "force": false,
            "force_apt_get": false,
            "install_recommends": null,
            "lock_timeout": 60,
            "name": [
                "python3",
                "python2",
                "curl",
                "wget",
                "git",
                "bat",
                "exa",
                "zoxide",
                "ripgrep",
                "fd-find"
            ],
            "only_upgrade": false,
            "package": [
                "python3",
                "python2",
                "curl",
                "wget",
                "git",
                "bat",
                "exa",
                "zoxide",
                "ripgrep",
                "fd-find"
            ],
            "policy_rc_d": null,
            "purge": false,
            "state": "latest",
            "update_cache": null,
            "update_cache_retries": 5,
            "update_cache_retry_max_delay": 12,
            "upgrade": null
        }
    }
}
2022-12-29 23:31:43,993 p=71284 u=kal n=ansible | TASK [Set environment managers (direnv, npm, conda)] *************************************************************************************************
2022-12-29 23:31:44,003 p=71284 u=kal n=ansible | <127.0.0.1> ESTABLISH LOCAL CONNECTION FOR USER: kal
2022-12-29 23:31:44,003 p=71284 u=kal n=ansible | <127.0.0.1> EXEC /bin/sh -c 'echo ~kal && sleep 0'
2022-12-29 23:31:44,005 p=71284 u=kal n=ansible | <127.0.0.1> EXEC /bin/sh -c '( umask 77 && mkdir -p "` echo /home/kal/.ansible/tmp `"&& mkdir "` echo /home/kal/.ansible/tmp/ansible-tmp-1672374704.0046136-71587-47827686448618 `" && echo ansible-tmp-1672374704.0046136-71587-47827686448618="` echo /home/kal/.ansible/tmp/ansible-tmp-1672374704.0046136-71587-47827686448618 `" ) && sleep 0'
2022-12-29 23:31:44,009 p=71284 u=kal n=ansible | Using module file /home/kal/.local/lib/python3.10/site-packages/ansible/modules/apt.py
2022-12-29 23:31:44,009 p=71284 u=kal n=ansible | <127.0.0.1> PUT /home/kal/.ansible/tmp/ansible-local-712841piedbjp/tmp8nqsqvri TO /home/kal/.ansible/tmp/ansible-tmp-1672374704.0046136-71587-47827686448618/AnsiballZ_apt.py
2022-12-29 23:31:44,010 p=71284 u=kal n=ansible | <127.0.0.1> EXEC /bin/sh -c 'chmod u+x /home/kal/.ansible/tmp/ansible-tmp-1672374704.0046136-71587-47827686448618/ /home/kal/.ansible/tmp/ansible-tmp-1672374704.0046136-71587-47827686448618/AnsiballZ_apt.py && sleep 0'
2022-12-29 23:31:44,012 p=71284 u=kal n=ansible | <127.0.0.1> EXEC /bin/sh -c 'sudo -H -S -n  -u root /bin/sh -c '"'"'echo BECOME-SUCCESS-nlnhkeyfijdilckvfywxtyldntpqwutq ; /usr/bin/python2 /home/kal/.ansible/tmp/ansible-tmp-1672374704.0046136-71587-47827686448618/AnsiballZ_apt.py'"'"' && sleep 0'
2022-12-29 23:31:45,033 p=71284 u=kal n=ansible | <127.0.0.1> EXEC /bin/sh -c 'rm -f -r /home/kal/.ansible/tmp/ansible-tmp-1672374704.0046136-71587-47827686448618/ > /dev/null 2>&1 && sleep 0'
2022-12-29 23:31:45,038 p=71284 u=kal n=ansible | ok: [krpz] => {
    "cache_update_time": 1672373899,
    "cache_updated": false,
    "changed": false,
    "invocation": {
        "module_args": {
            "allow_change_held_packages": false,
            "allow_downgrade": false,
            "allow_unauthenticated": false,
            "autoclean": false,
            "autoremove": false,
            "cache_valid_time": 0,
            "clean": false,
            "deb": null,
            "default_release": null,
            "dpkg_options": "force-confdef,force-confold",
            "fail_on_autoremove": false,
            "force": false,
            "force_apt_get": false,
            "install_recommends": null,
            "lock_timeout": 60,
            "name": [
                "direnv"
            ],
            "only_upgrade": false,
            "package": [
                "direnv"
            ],
            "policy_rc_d": null,
            "purge": false,
            "state": "latest",
            "update_cache": null,
            "update_cache_retries": 5,
            "update_cache_retry_max_delay": 12,
            "upgrade": null
        }
    }
}
2022-12-29 23:31:45,046 p=71284 u=kal n=ansible | TASK [Install NVM] ***********************************************************************************************************************************
2022-12-29 23:31:45,057 p=71284 u=kal n=ansible | <127.0.0.1> ESTABLISH LOCAL CONNECTION FOR USER: kal
2022-12-29 23:31:45,058 p=71284 u=kal n=ansible | <127.0.0.1> EXEC /bin/sh -c 'echo ~kal && sleep 0'
2022-12-29 23:31:45,059 p=71284 u=kal n=ansible | <127.0.0.1> EXEC /bin/sh -c '( umask 77 && mkdir -p "` echo /home/kal/.ansible/tmp `"&& mkdir "` echo /home/kal/.ansible/tmp/ansible-tmp-1672374705.0595086-71627-2700516363912 `" && echo ansible-tmp-1672374705.0595086-71627-2700516363912="` echo /home/kal/.ansible/tmp/ansible-tmp-1672374705.0595086-71627-2700516363912 `" ) && sleep 0'
2022-12-29 23:31:45,151 p=71284 u=kal n=ansible | Using module file /home/kal/.local/lib/python3.10/site-packages/ansible/modules/command.py
2022-12-29 23:31:45,151 p=71284 u=kal n=ansible | <127.0.0.1> PUT /home/kal/.ansible/tmp/ansible-local-712841piedbjp/tmpmo6d7q6h TO /home/kal/.ansible/tmp/ansible-tmp-1672374705.0595086-71627-2700516363912/AnsiballZ_command.py
2022-12-29 23:31:45,152 p=71284 u=kal n=ansible | <127.0.0.1> EXEC /bin/sh -c 'chmod u+x /home/kal/.ansible/tmp/ansible-tmp-1672374705.0595086-71627-2700516363912/ /home/kal/.ansible/tmp/ansible-tmp-1672374705.0595086-71627-2700516363912/AnsiballZ_command.py && sleep 0'
2022-12-29 23:31:45,154 p=71284 u=kal n=ansible | <127.0.0.1> EXEC /bin/sh -c 'sudo -H -S -n  -u root /bin/sh -c '"'"'echo BECOME-SUCCESS-dqiwpvtmnwpcozavutatqievewpbkins ; /usr/bin/python2 /home/kal/.ansible/tmp/ansible-tmp-1672374705.0595086-71627-2700516363912/AnsiballZ_command.py'"'"' && sleep 0'
2022-12-29 23:31:45,217 p=71284 u=kal n=ansible | <127.0.0.1> EXEC /bin/sh -c 'rm -f -r /home/kal/.ansible/tmp/ansible-tmp-1672374705.0595086-71627-2700516363912/ > /dev/null 2>&1 && sleep 0'
2022-12-29 23:31:45,221 p=71284 u=kal n=ansible | ok: [krpz] => {
    "changed": false,
    "cmd": "curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.3/install.sh | bash\n",
    "delta": null,
    "end": null,
    "invocation": {
        "module_args": {
            "_raw_params": "curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.3/install.sh | bash\n",
            "_uses_shell": true,
            "argv": null,
            "chdir": null,
            "creates": "/root/.nvm/nvm.sh",
            "executable": null,
            "removes": null,
            "stdin": null,
            "stdin_add_newline": true,
            "strip_empty_ends": true
        }
    },
    "msg": "Did not run command since '/root/.nvm/nvm.sh' exists",
    "rc": 0,
    "start": null,
    "stderr": "",
    "stderr_lines": [],
    "stdout": "skipped, since /root/.nvm/nvm.sh exists",
    "stdout_lines": [
        "skipped, since /root/.nvm/nvm.sh exists"
    ]
}
2022-12-29 23:31:45,228 p=71284 u=kal n=ansible | TASK [Install utilities (htop, tree, pstree, etc.)] **************************************************************************************************
2022-12-29 23:31:45,237 p=71284 u=kal n=ansible | <127.0.0.1> ESTABLISH LOCAL CONNECTION FOR USER: kal
2022-12-29 23:31:45,237 p=71284 u=kal n=ansible | <127.0.0.1> EXEC /bin/sh -c 'echo ~kal && sleep 0'
2022-12-29 23:31:45,239 p=71284 u=kal n=ansible | <127.0.0.1> EXEC /bin/sh -c '( umask 77 && mkdir -p "` echo /home/kal/.ansible/tmp `"&& mkdir "` echo /home/kal/.ansible/tmp/ansible-tmp-1672374705.239033-71656-23234381399166 `" && echo ansible-tmp-1672374705.239033-71656-23234381399166="` echo /home/kal/.ansible/tmp/ansible-tmp-1672374705.239033-71656-23234381399166 `" ) && sleep 0'
2022-12-29 23:31:45,243 p=71284 u=kal n=ansible | Using module file /home/kal/.local/lib/python3.10/site-packages/ansible/modules/apt.py
2022-12-29 23:31:45,243 p=71284 u=kal n=ansible | <127.0.0.1> PUT /home/kal/.ansible/tmp/ansible-local-712841piedbjp/tmp8u6en9_m TO /home/kal/.ansible/tmp/ansible-tmp-1672374705.239033-71656-23234381399166/AnsiballZ_apt.py
2022-12-29 23:31:45,243 p=71284 u=kal n=ansible | <127.0.0.1> EXEC /bin/sh -c 'chmod u+x /home/kal/.ansible/tmp/ansible-tmp-1672374705.239033-71656-23234381399166/ /home/kal/.ansible/tmp/ansible-tmp-1672374705.239033-71656-23234381399166/AnsiballZ_apt.py && sleep 0'
2022-12-29 23:31:45,245 p=71284 u=kal n=ansible | <127.0.0.1> EXEC /bin/sh -c 'sudo -H -S -n  -u root /bin/sh -c '"'"'echo BECOME-SUCCESS-evtbpfkqzypocwqbmcpktuherkzhftwz ; /usr/bin/python2 /home/kal/.ansible/tmp/ansible-tmp-1672374705.239033-71656-23234381399166/AnsiballZ_apt.py'"'"' && sleep 0'
2022-12-29 23:31:46,260 p=71284 u=kal n=ansible | <127.0.0.1> EXEC /bin/sh -c 'rm -f -r /home/kal/.ansible/tmp/ansible-tmp-1672374705.239033-71656-23234381399166/ > /dev/null 2>&1 && sleep 0'
2022-12-29 23:31:46,266 p=71284 u=kal n=ansible | ok: [krpz] => {
    "cache_update_time": 1672373899,
    "cache_updated": false,
    "changed": false,
    "invocation": {
        "module_args": {
            "allow_change_held_packages": false,
            "allow_downgrade": false,
            "allow_unauthenticated": false,
            "autoclean": false,
            "autoremove": false,
            "cache_valid_time": 0,
            "clean": false,
            "deb": null,
            "default_release": null,
            "dpkg_options": "force-confdef,force-confold",
            "fail_on_autoremove": false,
            "force": false,
            "force_apt_get": false,
            "install_recommends": null,
            "lock_timeout": 60,
            "name": [
                "htop",
                "tree",
                "net-tools",
                "psmisc",
                "trash-cli"
            ],
            "only_upgrade": false,
            "package": [
                "htop",
                "tree",
                "net-tools",
                "psmisc",
                "trash-cli"
            ],
            "policy_rc_d": null,
            "purge": false,
            "state": "latest",
            "update_cache": null,
            "update_cache_retries": 5,
            "update_cache_retry_max_delay": 12,
            "upgrade": null
        }
    }
}
2022-12-29 23:31:46,274 p=71284 u=kal n=ansible | TASK [Install VM techs] ******************************************************************************************************************************
2022-12-29 23:31:46,283 p=71284 u=kal n=ansible | <127.0.0.1> ESTABLISH LOCAL CONNECTION FOR USER: kal
2022-12-29 23:31:46,283 p=71284 u=kal n=ansible | <127.0.0.1> EXEC /bin/sh -c 'echo ~kal && sleep 0'
2022-12-29 23:31:46,285 p=71284 u=kal n=ansible | <127.0.0.1> EXEC /bin/sh -c '( umask 77 && mkdir -p "` echo /home/kal/.ansible/tmp `"&& mkdir "` echo /home/kal/.ansible/tmp/ansible-tmp-1672374706.2845805-71694-155709535028067 `" && echo ansible-tmp-1672374706.2845805-71694-155709535028067="` echo /home/kal/.ansible/tmp/ansible-tmp-1672374706.2845805-71694-155709535028067 `" ) && sleep 0'
2022-12-29 23:31:46,288 p=71284 u=kal n=ansible | Using module file /home/kal/.local/lib/python3.10/site-packages/ansible/modules/apt.py
2022-12-29 23:31:46,289 p=71284 u=kal n=ansible | <127.0.0.1> PUT /home/kal/.ansible/tmp/ansible-local-712841piedbjp/tmp8glr4j5m TO /home/kal/.ansible/tmp/ansible-tmp-1672374706.2845805-71694-155709535028067/AnsiballZ_apt.py
2022-12-29 23:31:46,289 p=71284 u=kal n=ansible | <127.0.0.1> EXEC /bin/sh -c 'chmod u+x /home/kal/.ansible/tmp/ansible-tmp-1672374706.2845805-71694-155709535028067/ /home/kal/.ansible/tmp/ansible-tmp-1672374706.2845805-71694-155709535028067/AnsiballZ_apt.py && sleep 0'
2022-12-29 23:31:46,291 p=71284 u=kal n=ansible | <127.0.0.1> EXEC /bin/sh -c 'sudo -H -S -n  -u root /bin/sh -c '"'"'echo BECOME-SUCCESS-xvdpnxrimfyspikhubdfnvzgdelwklar ; /usr/bin/python2 /home/kal/.ansible/tmp/ansible-tmp-1672374706.2845805-71694-155709535028067/AnsiballZ_apt.py'"'"' && sleep 0'
2022-12-29 23:31:47,316 p=71284 u=kal n=ansible | <127.0.0.1> EXEC /bin/sh -c 'rm -f -r /home/kal/.ansible/tmp/ansible-tmp-1672374706.2845805-71694-155709535028067/ > /dev/null 2>&1 && sleep 0'
2022-12-29 23:31:47,321 p=71284 u=kal n=ansible | ok: [krpz] => {
    "cache_update_time": 1672373899,
    "cache_updated": false,
    "changed": false,
    "invocation": {
        "module_args": {
            "allow_change_held_packages": false,
            "allow_downgrade": false,
            "allow_unauthenticated": false,
            "autoclean": false,
            "autoremove": false,
            "cache_valid_time": 0,
            "clean": false,
            "deb": null,
            "default_release": null,
            "dpkg_options": "force-confdef,force-confold",
            "fail_on_autoremove": false,
            "force": false,
            "force_apt_get": false,
            "install_recommends": null,
            "lock_timeout": 60,
            "name": [
                "vagrant",
                "docker.io"
            ],
            "only_upgrade": false,
            "package": [
                "vagrant",
                "docker.io"
            ],
            "policy_rc_d": null,
            "purge": false,
            "state": "latest",
            "update_cache": null,
            "update_cache_retries": 5,
            "update_cache_retry_max_delay": 12,
            "upgrade": null
        }
    }
}
2022-12-29 23:31:47,329 p=71284 u=kal n=ansible | TASK [Install Rust] **********************************************************************************************************************************
2022-12-29 23:31:47,340 p=71284 u=kal n=ansible | <127.0.0.1> ESTABLISH LOCAL CONNECTION FOR USER: kal
2022-12-29 23:31:47,340 p=71284 u=kal n=ansible | <127.0.0.1> EXEC /bin/sh -c 'echo ~kal && sleep 0'
2022-12-29 23:31:47,341 p=71284 u=kal n=ansible | <127.0.0.1> EXEC /bin/sh -c '( umask 77 && mkdir -p "` echo /home/kal/.ansible/tmp `"&& mkdir "` echo /home/kal/.ansible/tmp/ansible-tmp-1672374707.3411918-71732-11982851108963 `" && echo ansible-tmp-1672374707.3411918-71732-11982851108963="` echo /home/kal/.ansible/tmp/ansible-tmp-1672374707.3411918-71732-11982851108963 `" ) && sleep 0'
2022-12-29 23:31:47,433 p=71284 u=kal n=ansible | Using module file /home/kal/.local/lib/python3.10/site-packages/ansible/modules/expect.py
2022-12-29 23:31:47,434 p=71284 u=kal n=ansible | <127.0.0.1> PUT /home/kal/.ansible/tmp/ansible-local-712841piedbjp/tmp91z9knos TO /home/kal/.ansible/tmp/ansible-tmp-1672374707.3411918-71732-11982851108963/AnsiballZ_expect.py
2022-12-29 23:31:47,434 p=71284 u=kal n=ansible | <127.0.0.1> EXEC /bin/sh -c 'chmod u+x /home/kal/.ansible/tmp/ansible-tmp-1672374707.3411918-71732-11982851108963/ /home/kal/.ansible/tmp/ansible-tmp-1672374707.3411918-71732-11982851108963/AnsiballZ_expect.py && sleep 0'
2022-12-29 23:31:47,436 p=71284 u=kal n=ansible | <127.0.0.1> EXEC /bin/sh -c 'sudo -H -S -n  -u root /bin/sh -c '"'"'echo BECOME-SUCCESS-ouuwluhfazlwttdknkgtkfzxaoenvlzw ; /usr/bin/python2 /home/kal/.ansible/tmp/ansible-tmp-1672374707.3411918-71732-11982851108963/AnsiballZ_expect.py'"'"' && sleep 0'
2022-12-29 23:31:47,499 p=71284 u=kal n=ansible | <127.0.0.1> EXEC /bin/sh -c 'rm -f -r /home/kal/.ansible/tmp/ansible-tmp-1672374707.3411918-71732-11982851108963/ > /dev/null 2>&1 && sleep 0'
2022-12-29 23:31:47,503 p=71284 u=kal n=ansible | The full traceback is:
Traceback (most recent call last):
  File "/tmp/ansible_ansible.builtin.expect_payload_Sg2XAJ/ansible_ansible.builtin.expect_payload.zip/ansible/modules/expect.py", line 115, in <module>
ImportError: No module named pexpect

2022-12-29 23:31:47,503 p=71284 u=kal n=ansible | fatal: [krpz]: FAILED! => {
    "changed": false,
    "invocation": {
        "module_args": {
            "chdir": null,
            "command": "curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh",
            "creates": null,
            "echo": false,
            "removes": null,
            "responses": {
                "": ""
            },
            "timeout": 30
        }
    },
    "msg": "Failed to import the required Python library (pexpect) on KRPZ's Python /usr/bin/python2. Please read the module documentation and install it in the appropriate location. If the required library is installed, but Ansible is using the wrong Python interpreter, please consult the documentation on ansible_python_interpreter"
}
2022-12-29 23:31:47,504 p=71284 u=kal n=ansible | PLAY RECAP *******************************************************************************************************************************************
2022-12-29 23:31:47,504 p=71284 u=kal n=ansible | krpz                       : ok=10   changed=0    unreachable=0    failed=1    skipped=0    rescued=0    ignored=0   
2022-12-29 23:33:29,292 p=71902 u=kal n=ansible | ansible-playbook [core 2.14.1]
  config file = /home/kal/MyApplications/dotfiles/playbooks/ansible.cfg
  configured module search path = ['/home/kal/.ansible/plugins/modules', '/usr/share/ansible/plugins/modules']
  ansible python module location = /home/kal/.local/lib/python3.10/site-packages/ansible
  ansible collection location = /home/kal/.ansible/collections:/usr/share/ansible/collections
  executable location = /home/kal/.local/bin/ansible-playbook
  python version = 3.10.6 (main, Nov 14 2022, 16:10:14) [GCC 11.3.0] (/usr/bin/python3)
  jinja version = 3.1.2
  libyaml = True
2022-12-29 23:33:29,292 p=71902 u=kal n=ansible | Using /home/kal/MyApplications/dotfiles/playbooks/ansible.cfg as config file
2022-12-29 23:33:29,297 p=71902 u=kal n=ansible | host_list declined parsing /home/kal/MyApplications/dotfiles/playbooks/inventory.ini as it did not pass its verify_file() method
2022-12-29 23:33:29,297 p=71902 u=kal n=ansible | script declined parsing /home/kal/MyApplications/dotfiles/playbooks/inventory.ini as it did not pass its verify_file() method
2022-12-29 23:33:29,297 p=71902 u=kal n=ansible | auto declined parsing /home/kal/MyApplications/dotfiles/playbooks/inventory.ini as it did not pass its verify_file() method
2022-12-29 23:33:29,297 p=71902 u=kal n=ansible | yaml declined parsing /home/kal/MyApplications/dotfiles/playbooks/inventory.ini as it did not pass its verify_file() method
2022-12-29 23:33:29,298 p=71902 u=kal n=ansible | Parsed /home/kal/MyApplications/dotfiles/playbooks/inventory.ini inventory source with ini plugin
2022-12-29 23:33:29,362 p=71902 u=kal n=ansible | Skipping callback 'default', as we already have a stdout callback.
2022-12-29 23:33:29,362 p=71902 u=kal n=ansible | Skipping callback 'minimal', as we already have a stdout callback.
2022-12-29 23:33:29,362 p=71902 u=kal n=ansible | Skipping callback 'oneline', as we already have a stdout callback.
2022-12-29 23:33:29,362 p=71902 u=kal n=ansible | PLAYBOOK: all.yaml ***********************************************************************************************************************************
2022-12-29 23:33:29,362 p=71902 u=kal n=ansible | 1 plays in all.yaml
2022-12-29 23:33:29,363 p=71902 u=kal n=ansible | PLAY [localhost] *************************************************************************************************************************************
2022-12-29 23:33:29,371 p=71902 u=kal n=ansible | TASK [Gathering Facts] *******************************************************************************************************************************
2022-12-29 23:33:29,381 p=71902 u=kal n=ansible | <127.0.0.1> ESTABLISH LOCAL CONNECTION FOR USER: kal
2022-12-29 23:33:29,381 p=71902 u=kal n=ansible | <127.0.0.1> EXEC /bin/sh -c 'echo ~kal && sleep 0'
2022-12-29 23:33:29,382 p=71902 u=kal n=ansible | <127.0.0.1> EXEC /bin/sh -c '( umask 77 && mkdir -p "` echo /home/kal/.ansible/tmp `"&& mkdir "` echo /home/kal/.ansible/tmp/ansible-tmp-1672374809.3822553-71906-199215558943836 `" && echo ansible-tmp-1672374809.3822553-71906-199215558943836="` echo /home/kal/.ansible/tmp/ansible-tmp-1672374809.3822553-71906-199215558943836 `" ) && sleep 0'
2022-12-29 23:33:29,556 p=71902 u=kal n=ansible | Using module file /home/kal/.local/lib/python3.10/site-packages/ansible/modules/setup.py
2022-12-29 23:33:29,557 p=71902 u=kal n=ansible | <127.0.0.1> PUT /home/kal/.ansible/tmp/ansible-local-719023p_w7eeo/tmpdiz4kqc6 TO /home/kal/.ansible/tmp/ansible-tmp-1672374809.3822553-71906-199215558943836/AnsiballZ_setup.py
2022-12-29 23:33:29,557 p=71902 u=kal n=ansible | <127.0.0.1> EXEC /bin/sh -c 'chmod u+x /home/kal/.ansible/tmp/ansible-tmp-1672374809.3822553-71906-199215558943836/ /home/kal/.ansible/tmp/ansible-tmp-1672374809.3822553-71906-199215558943836/AnsiballZ_setup.py && sleep 0'
2022-12-29 23:33:29,559 p=71902 u=kal n=ansible | <127.0.0.1> EXEC /bin/sh -c 'sudo -H -S -n  -u root /bin/sh -c '"'"'echo BECOME-SUCCESS-kqktclrflwckxfikgwfemoazqxkwthfo ; /usr/bin/python2 /home/kal/.ansible/tmp/ansible-tmp-1672374809.3822553-71906-199215558943836/AnsiballZ_setup.py'"'"' && sleep 0'
2022-12-29 23:33:33,484 p=71902 u=kal n=ansible | <127.0.0.1> EXEC /bin/sh -c 'rm -f -r /home/kal/.ansible/tmp/ansible-tmp-1672374809.3822553-71906-199215558943836/ > /dev/null 2>&1 && sleep 0'
2022-12-29 23:33:33,505 p=71902 u=kal n=ansible | ok: [krpz]
2022-12-29 23:33:33,527 p=71902 u=kal n=ansible | TASK [Install Rust] **********************************************************************************************************************************
2022-12-29 23:33:33,536 p=71902 u=kal n=ansible | <127.0.0.1> ESTABLISH LOCAL CONNECTION FOR USER: kal
2022-12-29 23:33:33,536 p=71902 u=kal n=ansible | <127.0.0.1> EXEC /bin/sh -c 'echo ~kal && sleep 0'
2022-12-29 23:33:33,538 p=71902 u=kal n=ansible | <127.0.0.1> EXEC /bin/sh -c '( umask 77 && mkdir -p "` echo /home/kal/.ansible/tmp `"&& mkdir "` echo /home/kal/.ansible/tmp/ansible-tmp-1672374813.5378196-72026-41739738282548 `" && echo ansible-tmp-1672374813.5378196-72026-41739738282548="` echo /home/kal/.ansible/tmp/ansible-tmp-1672374813.5378196-72026-41739738282548 `" ) && sleep 0'
2022-12-29 23:33:33,629 p=71902 u=kal n=ansible | Using module file /home/kal/.local/lib/python3.10/site-packages/ansible/modules/expect.py
2022-12-29 23:33:33,629 p=71902 u=kal n=ansible | <127.0.0.1> PUT /home/kal/.ansible/tmp/ansible-local-719023p_w7eeo/tmp394p8i84 TO /home/kal/.ansible/tmp/ansible-tmp-1672374813.5378196-72026-41739738282548/AnsiballZ_expect.py
2022-12-29 23:33:33,630 p=71902 u=kal n=ansible | <127.0.0.1> EXEC /bin/sh -c 'chmod u+x /home/kal/.ansible/tmp/ansible-tmp-1672374813.5378196-72026-41739738282548/ /home/kal/.ansible/tmp/ansible-tmp-1672374813.5378196-72026-41739738282548/AnsiballZ_expect.py && sleep 0'
2022-12-29 23:33:33,632 p=71902 u=kal n=ansible | <127.0.0.1> EXEC /bin/sh -c 'sudo -H -S -n  -u root /bin/sh -c '"'"'echo BECOME-SUCCESS-odvhdropxdjcohrtfubqxysglfjytzkp ; /usr/bin/python2 /home/kal/.ansible/tmp/ansible-tmp-1672374813.5378196-72026-41739738282548/AnsiballZ_expect.py'"'"' && sleep 0'
2022-12-29 23:33:33,697 p=71902 u=kal n=ansible | <127.0.0.1> EXEC /bin/sh -c 'rm -f -r /home/kal/.ansible/tmp/ansible-tmp-1672374813.5378196-72026-41739738282548/ > /dev/null 2>&1 && sleep 0'
2022-12-29 23:33:33,702 p=71902 u=kal n=ansible | The full traceback is:
Traceback (most recent call last):
  File "/tmp/ansible_ansible.builtin.expect_payload_z1ZiK0/ansible_ansible.builtin.expect_payload.zip/ansible/modules/expect.py", line 115, in <module>
ImportError: No module named pexpect

2022-12-29 23:33:33,702 p=71902 u=kal n=ansible | fatal: [krpz]: FAILED! => {
    "changed": false,
    "invocation": {
        "module_args": {
            "chdir": null,
            "command": "curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh",
            "creates": null,
            "echo": false,
            "removes": null,
            "responses": {
                "(?i)password": "MySekretPa$$word"
            },
            "timeout": 30
        }
    },
    "msg": "Failed to import the required Python library (pexpect) on KRPZ's Python /usr/bin/python2. Please read the module documentation and install it in the appropriate location. If the required library is installed, but Ansible is using the wrong Python interpreter, please consult the documentation on ansible_python_interpreter"
}
2022-12-29 23:33:33,702 p=71902 u=kal n=ansible | PLAY RECAP *******************************************************************************************************************************************
2022-12-29 23:33:33,703 p=71902 u=kal n=ansible | krpz                       : ok=1    changed=0    unreachable=0    failed=1    skipped=0    rescued=0    ignored=0   
2022-12-29 23:36:48,215 p=72376 u=kal n=ansible | ansible-playbook [core 2.14.1]
  config file = /home/kal/MyApplications/dotfiles/playbooks/ansible.cfg
  configured module search path = ['/home/kal/.ansible/plugins/modules', '/usr/share/ansible/plugins/modules']
  ansible python module location = /home/kal/.local/lib/python3.10/site-packages/ansible
  ansible collection location = /home/kal/.ansible/collections:/usr/share/ansible/collections
  executable location = /home/kal/.local/bin/ansible-playbook
  python version = 3.10.6 (main, Nov 14 2022, 16:10:14) [GCC 11.3.0] (/usr/bin/python3)
  jinja version = 3.1.2
  libyaml = True
2022-12-29 23:36:48,215 p=72376 u=kal n=ansible | Using /home/kal/MyApplications/dotfiles/playbooks/ansible.cfg as config file
2022-12-29 23:36:48,284 p=72376 u=kal n=ansible | Skipping callback 'default', as we already have a stdout callback.
2022-12-29 23:36:48,284 p=72376 u=kal n=ansible | Skipping callback 'minimal', as we already have a stdout callback.
2022-12-29 23:36:48,285 p=72376 u=kal n=ansible | Skipping callback 'oneline', as we already have a stdout callback.
2022-12-29 23:36:48,285 p=72376 u=kal n=ansible | PLAYBOOK: all.yaml ***********************************************************************************************************************************
2022-12-29 23:36:48,285 p=72376 u=kal n=ansible | 1 plays in all.yaml
2022-12-29 23:36:48,286 p=72376 u=kal n=ansible | PLAY [localhost] *************************************************************************************************************************************
2022-12-29 23:36:48,292 p=72376 u=kal n=ansible | TASK [Gathering Facts] *******************************************************************************************************************************
2022-12-29 23:36:52,248 p=72376 u=kal n=ansible | ok: [krpz]
2022-12-29 23:36:52,271 p=72376 u=kal n=ansible | TASK [Install Rust] **********************************************************************************************************************************
2022-12-29 23:36:52,441 p=72376 u=kal n=ansible | An exception occurred during task execution. To see the full traceback, use -vvv. The error was: ImportError: No module named pexpect
2022-12-29 23:36:52,442 p=72376 u=kal n=ansible | fatal: [krpz]: FAILED! => {"changed": false, "msg": "Failed to import the required Python library (pexpect) on KRPZ's Python /usr/bin/python2. Please read the module documentation and install it in the appropriate location. If the required library is installed, but Ansible is using the wrong Python interpreter, please consult the documentation on ansible_python_interpreter"}
2022-12-29 23:36:52,442 p=72376 u=kal n=ansible | PLAY RECAP *******************************************************************************************************************************************
2022-12-29 23:36:52,442 p=72376 u=kal n=ansible | krpz                       : ok=1    changed=0    unreachable=0    failed=1    skipped=0    rescued=0    ignored=0   
2022-12-29 23:50:48,738 p=81684 u=kal n=ansible | ansible-playbook [core 2.14.1]
  config file = /home/kal/MyApplications/dotfiles/playbooks/ansible.cfg
  configured module search path = ['/home/kal/.ansible/plugins/modules', '/usr/share/ansible/plugins/modules']
  ansible python module location = /home/kal/.local/lib/python3.10/site-packages/ansible
  ansible collection location = /home/kal/.ansible/collections:/usr/share/ansible/collections
  executable location = /home/kal/.local/bin/ansible-playbook
  python version = 3.10.6 (main, Nov 14 2022, 16:10:14) [GCC 11.3.0] (/usr/bin/python3)
  jinja version = 3.1.2
  libyaml = True
2022-12-29 23:50:48,738 p=81684 u=kal n=ansible | Using /home/kal/MyApplications/dotfiles/playbooks/ansible.cfg as config file
2022-12-29 23:50:48,807 p=81684 u=kal n=ansible | Skipping callback 'default', as we already have a stdout callback.
2022-12-29 23:50:48,807 p=81684 u=kal n=ansible | Skipping callback 'minimal', as we already have a stdout callback.
2022-12-29 23:50:48,807 p=81684 u=kal n=ansible | Skipping callback 'oneline', as we already have a stdout callback.
2022-12-29 23:50:48,807 p=81684 u=kal n=ansible | PLAYBOOK: all.yaml ***********************************************************************************************************************************
2022-12-29 23:50:48,807 p=81684 u=kal n=ansible | 1 plays in all.yaml
2022-12-29 23:50:48,808 p=81684 u=kal n=ansible | PLAY [localhost] *************************************************************************************************************************************
2022-12-29 23:50:48,815 p=81684 u=kal n=ansible | TASK [Gathering Facts] *******************************************************************************************************************************
2022-12-29 23:50:52,753 p=81684 u=kal n=ansible | ok: [krpz]
2022-12-29 23:50:52,775 p=81684 u=kal n=ansible | TASK [Install Rust] **********************************************************************************************************************************
2022-12-29 23:50:52,943 p=81684 u=kal n=ansible | An exception occurred during task execution. To see the full traceback, use -vvv. The error was: ImportError: No module named pexpect
2022-12-29 23:50:52,943 p=81684 u=kal n=ansible | fatal: [krpz]: FAILED! => {"changed": false, "msg": "Failed to import the required Python library (pexpect) on KRPZ's Python /usr/bin/python2. Please read the module documentation and install it in the appropriate location. If the required library is installed, but Ansible is using the wrong Python interpreter, please consult the documentation on ansible_python_interpreter"}
2022-12-29 23:50:52,944 p=81684 u=kal n=ansible | PLAY RECAP *******************************************************************************************************************************************
2022-12-29 23:50:52,944 p=81684 u=kal n=ansible | krpz                       : ok=1    changed=0    unreachable=0    failed=1    skipped=0    rescued=0    ignored=0   
2022-12-29 23:52:04,080 p=81980 u=kal n=ansible | ansible-playbook [core 2.14.1]
  config file = /home/kal/MyApplications/dotfiles/playbooks/ansible.cfg
  configured module search path = ['/home/kal/.ansible/plugins/modules', '/usr/share/ansible/plugins/modules']
  ansible python module location = /home/kal/.local/lib/python3.10/site-packages/ansible
  ansible collection location = /home/kal/.ansible/collections:/usr/share/ansible/collections
  executable location = /home/kal/.local/bin/ansible-playbook
  python version = 3.10.6 (main, Nov 14 2022, 16:10:14) [GCC 11.3.0] (/usr/bin/python3)
  jinja version = 3.1.2
  libyaml = True
2022-12-29 23:52:04,080 p=81980 u=kal n=ansible | Using /home/kal/MyApplications/dotfiles/playbooks/ansible.cfg as config file
2022-12-29 23:52:04,150 p=81980 u=kal n=ansible | Skipping callback 'default', as we already have a stdout callback.
2022-12-29 23:52:04,151 p=81980 u=kal n=ansible | Skipping callback 'minimal', as we already have a stdout callback.
2022-12-29 23:52:04,151 p=81980 u=kal n=ansible | Skipping callback 'oneline', as we already have a stdout callback.
2022-12-29 23:52:04,151 p=81980 u=kal n=ansible | PLAYBOOK: all.yaml ***********************************************************************************************************************************
2022-12-29 23:52:04,151 p=81980 u=kal n=ansible | 1 plays in all.yaml
2022-12-29 23:52:04,152 p=81980 u=kal n=ansible | PLAY [localhost] *************************************************************************************************************************************
2022-12-29 23:52:04,158 p=81980 u=kal n=ansible | TASK [Gathering Facts] *******************************************************************************************************************************
2022-12-29 23:52:08,095 p=81980 u=kal n=ansible | ok: [krpz]
2022-12-29 23:52:08,117 p=81980 u=kal n=ansible | TASK [install pexpect] *******************************************************************************************************************************
2022-12-29 23:52:08,293 p=81980 u=kal n=ansible | fatal: [krpz]: FAILED! => {"changed": false, "msg": "Unsupported parameters for (pip) module: become. Supported parameters include: virtualenv, virtualenv_site_packages, executable, chdir, requirements, name, virtualenv_python, umask, editable, virtualenv_command, extra_args, state, version."}
2022-12-29 23:52:08,294 p=81980 u=kal n=ansible | PLAY RECAP *******************************************************************************************************************************************
2022-12-29 23:52:08,294 p=81980 u=kal n=ansible | krpz                       : ok=1    changed=0    unreachable=0    failed=1    skipped=0    rescued=0    ignored=0   
2022-12-29 23:52:24,950 p=82139 u=kal n=ansible | ansible-playbook [core 2.14.1]
  config file = /home/kal/MyApplications/dotfiles/playbooks/ansible.cfg
  configured module search path = ['/home/kal/.ansible/plugins/modules', '/usr/share/ansible/plugins/modules']
  ansible python module location = /home/kal/.local/lib/python3.10/site-packages/ansible
  ansible collection location = /home/kal/.ansible/collections:/usr/share/ansible/collections
  executable location = /home/kal/.local/bin/ansible-playbook
  python version = 3.10.6 (main, Nov 14 2022, 16:10:14) [GCC 11.3.0] (/usr/bin/python3)
  jinja version = 3.1.2
  libyaml = True
2022-12-29 23:52:24,950 p=82139 u=kal n=ansible | Using /home/kal/MyApplications/dotfiles/playbooks/ansible.cfg as config file
2022-12-29 23:52:25,022 p=82139 u=kal n=ansible | Skipping callback 'default', as we already have a stdout callback.
2022-12-29 23:52:25,022 p=82139 u=kal n=ansible | Skipping callback 'minimal', as we already have a stdout callback.
2022-12-29 23:52:25,022 p=82139 u=kal n=ansible | Skipping callback 'oneline', as we already have a stdout callback.
2022-12-29 23:52:25,022 p=82139 u=kal n=ansible | PLAYBOOK: all.yaml ***********************************************************************************************************************************
2022-12-29 23:52:25,022 p=82139 u=kal n=ansible | 1 plays in all.yaml
2022-12-29 23:52:25,023 p=82139 u=kal n=ansible | PLAY [localhost] *************************************************************************************************************************************
2022-12-29 23:52:25,030 p=82139 u=kal n=ansible | TASK [Gathering Facts] *******************************************************************************************************************************
2022-12-29 23:52:29,547 p=82139 u=kal n=ansible | ok: [krpz]
2022-12-29 23:52:29,568 p=82139 u=kal n=ansible | TASK [install pexpect] *******************************************************************************************************************************
2022-12-29 23:52:29,746 p=82139 u=kal n=ansible | An exception occurred during task execution. To see the full traceback, use -vvv. The error was: ImportError: No module named pkg_resources
2022-12-29 23:52:29,746 p=82139 u=kal n=ansible | fatal: [krpz]: FAILED! => {"changed": false, "msg": "Failed to import the required Python library (setuptools) on KRPZ's Python /usr/bin/python2. Please read the module documentation and install it in the appropriate location. If the required library is installed, but Ansible is using the wrong Python interpreter, please consult the documentation on ansible_python_interpreter"}
2022-12-29 23:52:29,747 p=82139 u=kal n=ansible | PLAY RECAP *******************************************************************************************************************************************
2022-12-29 23:52:29,747 p=82139 u=kal n=ansible | krpz                       : ok=1    changed=0    unreachable=0    failed=1    skipped=0    rescued=0    ignored=0   
2022-12-29 23:53:04,372 p=82325 u=kal n=ansible | ansible-playbook [core 2.14.1]
  config file = /home/kal/MyApplications/dotfiles/playbooks/ansible.cfg
  configured module search path = ['/home/kal/.ansible/plugins/modules', '/usr/share/ansible/plugins/modules']
  ansible python module location = /home/kal/.local/lib/python3.10/site-packages/ansible
  ansible collection location = /home/kal/.ansible/collections:/usr/share/ansible/collections
  executable location = /home/kal/.local/bin/ansible-playbook
  python version = 3.10.6 (main, Nov 14 2022, 16:10:14) [GCC 11.3.0] (/usr/bin/python3)
  jinja version = 3.1.2
  libyaml = True
2022-12-29 23:53:04,372 p=82325 u=kal n=ansible | Using /home/kal/MyApplications/dotfiles/playbooks/ansible.cfg as config file
2022-12-29 23:53:04,443 p=82325 u=kal n=ansible | Skipping callback 'default', as we already have a stdout callback.
2022-12-29 23:53:04,443 p=82325 u=kal n=ansible | Skipping callback 'minimal', as we already have a stdout callback.
2022-12-29 23:53:04,443 p=82325 u=kal n=ansible | Skipping callback 'oneline', as we already have a stdout callback.
2022-12-29 23:53:04,443 p=82325 u=kal n=ansible | PLAYBOOK: all.yaml ***********************************************************************************************************************************
2022-12-29 23:53:04,443 p=82325 u=kal n=ansible | 1 plays in all.yaml
2022-12-29 23:53:04,444 p=82325 u=kal n=ansible | PLAY [localhost] *************************************************************************************************************************************
2022-12-29 23:53:04,451 p=82325 u=kal n=ansible | TASK [Gathering Facts] *******************************************************************************************************************************
2022-12-29 23:53:08,405 p=82325 u=kal n=ansible | ok: [krpz]
2022-12-29 23:53:08,426 p=82325 u=kal n=ansible | TASK [install pexpect] *******************************************************************************************************************************
2022-12-29 23:53:08,604 p=82325 u=kal n=ansible | An exception occurred during task execution. To see the full traceback, use -vvv. The error was: ImportError: No module named pkg_resources
2022-12-29 23:53:08,604 p=82325 u=kal n=ansible | fatal: [krpz]: FAILED! => {"changed": false, "msg": "Failed to import the required Python library (setuptools) on KRPZ's Python /usr/bin/python2. Please read the module documentation and install it in the appropriate location. If the required library is installed, but Ansible is using the wrong Python interpreter, please consult the documentation on ansible_python_interpreter"}
2022-12-29 23:53:08,604 p=82325 u=kal n=ansible | PLAY RECAP *******************************************************************************************************************************************
2022-12-29 23:53:08,605 p=82325 u=kal n=ansible | krpz                       : ok=1    changed=0    unreachable=0    failed=1    skipped=0    rescued=0    ignored=0   
2022-12-29 23:53:24,705 p=82491 u=kal n=ansible | ansible-playbook [core 2.14.1]
  config file = /home/kal/MyApplications/dotfiles/playbooks/ansible.cfg
  configured module search path = ['/home/kal/.ansible/plugins/modules', '/usr/share/ansible/plugins/modules']
  ansible python module location = /home/kal/.local/lib/python3.10/site-packages/ansible
  ansible collection location = /home/kal/.ansible/collections:/usr/share/ansible/collections
  executable location = /home/kal/.local/bin/ansible-playbook
  python version = 3.10.6 (main, Nov 14 2022, 16:10:14) [GCC 11.3.0] (/usr/bin/python3)
  jinja version = 3.1.2
  libyaml = True
2022-12-29 23:53:24,706 p=82491 u=kal n=ansible | Using /home/kal/MyApplications/dotfiles/playbooks/ansible.cfg as config file
2022-12-29 23:53:24,775 p=82491 u=kal n=ansible | Skipping callback 'default', as we already have a stdout callback.
2022-12-29 23:53:24,775 p=82491 u=kal n=ansible | Skipping callback 'minimal', as we already have a stdout callback.
2022-12-29 23:53:24,775 p=82491 u=kal n=ansible | Skipping callback 'oneline', as we already have a stdout callback.
2022-12-29 23:53:24,775 p=82491 u=kal n=ansible | PLAYBOOK: all.yaml ***********************************************************************************************************************************
2022-12-29 23:53:24,775 p=82491 u=kal n=ansible | 1 plays in all.yaml
2022-12-29 23:53:24,776 p=82491 u=kal n=ansible | PLAY [localhost] *************************************************************************************************************************************
2022-12-29 23:53:24,782 p=82491 u=kal n=ansible | TASK [Gathering Facts] *******************************************************************************************************************************
2022-12-29 23:53:29,784 p=82491 u=kal n=ansible | ok: [krpz]
2022-12-29 23:53:29,806 p=82491 u=kal n=ansible | TASK [install pexpect] *******************************************************************************************************************************
2022-12-29 23:53:29,988 p=82491 u=kal n=ansible | An exception occurred during task execution. To see the full traceback, use -vvv. The error was: ImportError: No module named pkg_resources
2022-12-29 23:53:29,988 p=82491 u=kal n=ansible | fatal: [krpz]: FAILED! => {"changed": false, "msg": "Failed to import the required Python library (setuptools) on KRPZ's Python /usr/bin/python2. Please read the module documentation and install it in the appropriate location. If the required library is installed, but Ansible is using the wrong Python interpreter, please consult the documentation on ansible_python_interpreter"}
2022-12-29 23:53:29,989 p=82491 u=kal n=ansible | PLAY RECAP *******************************************************************************************************************************************
2022-12-29 23:53:29,989 p=82491 u=kal n=ansible | krpz                       : ok=1    changed=0    unreachable=0    failed=1    skipped=0    rescued=0    ignored=0   
2022-12-29 23:54:46,121 p=82939 u=kal n=ansible | ansible-playbook [core 2.14.1]
  config file = /home/kal/MyApplications/dotfiles/playbooks/ansible.cfg
  configured module search path = ['/home/kal/.ansible/plugins/modules', '/usr/share/ansible/plugins/modules']
  ansible python module location = /home/kal/.local/lib/python3.10/site-packages/ansible
  ansible collection location = /home/kal/.ansible/collections:/usr/share/ansible/collections
  executable location = /home/kal/.local/bin/ansible-playbook
  python version = 3.10.6 (main, Nov 14 2022, 16:10:14) [GCC 11.3.0] (/usr/bin/python3)
  jinja version = 3.1.2
  libyaml = True
2022-12-29 23:54:46,121 p=82939 u=kal n=ansible | Using /home/kal/MyApplications/dotfiles/playbooks/ansible.cfg as config file
2022-12-29 23:54:46,191 p=82939 u=kal n=ansible | Skipping callback 'default', as we already have a stdout callback.
2022-12-29 23:54:46,191 p=82939 u=kal n=ansible | Skipping callback 'minimal', as we already have a stdout callback.
2022-12-29 23:54:46,191 p=82939 u=kal n=ansible | Skipping callback 'oneline', as we already have a stdout callback.
2022-12-29 23:54:46,191 p=82939 u=kal n=ansible | PLAYBOOK: all.yaml ***********************************************************************************************************************************
2022-12-29 23:54:46,191 p=82939 u=kal n=ansible | 1 plays in all.yaml
2022-12-29 23:54:46,192 p=82939 u=kal n=ansible | PLAY [localhost] *************************************************************************************************************************************
2022-12-29 23:54:46,199 p=82939 u=kal n=ansible | TASK [Gathering Facts] *******************************************************************************************************************************
2022-12-29 23:54:50,150 p=82939 u=kal n=ansible | ok: [krpz]
2022-12-29 23:54:50,172 p=82939 u=kal n=ansible | TASK [install pexpect] *******************************************************************************************************************************
2022-12-29 23:54:50,349 p=82939 u=kal n=ansible | An exception occurred during task execution. To see the full traceback, use -vvv. The error was: ImportError: No module named pkg_resources
2022-12-29 23:54:50,350 p=82939 u=kal n=ansible | fatal: [krpz]: FAILED! => {"changed": false, "msg": "Failed to import the required Python library (setuptools) on KRPZ's Python /usr/bin/python2. Please read the module documentation and install it in the appropriate location. If the required library is installed, but Ansible is using the wrong Python interpreter, please consult the documentation on ansible_python_interpreter"}
2022-12-29 23:54:50,350 p=82939 u=kal n=ansible | PLAY RECAP *******************************************************************************************************************************************
2022-12-29 23:54:50,350 p=82939 u=kal n=ansible | krpz                       : ok=1    changed=0    unreachable=0    failed=1    skipped=0    rescued=0    ignored=0   
2022-12-29 23:56:21,100 p=83467 u=kal n=ansible | ansible-playbook [core 2.14.1]
  config file = /home/kal/MyApplications/dotfiles/playbooks/ansible.cfg
  configured module search path = ['/home/kal/.ansible/plugins/modules', '/usr/share/ansible/plugins/modules']
  ansible python module location = /home/kal/.local/lib/python3.10/site-packages/ansible
  ansible collection location = /home/kal/.ansible/collections:/usr/share/ansible/collections
  executable location = /home/kal/.local/bin/ansible-playbook
  python version = 3.10.6 (main, Nov 14 2022, 16:10:14) [GCC 11.3.0] (/usr/bin/python3)
  jinja version = 3.1.2
  libyaml = True
2022-12-29 23:56:21,100 p=83467 u=kal n=ansible | Using /home/kal/MyApplications/dotfiles/playbooks/ansible.cfg as config file
2022-12-29 23:56:21,170 p=83467 u=kal n=ansible | Skipping callback 'default', as we already have a stdout callback.
2022-12-29 23:56:21,171 p=83467 u=kal n=ansible | Skipping callback 'minimal', as we already have a stdout callback.
2022-12-29 23:56:21,171 p=83467 u=kal n=ansible | Skipping callback 'oneline', as we already have a stdout callback.
2022-12-29 23:56:21,171 p=83467 u=kal n=ansible | PLAYBOOK: all.yaml ***********************************************************************************************************************************
2022-12-29 23:56:21,171 p=83467 u=kal n=ansible | 1 plays in all.yaml
2022-12-29 23:56:21,172 p=83467 u=kal n=ansible | PLAY [localhost] *************************************************************************************************************************************
2022-12-29 23:56:21,179 p=83467 u=kal n=ansible | TASK [Gathering Facts] *******************************************************************************************************************************
2022-12-29 23:56:25,108 p=83467 u=kal n=ansible | ok: [krpz]
2022-12-29 23:56:25,130 p=83467 u=kal n=ansible | TASK [install pexpect] *******************************************************************************************************************************
2022-12-29 23:56:25,306 p=83467 u=kal n=ansible | An exception occurred during task execution. To see the full traceback, use -vvv. The error was: ImportError: No module named pkg_resources
2022-12-29 23:56:25,306 p=83467 u=kal n=ansible | fatal: [krpz]: FAILED! => {"changed": false, "msg": "Failed to import the required Python library (setuptools) on KRPZ's Python /usr/bin/python2. Please read the module documentation and install it in the appropriate location. If the required library is installed, but Ansible is using the wrong Python interpreter, please consult the documentation on ansible_python_interpreter"}
2022-12-29 23:56:25,307 p=83467 u=kal n=ansible | PLAY RECAP *******************************************************************************************************************************************
2022-12-29 23:56:25,307 p=83467 u=kal n=ansible | krpz                       : ok=1    changed=0    unreachable=0    failed=1    skipped=0    rescued=0    ignored=0   
2022-12-29 23:56:53,572 p=83673 u=kal n=ansible | ansible-playbook [core 2.14.1]
  config file = /home/kal/MyApplications/dotfiles/playbooks/ansible.cfg
  configured module search path = ['/home/kal/.ansible/plugins/modules', '/usr/share/ansible/plugins/modules']
  ansible python module location = /home/kal/.local/lib/python3.10/site-packages/ansible
  ansible collection location = /home/kal/.ansible/collections:/usr/share/ansible/collections
  executable location = /home/kal/.local/bin/ansible-playbook
  python version = 3.10.6 (main, Nov 14 2022, 16:10:14) [GCC 11.3.0] (/usr/bin/python3)
  jinja version = 3.1.2
  libyaml = True
2022-12-29 23:56:53,572 p=83673 u=kal n=ansible | Using /home/kal/MyApplications/dotfiles/playbooks/ansible.cfg as config file
2022-12-29 23:56:53,644 p=83673 u=kal n=ansible | Skipping callback 'default', as we already have a stdout callback.
2022-12-29 23:56:53,644 p=83673 u=kal n=ansible | Skipping callback 'minimal', as we already have a stdout callback.
2022-12-29 23:56:53,644 p=83673 u=kal n=ansible | Skipping callback 'oneline', as we already have a stdout callback.
2022-12-29 23:56:53,644 p=83673 u=kal n=ansible | PLAYBOOK: all.yaml ***********************************************************************************************************************************
2022-12-29 23:56:53,644 p=83673 u=kal n=ansible | 1 plays in all.yaml
2022-12-29 23:56:53,645 p=83673 u=kal n=ansible | PLAY [localhost] *************************************************************************************************************************************
2022-12-29 23:56:53,652 p=83673 u=kal n=ansible | TASK [Gathering Facts] *******************************************************************************************************************************
2022-12-29 23:56:57,641 p=83673 u=kal n=ansible | ok: [krpz]
2022-12-29 23:56:57,668 p=83673 u=kal n=ansible | TASK [install pexpect] *******************************************************************************************************************************
2022-12-29 23:56:57,850 p=83673 u=kal n=ansible | An exception occurred during task execution. To see the full traceback, use -vvv. The error was: ImportError: No module named pkg_resources
2022-12-29 23:56:57,850 p=83673 u=kal n=ansible | fatal: [krpz]: FAILED! => {"changed": false, "msg": "Failed to import the required Python library (setuptools) on KRPZ's Python /usr/bin/python2. Please read the module documentation and install it in the appropriate location. If the required library is installed, but Ansible is using the wrong Python interpreter, please consult the documentation on ansible_python_interpreter"}
2022-12-29 23:56:57,851 p=83673 u=kal n=ansible | PLAY RECAP *******************************************************************************************************************************************
2022-12-29 23:56:57,851 p=83673 u=kal n=ansible | krpz                       : ok=1    changed=0    unreachable=0    failed=1    skipped=0    rescued=0    ignored=0   
2022-12-29 23:58:34,206 p=86185 u=kal n=ansible | ansible-playbook [core 2.14.1]
  config file = /home/kal/MyApplications/dotfiles/playbooks/ansible.cfg
  configured module search path = ['/home/kal/.ansible/plugins/modules', '/usr/share/ansible/plugins/modules']
  ansible python module location = /home/kal/.local/lib/python3.10/site-packages/ansible
  ansible collection location = /home/kal/.ansible/collections:/usr/share/ansible/collections
  executable location = /home/kal/.local/bin/ansible-playbook
  python version = 3.10.6 (main, Nov 14 2022, 16:10:14) [GCC 11.3.0] (/usr/bin/python3)
  jinja version = 3.1.2
  libyaml = True
2022-12-29 23:58:34,206 p=86185 u=kal n=ansible | Using /home/kal/MyApplications/dotfiles/playbooks/ansible.cfg as config file
2022-12-29 23:58:34,278 p=86185 u=kal n=ansible | Skipping callback 'default', as we already have a stdout callback.
2022-12-29 23:58:34,278 p=86185 u=kal n=ansible | Skipping callback 'minimal', as we already have a stdout callback.
2022-12-29 23:58:34,278 p=86185 u=kal n=ansible | Skipping callback 'oneline', as we already have a stdout callback.
2022-12-29 23:58:34,278 p=86185 u=kal n=ansible | PLAYBOOK: all.yaml ***********************************************************************************************************************************
2022-12-29 23:58:34,278 p=86185 u=kal n=ansible | 1 plays in all.yaml
2022-12-29 23:58:34,279 p=86185 u=kal n=ansible | PLAY [localhost] *************************************************************************************************************************************
2022-12-29 23:58:34,286 p=86185 u=kal n=ansible | TASK [Gathering Facts] *******************************************************************************************************************************
2022-12-29 23:58:38,348 p=86185 u=kal n=ansible | ok: [krpz]
2022-12-29 23:58:38,370 p=86185 u=kal n=ansible | TASK [install pexpect] *******************************************************************************************************************************
2022-12-29 23:58:38,587 p=86185 u=kal n=ansible | fatal: [krpz]: FAILED! => {"changed": false, "msg": "Unable to find any of pip2, pip to use.  pip needs to be installed."}
2022-12-29 23:58:38,588 p=86185 u=kal n=ansible | PLAY RECAP *******************************************************************************************************************************************
2022-12-29 23:58:38,588 p=86185 u=kal n=ansible | krpz                       : ok=1    changed=0    unreachable=0    failed=1    skipped=0    rescued=0    ignored=0   
2022-12-30 00:00:30,958 p=87051 u=kal n=ansible | ansible-playbook [core 2.14.1]
  config file = /home/kal/MyApplications/dotfiles/playbooks/ansible.cfg
  configured module search path = ['/home/kal/.ansible/plugins/modules', '/usr/share/ansible/plugins/modules']
  ansible python module location = /home/kal/.local/lib/python3.10/site-packages/ansible
  ansible collection location = /home/kal/.ansible/collections:/usr/share/ansible/collections
  executable location = /home/kal/.local/bin/ansible-playbook
  python version = 3.10.6 (main, Nov 14 2022, 16:10:14) [GCC 11.3.0] (/usr/bin/python3)
  jinja version = 3.1.2
  libyaml = True
2022-12-30 00:00:30,958 p=87051 u=kal n=ansible | Using /home/kal/MyApplications/dotfiles/playbooks/ansible.cfg as config file
2022-12-30 00:00:31,027 p=87051 u=kal n=ansible | Skipping callback 'default', as we already have a stdout callback.
2022-12-30 00:00:31,027 p=87051 u=kal n=ansible | Skipping callback 'minimal', as we already have a stdout callback.
2022-12-30 00:00:31,028 p=87051 u=kal n=ansible | Skipping callback 'oneline', as we already have a stdout callback.
2022-12-30 00:00:31,028 p=87051 u=kal n=ansible | PLAYBOOK: all.yaml ***********************************************************************************************************************************
2022-12-30 00:00:31,028 p=87051 u=kal n=ansible | 1 plays in all.yaml
2022-12-30 00:00:31,029 p=87051 u=kal n=ansible | PLAY [localhost] *************************************************************************************************************************************
2022-12-30 00:00:31,035 p=87051 u=kal n=ansible | TASK [Gathering Facts] *******************************************************************************************************************************
2022-12-30 00:00:34,960 p=87051 u=kal n=ansible | ok: [krpz]
2022-12-30 00:00:34,984 p=87051 u=kal n=ansible | TASK [install pexpect] *******************************************************************************************************************************
2022-12-30 00:00:36,474 p=87051 u=kal n=ansible | changed: [krpz] => {"changed": true, "cmd": ["/usr/bin/python2", "-m", "pip.__main__", "install", "pexpect"], "name": ["pexpect"], "requirements": null, "state": "present", "stderr": "DEPRECATION: Python 2.7 reached the end of its life on January 1st, 2020. Please upgrade your Python as Python 2.7 is no longer maintained. pip 21.0 will drop support for Python 2.7 in January 2021. More details about Python 2 support in pip can be found at https://pip.pypa.io/en/latest/development/release-process/#python-2-support pip 21.0 will remove support for this functionality.\n", "stderr_lines": ["DEPRECATION: Python 2.7 reached the end of its life on January 1st, 2020. Please upgrade your Python as Python 2.7 is no longer maintained. pip 21.0 will drop support for Python 2.7 in January 2021. More details about Python 2 support in pip can be found at https://pip.pypa.io/en/latest/development/release-process/#python-2-support pip 21.0 will remove support for this functionality."], "stdout": "Collecting pexpect\n  Downloading pexpect-4.8.0-py2.py3-none-any.whl (59 kB)\nCollecting ptyprocess>=0.5\n  Downloading ptyprocess-0.7.0-py2.py3-none-any.whl (13 kB)\nInstalling collected packages: ptyprocess, pexpect\nSuccessfully installed pexpect-4.8.0 ptyprocess-0.7.0\n", "stdout_lines": ["Collecting pexpect", "  Downloading pexpect-4.8.0-py2.py3-none-any.whl (59 kB)", "Collecting ptyprocess>=0.5", "  Downloading ptyprocess-0.7.0-py2.py3-none-any.whl (13 kB)", "Installing collected packages: ptyprocess, pexpect", "Successfully installed pexpect-4.8.0 ptyprocess-0.7.0"], "version": null, "virtualenv": null}
2022-12-30 00:00:36,482 p=87051 u=kal n=ansible | TASK [install setuptools] ****************************************************************************************************************************
2022-12-30 00:00:36,823 p=87051 u=kal n=ansible | ok: [krpz] => {"changed": false, "cmd": ["/usr/bin/python2", "-m", "pip.__main__", "install", "setuptools"], "name": ["setuptools"], "requirements": null, "state": "present", "stderr": "DEPRECATION: Python 2.7 reached the end of its life on January 1st, 2020. Please upgrade your Python as Python 2.7 is no longer maintained. pip 21.0 will drop support for Python 2.7 in January 2021. More details about Python 2 support in pip can be found at https://pip.pypa.io/en/latest/development/release-process/#python-2-support pip 21.0 will remove support for this functionality.\n", "stderr_lines": ["DEPRECATION: Python 2.7 reached the end of its life on January 1st, 2020. Please upgrade your Python as Python 2.7 is no longer maintained. pip 21.0 will drop support for Python 2.7 in January 2021. More details about Python 2 support in pip can be found at https://pip.pypa.io/en/latest/development/release-process/#python-2-support pip 21.0 will remove support for this functionality."], "stdout": "Requirement already satisfied: setuptools in /usr/lib/python2.7/dist-packages (44.1.1)\n", "stdout_lines": ["Requirement already satisfied: setuptools in /usr/lib/python2.7/dist-packages (44.1.1)"], "version": null, "virtualenv": null}
2022-12-30 00:00:36,831 p=87051 u=kal n=ansible | TASK [Install Rust] **********************************************************************************************************************************
2022-12-30 00:00:39,189 p=87051 u=kal n=ansible | fatal: [krpz]: FAILED! => {"changed": true, "cmd": "curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh", "delta": "0:00:02.166175", "end": "2022-12-30 00:00:39.161031", "msg": "non-zero return code", "rc": 1, "start": "2022-12-30 00:00:36.994856", "stdout": "#!/bin/sh\r\n# shellcheck shell=dash\r\n\r\n# This is just a little script that can be downloaded from the internet to\r\n# install rustup. It just does platform detection, downloads the installer\r\n# and runs it.\r\n\r\n# It runs on Unix shells like {a,ba,da,k,z}sh. It uses the common `local`\r\n# extension. Note: Most shells limit `local` to 1 var per line, contra bash.\r\n\r\nif [ \"$KSH_VERSION\" = 'Version JM 93t+ 2010-03-05' ]; then\r\n    # The version of ksh93 that ships with many illumos systems does not\r\n    # support the \"local\" extension.  Print a message rather than fail in\r\n    # subtle ways later on:\r\n    echo 'rustup does not work with this ksh93 version; please try bash!' >&2\r\n    exit 1\r\nfi\r\n\r\n\r\nset -u\r\n\r\n# If RUSTUP_UPDATE_ROOT is unset or empty, default it.\r\nRUSTUP_UPDATE_ROOT=\"${RUSTUP_UPDATE_ROOT:-https://static.rust-lang.org/rustup}\"\r\n\r\n#XXX: If you change anything here, please make the same changes in setup_mode.rs\r\nusage() {\r\n    cat 1>&2 <<EOF\r\nrustup-init 1.25.1 (48d233f65 2022-07-12)\r\nThe installer for rustup\r\n\r\nUSAGE:\r\n    rustup-init [FLAGS] [OPTIONS]\r\n\r\nFLAGS:\r\n    -v, --verbose           Enable verbose output\r\n    -q, --quiet             Disable progress output\r\n    -y                      Disable confirmation prompt.\r\n        --no-modify-path    Don't configure the PATH environment variable\r\n    -h, --help              Prints help information\r\n    -V, --version           Prints version information\r\n\r\nOPTIONS:\r\n        --default-host <default-host>              Choose a default host triple\r\n        --default-toolchain <default-toolchain>    Choose a default toolchain to install\r\n        --default-toolchain none                   Do not install any toolchains\r\n        --profile [minimal|default|complete]       Choose a profile\r\n    -c, --component <components>...                Component name to also install\r\n    -t, --target <targets>...                      Target name to also install\r\nEOF\r\n}\r\n\r\nmain() {\r\n    downloader --check\r\n    need_cmd uname\r\n    need_cmd mktemp\r\n    need_cmd chmod\r\n    need_cmd mkdir\r\n    need_cmd rm\r\n    need_cmd rmdir\r\n\r\n    get_architecture || return 1\r\n    local _arch=\"$RETVAL\"\r\n    assert_nz \"$_arch\" \"arch\"\r\n\r\n    local _ext=\"\"\r\n    case \"$_arch\" in\r\n        *windows*)\r\n            _ext=\".exe\"\r\n            ;;\r\n    esac\r\n\r\n    local _url=\"${RUSTUP_UPDATE_ROOT}/dist/${_arch}/rustup-init${_ext}\"\r\n\r\n    local _dir\r\n    _dir=\"$(ensure mktemp -d)\"\r\n    local _file=\"${_dir}/rustup-init${_ext}\"\r\n\r\n    local _ansi_escapes_are_valid=false\r\n    if [ -t 2 ]; then\r\n        if [ \"${TERM+set}\" = 'set' ]; then\r\n            case \"$TERM\" in\r\n                xterm*|rxvt*|urxvt*|linux*|vt*)\r\n                    _ansi_escapes_are_valid=true\r\n                ;;\r\n            esac\r\n        fi\r\n    fi\r\n\r\n    # check if we have to use /dev/tty to prompt the user\r\n    local need_tty=yes\r\n    for arg in \"$@\"; do\r\n        case \"$arg\" in\r\n            --help)\r\n                usage\r\n                exit 0\r\n                ;;\r\n            *)\r\n                OPTIND=1\r\n                if [ \"${arg%%--*}\" = \"\" ]; then\r\n                    # Long option (other than --help);\r\n                    # don't attempt to interpret it.\r\n                    continue\r\n                fi\r\n                while getopts :hy sub_arg \"$arg\"; do\r\n                    case \"$sub_arg\" in\r\n                        h)\r\n                            usage\r\n                            exit 0\r\n                            ;;\r\n                        y)\r\n                            # user wants to skip the prompt --\r\n                            # we don't need /dev/tty\r\n                            need_tty=no\r\n                            ;;\r\n                        *)\r\n                            ;;\r\n                        esac\r\n                done\r\n                ;;\r\n        esac\r\n    done\r\n\r\n    if $_ansi_escapes_are_valid; then\r\n        printf \"\\33[1minfo:\\33[0m downloading installer\\n\" 1>&2\r\n    else\r\n        printf '%s\\n' 'info: downloading installer' 1>&2\r\n    fi\r\n\r\n    ensure mkdir -p \"$_dir\"\r\n    ensure downloader \"$_url\" \"$_file\" \"$_arch\"\r\n    ensure chmod u+x \"$_file\"\r\n    if [ ! -x \"$_file\" ]; then\r\n        printf '%s\\n' \"Cannot execute $_file (likely because of mounting /tmp as noexec).\" 1>&2\r\n        printf '%s\\n' \"Please copy the file to a location where you can execute binaries and run ./rustup-init${_ext}.\" 1>&2\r\n        exit 1\r\n    fi\r\n\r\n    if [ \"$need_tty\" = \"yes\" ] && [ ! -t 0 ]; then\r\n        # The installer is going to want to ask for confirmation by\r\n        # reading stdin.  This script was piped into `sh` though and\r\n        # doesn't have stdin to pass to its children. Instead we're going\r\n        # to explicitly connect /dev/tty to the installer's stdin.\r\n        if [ ! -t 1 ]; then\r\n            err \"Unable to run interactively. Run with -y to accept defaults, --help for additional options\"\r\n        fi\r\n\r\n        ignore \"$_file\" \"$@\" < /dev/tty\r\n    else\r\n        ignore \"$_file\" \"$@\"\r\n    fi\r\n\r\n    local _retval=$?\r\n\r\n    ignore rm \"$_file\"\r\n    ignore rmdir \"$_dir\"\r\n\r\n    return \"$_retval\"\r\n}\r\n\r\ncheck_proc() {\r\n    # Check for /proc by looking for the /proc/self/exe link\r\n    # This is only run on Linux\r\n    if ! test -L /proc/self/exe ; then\r\n        err \"fatal: Unable to find /proc/self/exe.  Is /proc mounted?  Installation cannot proceed without /proc.\"\r\n    fi\r\n}\r\n\r\nget_bitness() {\r\n    need_cmd head\r\n    # Architecture detection without dependencies beyond coreutils.\r\n    # ELF files start out \"\\x7fELF\", and the following byte is\r\n    #   0x01 for 32-bit and\r\n    #   0x02 for 64-bit.\r\n    # The printf builtin on some shells like dash only supports octal\r\n    # escape sequences, so we use those.\r\n    local _current_exe_head\r\n    _current_exe_head=$(head -c 5 /proc/self/exe )\r\n    if [ \"$_current_exe_head\" = \"$(printf '\\177ELF\\001')\" ]; then\r\n        echo 32\r\n    elif [ \"$_current_exe_head\" = \"$(printf '\\177ELF\\002')\" ]; then\r\n        echo 64\r\n    else\r\n        err \"unknown platform bitness\"\r\n    fi\r\n}\r\n\r\nis_host_amd64_elf() {\r\n    need_cmd head\r\n    need_cmd tail\r\n    # ELF e_machine detection without dependencies beyond coreutils.\r\n    # Two-byte field at offset 0x12 indicates the CPU,\r\n    # but we're interested in it being 0x3E to indicate amd64, or not that.\r\n    local _current_exe_machine\r\n    _current_exe_machine=$(head -c 19 /proc/self/exe | tail -c 1)\r\n    [ \"$_current_exe_machine\" = \"$(printf '\\076')\" ]\r\n}\r\n\r\nget_endianness() {\r\n    local cputype=$1\r\n    local suffix_eb=$2\r\n    local suffix_el=$3\r\n\r\n    # detect endianness without od/hexdump, like get_bitness() does.\r\n    need_cmd head\r\n    need_cmd tail\r\n\r\n    local _current_exe_endianness\r\n    _current_exe_endianness=\"$(head -c 6 /proc/self/exe | tail -c 1)\"\r\n    if [ \"$_current_exe_endianness\" = \"$(printf '\\001')\" ]; then\r\n        echo \"${cputype}${suffix_el}\"\r\n    elif [ \"$_current_exe_endianness\" = \"$(printf '\\002')\" ]; then\r\n        echo \"${cputype}${suffix_eb}\"\r\n    else\r\n        err \"unknown platform endianness\"\r\n    fi\r\n}\r\n\r\nget_architecture() {\r\n    local _ostype _cputype _bitness _arch _clibtype\r\n    _ostype=\"$(uname -s)\"\r\n    _cputype=\"$(uname -m)\"\r\n    _clibtype=\"gnu\"\r\n\r\n    if [ \"$_ostype\" = Linux ]; then\r\n        if [ \"$(uname -o)\" = Android ]; then\r\n            _ostype=Android\r\n        fi\r\n        if ldd --version 2>&1 | grep -q 'musl'; then\r\n            _clibtype=\"musl\"\r\n        fi\r\n    fi\r\n\r\n    if [ \"$_ostype\" = Darwin ] && [ \"$_cputype\" = i386 ]; then\r\n        # Darwin `uname -m` lies\r\n        if sysctl hw.optional.x86_64 | grep -q ': 1'; then\r\n            _cputype=x86_64\r\n        fi\r\n    fi\r\n\r\n    if [ \"$_ostype\" = SunOS ]; then\r\n        # Both Solaris and illumos presently announce as \"SunOS\" in \"uname -s\"\r\n        # so use \"uname -o\" to disambiguate.  We use the full path to the\r\n        # system uname in case the user has coreutils uname first in PATH,\r\n        # which has historically sometimes printed the wrong value here.\r\n        if [ \"$(/usr/bin/uname -o)\" = illumos ]; then\r\n            _ostype=illumos\r\n        fi\r\n\r\n        # illumos systems have multi-arch userlands, and \"uname -m\" reports the\r\n        # machine hardware name; e.g., \"i86pc\" on both 32- and 64-bit x86\r\n        # systems.  Check for the native (widest) instruction set on the\r\n        # running kernel:\r\n        if [ \"$_cputype\" = i86pc ]; then\r\n            _cputype=\"$(isainfo -n)\"\r\n        fi\r\n    fi\r\n\r\n    case \"$_ostype\" in\r\n\r\n        Android)\r\n            _ostype=linux-android\r\n            ;;\r\n\r\n        Linux)\r\n            check_proc\r\n            _ostype=unknown-linux-$_clibtype\r\n            _bitness=$(get_bitness)\r\n            ;;\r\n\r\n        FreeBSD)\r\n            _ostype=unknown-freebsd\r\n            ;;\r\n\r\n        NetBSD)\r\n            _ostype=unknown-netbsd\r\n            ;;\r\n\r\n        DragonFly)\r\n            _ostype=unknown-dragonfly\r\n            ;;\r\n\r\n        Darwin)\r\n            _ostype=apple-darwin\r\n            ;;\r\n\r\n        illumos)\r\n            _ostype=unknown-illumos\r\n            ;;\r\n\r\n        MINGW* | MSYS* | CYGWIN* | Windows_NT)\r\n            _ostype=pc-windows-gnu\r\n            ;;\r\n\r\n        *)\r\n            err \"unrecognized OS type: $_ostype\"\r\n            ;;\r\n\r\n    esac\r\n\r\n    case \"$_cputype\" in\r\n\r\n        i386 | i486 | i686 | i786 | x86)\r\n            _cputype=i686\r\n            ;;\r\n\r\n        xscale | arm)\r\n            _cputype=arm\r\n            if [ \"$_ostype\" = \"linux-android\" ]; then\r\n                _ostype=linux-androideabi\r\n            fi\r\n            ;;\r\n\r\n        armv6l)\r\n            _cputype=arm\r\n            if [ \"$_ostype\" = \"linux-android\" ]; then\r\n                _ostype=linux-androideabi\r\n            else\r\n                _ostype=\"${_ostype}eabihf\"\r\n            fi\r\n            ;;\r\n\r\n        armv7l | armv8l)\r\n            _cputype=armv7\r\n            if [ \"$_ostype\" = \"linux-android\" ]; then\r\n                _ostype=linux-androideabi\r\n            else\r\n                _ostype=\"${_ostype}eabihf\"\r\n            fi\r\n            ;;\r\n\r\n        aarch64 | arm64)\r\n            _cputype=aarch64\r\n            ;;\r\n\r\n        x86_64 | x86-64 | x64 | amd64)\r\n            _cputype=x86_64\r\n            ;;\r\n\r\n        mips)\r\n            _cputype=$(get_endianness mips '' el)\r\n            ;;\r\n\r\n        mips64)\r\n            if [ \"$_bitness\" -eq 64 ]; then\r\n                # only n64 ABI is supported for now\r\n                _ostype=\"${_ostype}abi64\"\r\n                _cputype=$(get_endianness mips64 '' el)\r\n            fi\r\n            ;;\r\n\r\n        ppc)\r\n            _cputype=powerpc\r\n            ;;\r\n\r\n        ppc64)\r\n            _cputype=powerpc64\r\n            ;;\r\n\r\n        ppc64le)\r\n            _cputype=powerpc64le\r\n            ;;\r\n\r\n        s390x)\r\n            _cputype=s390x\r\n            ;;\r\n        riscv64)\r\n            _cputype=riscv64gc\r\n            ;;\r\n        *)\r\n            err \"unknown CPU type: $_cputype\"\r\n\r\n    esac\r\n\r\n    # Detect 64-bit linux with 32-bit userland\r\n    if [ \"${_ostype}\" = unknown-linux-gnu ] && [ \"${_bitness}\" -eq 32 ]; then\r\n        case $_cputype in\r\n            x86_64)\r\n                if [ -n \"${RUSTUP_CPUTYPE:-}\" ]; then\r\n                    _cputype=\"$RUSTUP_CPUTYPE\"\r\n                else {\r\n                    # 32-bit executable for amd64 = x32\r\n                    if is_host_amd64_elf; then {\r\n                         echo \"This host is running an x32 userland; as it stands, x32 support is poor,\" 1>&2\r\n                         echo \"and there isn't a native toolchain -- you will have to install\" 1>&2\r\n                         echo \"multiarch compatibility with i686 and/or amd64, then select one\" 1>&2\r\n                         echo \"by re-running this script with the RUSTUP_CPUTYPE environment variable\" 1>&2\r\n                         echo \"set to i686 or x86_64, respectively.\" 1>&2\r\n                         echo 1>&2\r\n                         echo \"You will be able to add an x32 target after installation by running\" 1>&2\r\n                         echo \"  rustup target add x86_64-unknown-linux-gnux32\" 1>&2\r\n                         exit 1\r\n                    }; else\r\n                        _cputype=i686\r\n                    fi\r\n                }; fi\r\n                ;;\r\n            mips64)\r\n                _cputype=$(get_endianness mips '' el)\r\n                ;;\r\n            powerpc64)\r\n                _cputype=powerpc\r\n                ;;\r\n            aarch64)\r\n                _cputype=armv7\r\n                if [ \"$_ostype\" = \"linux-android\" ]; then\r\n                    _ostype=linux-androideabi\r\n                else\r\n                    _ostype=\"${_ostype}eabihf\"\r\n                fi\r\n                ;;\r\n            riscv64gc)\r\n                err \"riscv64 with 32-bit userland unsupported\"\r\n                ;;\r\n        esac\r\n    fi\r\n\r\n    # Detect armv7 but without the CPU features Rust needs in that build,\r\n    # and fall back to arm.\r\n    # See https://github.com/rust-lang/rustup.rs/issues/587.\r\n    if [ \"$_ostype\" = \"unknown-linux-gnueabihf\" ] && [ \"$_cputype\" = armv7 ]; then\r\n        if ensure grep '^Features' /proc/cpuinfo | grep -q -v neon; then\r\n            # At least one processor does not have NEON.\r\n            _cputype=arm\r\n        fi\r\n    fi\r\n\r\n    _arch=\"${_cputype}-${_ostype}\"\r\n\r\n    RETVAL=\"$_arch\"\r\n}\r\n\r\nsay() {\r\n    printf 'rustup: %s\\n' \"$1\"\r\n}\r\n\r\nerr() {\r\n    say \"$1\" >&2\r\n    exit 1\r\n}\r\n\r\nneed_cmd() {\r\n    if ! check_cmd \"$1\"; then\r\n        err \"need '$1' (command not found)\"\r\n    fi\r\n}\r\n\r\ncheck_cmd() {\r\n    command -v \"$1\" > /dev/null 2>&1\r\n}\r\n\r\nassert_nz() {\r\n    if [ -z \"$1\" ]; then err \"assert_nz $2\"; fi\r\n}\r\n\r\n# Run a command that should never fail. If the command fails execution\r\n# will immediately terminate with an error showing the failing\r\n# command.\r\nensure() {\r\n    if ! \"$@\"; then err \"command failed: $*\"; fi\r\n}\r\n\r\n# This is just for indicating that commands' results are being\r\n# intentionally ignored. Usually, because it's being executed\r\n# as part of error handling.\r\nignore() {\r\n    \"$@\"\r\n}\r\n\r\n# This wraps curl or wget. Try curl first, if not installed,\r\n# use wget instead.\r\ndownloader() {\r\n    local _dld\r\n    local _ciphersuites\r\n    local _err\r\n    local _status\r\n    local _retry\r\n    if check_cmd curl; then\r\n        _dld=curl\r\n    elif check_cmd wget; then\r\n        _dld=wget\r\n    else\r\n        _dld='curl or wget' # to be used in error message of need_cmd\r\n    fi\r\n\r\n    if [ \"$1\" = --check ]; then\r\n        need_cmd \"$_dld\"\r\n    elif [ \"$_dld\" = curl ]; then\r\n        check_curl_for_retry_support\r\n        _retry=\"$RETVAL\"\r\n        get_ciphersuites_for_curl\r\n        _ciphersuites=\"$RETVAL\"\r\n        if [ -n \"$_ciphersuites\" ]; then\r\n            _err=$(curl $_retry --proto '=https' --tlsv1.2 --ciphers \"$_ciphersuites\" --silent --show-error --fail --location \"$1\" --output \"$2\" 2>&1)\r\n            _status=$?\r\n        else\r\n            echo \"Warning: Not enforcing strong cipher suites for TLS, this is potentially less secure\"\r\n            if ! check_help_for \"$3\" curl --proto --tlsv1.2; then\r\n                echo \"Warning: Not enforcing TLS v1.2, this is potentially less secure\"\r\n                _err=$(curl $_retry --silent --show-error --fail --location \"$1\" --output \"$2\" 2>&1)\r\n                _status=$?\r\n            else\r\n                _err=$(curl $_retry --proto '=https' --tlsv1.2 --silent --show-error --fail --location \"$1\" --output \"$2\" 2>&1)\r\n                _status=$?\r\n            fi\r\n        fi\r\n        if [ -n \"$_err\" ]; then\r\n            echo \"$_err\" >&2\r\n            if echo \"$_err\" | grep -q 404$; then\r\n                err \"installer for platform '$3' not found, this may be unsupported\"\r\n            fi\r\n        fi\r\n        return $_status\r\n    elif [ \"$_dld\" = wget ]; then\r\n        if [ \"$(wget -V 2>&1|head -2|tail -1|cut -f1 -d\" \")\" = \"BusyBox\" ]; then\r\n            echo \"Warning: using the BusyBox version of wget.  Not enforcing strong cipher suites for TLS or TLS v1.2, this is potentially less secure\"\r\n            _err=$(wget \"$1\" -O \"$2\" 2>&1)\r\n            _status=$?\r\n        else\r\n            get_ciphersuites_for_wget\r\n            _ciphersuites=\"$RETVAL\"\r\n            if [ -n \"$_ciphersuites\" ]; then\r\n                _err=$(wget --https-only --secure-protocol=TLSv1_2 --ciphers \"$_ciphersuites\" \"$1\" -O \"$2\" 2>&1)\r\n                _status=$?\r\n            else\r\n                echo \"Warning: Not enforcing strong cipher suites for TLS, this is potentially less secure\"\r\n                if ! check_help_for \"$3\" wget --https-only --secure-protocol; then\r\n                    echo \"Warning: Not enforcing TLS v1.2, this is potentially less secure\"\r\n                    _err=$(wget \"$1\" -O \"$2\" 2>&1)\r\n                    _status=$?\r\n                else\r\n                    _err=$(wget --https-only --secure-protocol=TLSv1_2 \"$1\" -O \"$2\" 2>&1)\r\n                    _status=$?\r\n                fi\r\n            fi\r\n        fi\r\n        if [ -n \"$_err\" ]; then\r\n            echo \"$_err\" >&2\r\n            if echo \"$_err\" | grep -q ' 404 Not Found$'; then\r\n                err \"installer for platform '$3' not found, this may be unsupported\"\r\n            fi\r\n        fi\r\n        return $_status\r\n    else\r\n        err \"Unknown downloader\"   # should not reach here\r\n    fi\r\n}\r\n\r\ncheck_help_for() {\r\n    local _arch\r\n    local _cmd\r\n    local _arg\r\n    _arch=\"$1\"\r\n    shift\r\n    _cmd=\"$1\"\r\n    shift\r\n\r\n    local _category\r\n    if \"$_cmd\" --help | grep -q 'For all options use the manual or \"--help all\".'; then\r\n      _category=\"all\"\r\n    else\r\n      _category=\"\"\r\n    fi\r\n\r\n    case \"$_arch\" in\r\n\r\n        *darwin*)\r\n        if check_cmd sw_vers; then\r\n            case $(sw_vers -productVersion) in\r\n                10.*)\r\n                    # If we're running on macOS, older than 10.13, then we always\r\n                    # fail to find these options to force fallback\r\n                    if [ \"$(sw_vers -productVersion | cut -d. -f2)\" -lt 13 ]; then\r\n                        # Older than 10.13\r\n                        echo \"Warning: Detected macOS platform older than 10.13\"\r\n                        return 1\r\n                    fi\r\n                    ;;\r\n                11.*)\r\n                    # We assume Big Sur will be OK for now\r\n                    ;;\r\n                *)\r\n                    # Unknown product version, warn and continue\r\n                    echo \"Warning: Detected unknown macOS major version: $(sw_vers -productVersion)\"\r\n                    echo \"Warning TLS capabilities detection may fail\"\r\n                    ;;\r\n            esac\r\n        fi\r\n        ;;\r\n\r\n    esac\r\n\r\n    for _arg in \"$@\"; do\r\n        if ! \"$_cmd\" --help $_category | grep -q -- \"$_arg\"; then\r\n            return 1\r\n        fi\r\n    done\r\n\r\n    true # not strictly needed\r\n}\r\n\r\n# Check if curl supports the --retry flag, then pass it to the curl invocation.\r\ncheck_curl_for_retry_support() {\r\n  local _retry_supported=\"\"\r\n  # \"unspecified\" is for arch, allows for possibility old OS using macports, homebrew, etc.\r\n  if check_help_for \"notspecified\" \"curl\" \"--retry\"; then\r\n    _retry_supported=\"--retry 3\"\r\n  fi\r\n\r\n  RETVAL=\"$_retry_supported\"\r\n\r\n}\r\n\r\n# Return cipher suite string specified by user, otherwise return strong TLS 1.2-1.3 cipher suites\r\n# if support by local tools is detected. Detection currently supports these curl backends:\r\n# GnuTLS and OpenSSL (possibly also LibreSSL and BoringSSL). Return value can be empty.\r\nget_ciphersuites_for_curl() {\r\n    if [ -n \"${RUSTUP_TLS_CIPHERSUITES-}\" ]; then\r\n        # user specified custom cipher suites, assume they know what they're doing\r\n        RETVAL=\"$RUSTUP_TLS_CIPHERSUITES\"\r\n        return\r\n    fi\r\n\r\n    local _openssl_syntax=\"no\"\r\n    local _gnutls_syntax=\"no\"\r\n    local _backend_supported=\"yes\"\r\n    if curl -V | grep -q ' OpenSSL/'; then\r\n        _openssl_syntax=\"yes\"\r\n    elif curl -V | grep -iq ' LibreSSL/'; then\r\n        _openssl_syntax=\"yes\"\r\n    elif curl -V | grep -iq ' BoringSSL/'; then\r\n        _openssl_syntax=\"yes\"\r\n    elif curl -V | grep -iq ' GnuTLS/'; then\r\n        _gnutls_syntax=\"yes\"\r\n    else\r\n        _backend_supported=\"no\"\r\n    fi\r\n\r\n    local _args_supported=\"no\"\r\n    if [ \"$_backend_supported\" = \"yes\" ]; then\r\n        # \"unspecified\" is for arch, allows for possibility old OS using macports, homebrew, etc.\r\n        if check_help_for \"notspecified\" \"curl\" \"--tlsv1.2\" \"--ciphers\" \"--proto\"; then\r\n            _args_supported=\"yes\"\r\n        fi\r\n    fi\r\n\r\n    local _cs=\"\"\r\n    if [ \"$_args_supported\" = \"yes\" ]; then\r\n        if [ \"$_openssl_syntax\" = \"yes\" ]; then\r\n            _cs=$(get_strong_ciphersuites_for \"openssl\")\r\n        elif [ \"$_gnutls_syntax\" = \"yes\" ]; then\r\n            _cs=$(get_strong_ciphersuites_for \"gnutls\")\r\n        fi\r\n    fi\r\n\r\n    RETVAL=\"$_cs\"\r\n}\r\n\r\n# Return cipher suite string specified by user, otherwise return strong TLS 1.2-1.3 cipher suites\r\n# if support by local tools is detected. Detection currently supports these wget backends:\r\n# GnuTLS and OpenSSL (possibly also LibreSSL and BoringSSL). Return value can be empty.\r\nget_ciphersuites_for_wget() {\r\n    if [ -n \"${RUSTUP_TLS_CIPHERSUITES-}\" ]; then\r\n        # user specified custom cipher suites, assume they know what they're doing\r\n        RETVAL=\"$RUSTUP_TLS_CIPHERSUITES\"\r\n        return\r\n    fi\r\n\r\n    local _cs=\"\"\r\n    if wget -V | grep -q '\\-DHAVE_LIBSSL'; then\r\n        # \"unspecified\" is for arch, allows for possibility old OS using macports, homebrew, etc.\r\n        if check_help_for \"notspecified\" \"wget\" \"TLSv1_2\" \"--ciphers\" \"--https-only\" \"--secure-protocol\"; then\r\n            _cs=$(get_strong_ciphersuites_for \"openssl\")\r\n        fi\r\n    elif wget -V | grep -q '\\-DHAVE_LIBGNUTLS'; then\r\n        # \"unspecified\" is for arch, allows for possibility old OS using macports, homebrew, etc.\r\n        if check_help_for \"notspecified\" \"wget\" \"TLSv1_2\" \"--ciphers\" \"--https-only\" \"--secure-protocol\"; then\r\n            _cs=$(get_strong_ciphersuites_for \"gnutls\")\r\n        fi\r\n    fi\r\n\r\n    RETVAL=\"$_cs\"\r\n}\r\n\r\n# Return strong TLS 1.2-1.3 cipher suites in OpenSSL or GnuTLS syntax. TLS 1.2\r\n# excludes non-ECDHE and non-AEAD cipher suites. DHE is excluded due to bad\r\n# DH params often found on servers (see RFC 7919). Sequence matches or is\r\n# similar to Firefox 68 ESR with weak cipher suites disabled via about:config.\r\n# $1 must be openssl or gnutls.\r\nget_strong_ciphersuites_for() {\r\n    if [ \"$1\" = \"openssl\" ]; then\r\n        # OpenSSL is forgiving of unknown values, no problems with TLS 1.3 values on versions that don't support it yet.\r\n        echo \"TLS_AES_128_GCM_SHA256:TLS_CHACHA20_POLY1305_SHA256:TLS_AES_256_GCM_SHA384:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384\"\r\n    elif [ \"$1\" = \"gnutls\" ]; then\r\n        # GnuTLS isn't forgiving of unknown values, so this may require a GnuTLS version that supports TLS 1.3 even if wget doesn't.\r\n        # Begin with SECURE128 (and higher) then remove/add to build cipher suites. Produces same 9 cipher suites as OpenSSL but in slightly different order.\r\n        echo \"SECURE128:-VERS-SSL3.0:-VERS-TLS1.0:-VERS-TLS1.1:-VERS-DTLS-ALL:-CIPHER-ALL:-MAC-ALL:-KX-ALL:+AEAD:+ECDHE-ECDSA:+ECDHE-RSA:+AES-128-GCM:+CHACHA20-POLY1305:+AES-256-GCM\"\r\n    fi\r\n}\r\n\r\nmain \"$@\" || exit 1\r\ncurl: (1) Protocol \"http\" not supported or disabled in libcurl\r\ncurl: (1) Protocol \"http\" not supported or disabled in libcurl", "stdout_lines": ["#!/bin/sh", "# shellcheck shell=dash", "", "# This is just a little script that can be downloaded from the internet to", "# install rustup. It just does platform detection, downloads the installer", "# and runs it.", "", "# It runs on Unix shells like {a,ba,da,k,z}sh. It uses the common `local`", "# extension. Note: Most shells limit `local` to 1 var per line, contra bash.", "", "if [ \"$KSH_VERSION\" = 'Version JM 93t+ 2010-03-05' ]; then", "    # The version of ksh93 that ships with many illumos systems does not", "    # support the \"local\" extension.  Print a message rather than fail in", "    # subtle ways later on:", "    echo 'rustup does not work with this ksh93 version; please try bash!' >&2", "    exit 1", "fi", "", "", "set -u", "", "# If RUSTUP_UPDATE_ROOT is unset or empty, default it.", "RUSTUP_UPDATE_ROOT=\"${RUSTUP_UPDATE_ROOT:-https://static.rust-lang.org/rustup}\"", "", "#XXX: If you change anything here, please make the same changes in setup_mode.rs", "usage() {", "    cat 1>&2 <<EOF", "rustup-init 1.25.1 (48d233f65 2022-07-12)", "The installer for rustup", "", "USAGE:", "    rustup-init [FLAGS] [OPTIONS]", "", "FLAGS:", "    -v, --verbose           Enable verbose output", "    -q, --quiet             Disable progress output", "    -y                      Disable confirmation prompt.", "        --no-modify-path    Don't configure the PATH environment variable", "    -h, --help              Prints help information", "    -V, --version           Prints version information", "", "OPTIONS:", "        --default-host <default-host>              Choose a default host triple", "        --default-toolchain <default-toolchain>    Choose a default toolchain to install", "        --default-toolchain none                   Do not install any toolchains", "        --profile [minimal|default|complete]       Choose a profile", "    -c, --component <components>...                Component name to also install", "    -t, --target <targets>...                      Target name to also install", "EOF", "}", "", "main() {", "    downloader --check", "    need_cmd uname", "    need_cmd mktemp", "    need_cmd chmod", "    need_cmd mkdir", "    need_cmd rm", "    need_cmd rmdir", "", "    get_architecture || return 1", "    local _arch=\"$RETVAL\"", "    assert_nz \"$_arch\" \"arch\"", "", "    local _ext=\"\"", "    case \"$_arch\" in", "        *windows*)", "            _ext=\".exe\"", "            ;;", "    esac", "", "    local _url=\"${RUSTUP_UPDATE_ROOT}/dist/${_arch}/rustup-init${_ext}\"", "", "    local _dir", "    _dir=\"$(ensure mktemp -d)\"", "    local _file=\"${_dir}/rustup-init${_ext}\"", "", "    local _ansi_escapes_are_valid=false", "    if [ -t 2 ]; then", "        if [ \"${TERM+set}\" = 'set' ]; then", "            case \"$TERM\" in", "                xterm*|rxvt*|urxvt*|linux*|vt*)", "                    _ansi_escapes_are_valid=true", "                ;;", "            esac", "        fi", "    fi", "", "    # check if we have to use /dev/tty to prompt the user", "    local need_tty=yes", "    for arg in \"$@\"; do", "        case \"$arg\" in", "            --help)", "                usage", "                exit 0", "                ;;", "            *)", "                OPTIND=1", "                if [ \"${arg%%--*}\" = \"\" ]; then", "                    # Long option (other than --help);", "                    # don't attempt to interpret it.", "                    continue", "                fi", "                while getopts :hy sub_arg \"$arg\"; do", "                    case \"$sub_arg\" in", "                        h)", "                            usage", "                            exit 0", "                            ;;", "                        y)", "                            # user wants to skip the prompt --", "                            # we don't need /dev/tty", "                            need_tty=no", "                            ;;", "                        *)", "                            ;;", "                        esac", "                done", "                ;;", "        esac", "    done", "", "    if $_ansi_escapes_are_valid; then", "        printf \"\\33[1minfo:\\33[0m downloading installer\\n\" 1>&2", "    else", "        printf '%s\\n' 'info: downloading installer' 1>&2", "    fi", "", "    ensure mkdir -p \"$_dir\"", "    ensure downloader \"$_url\" \"$_file\" \"$_arch\"", "    ensure chmod u+x \"$_file\"", "    if [ ! -x \"$_file\" ]; then", "        printf '%s\\n' \"Cannot execute $_file (likely because of mounting /tmp as noexec).\" 1>&2", "        printf '%s\\n' \"Please copy the file to a location where you can execute binaries and run ./rustup-init${_ext}.\" 1>&2", "        exit 1", "    fi", "", "    if [ \"$need_tty\" = \"yes\" ] && [ ! -t 0 ]; then", "        # The installer is going to want to ask for confirmation by", "        # reading stdin.  This script was piped into `sh` though and", "        # doesn't have stdin to pass to its children. Instead we're going", "        # to explicitly connect /dev/tty to the installer's stdin.", "        if [ ! -t 1 ]; then", "            err \"Unable to run interactively. Run with -y to accept defaults, --help for additional options\"", "        fi", "", "        ignore \"$_file\" \"$@\" < /dev/tty", "    else", "        ignore \"$_file\" \"$@\"", "    fi", "", "    local _retval=$?", "", "    ignore rm \"$_file\"", "    ignore rmdir \"$_dir\"", "", "    return \"$_retval\"", "}", "", "check_proc() {", "    # Check for /proc by looking for the /proc/self/exe link", "    # This is only run on Linux", "    if ! test -L /proc/self/exe ; then", "        err \"fatal: Unable to find /proc/self/exe.  Is /proc mounted?  Installation cannot proceed without /proc.\"", "    fi", "}", "", "get_bitness() {", "    need_cmd head", "    # Architecture detection without dependencies beyond coreutils.", "    # ELF files start out \"\\x7fELF\", and the following byte is", "    #   0x01 for 32-bit and", "    #   0x02 for 64-bit.", "    # The printf builtin on some shells like dash only supports octal", "    # escape sequences, so we use those.", "    local _current_exe_head", "    _current_exe_head=$(head -c 5 /proc/self/exe )", "    if [ \"$_current_exe_head\" = \"$(printf '\\177ELF\\001')\" ]; then", "        echo 32", "    elif [ \"$_current_exe_head\" = \"$(printf '\\177ELF\\002')\" ]; then", "        echo 64", "    else", "        err \"unknown platform bitness\"", "    fi", "}", "", "is_host_amd64_elf() {", "    need_cmd head", "    need_cmd tail", "    # ELF e_machine detection without dependencies beyond coreutils.", "    # Two-byte field at offset 0x12 indicates the CPU,", "    # but we're interested in it being 0x3E to indicate amd64, or not that.", "    local _current_exe_machine", "    _current_exe_machine=$(head -c 19 /proc/self/exe | tail -c 1)", "    [ \"$_current_exe_machine\" = \"$(printf '\\076')\" ]", "}", "", "get_endianness() {", "    local cputype=$1", "    local suffix_eb=$2", "    local suffix_el=$3", "", "    # detect endianness without od/hexdump, like get_bitness() does.", "    need_cmd head", "    need_cmd tail", "", "    local _current_exe_endianness", "    _current_exe_endianness=\"$(head -c 6 /proc/self/exe | tail -c 1)\"", "    if [ \"$_current_exe_endianness\" = \"$(printf '\\001')\" ]; then", "        echo \"${cputype}${suffix_el}\"", "    elif [ \"$_current_exe_endianness\" = \"$(printf '\\002')\" ]; then", "        echo \"${cputype}${suffix_eb}\"", "    else", "        err \"unknown platform endianness\"", "    fi", "}", "", "get_architecture() {", "    local _ostype _cputype _bitness _arch _clibtype", "    _ostype=\"$(uname -s)\"", "    _cputype=\"$(uname -m)\"", "    _clibtype=\"gnu\"", "", "    if [ \"$_ostype\" = Linux ]; then", "        if [ \"$(uname -o)\" = Android ]; then", "            _ostype=Android", "        fi", "        if ldd --version 2>&1 | grep -q 'musl'; then", "            _clibtype=\"musl\"", "        fi", "    fi", "", "    if [ \"$_ostype\" = Darwin ] && [ \"$_cputype\" = i386 ]; then", "        # Darwin `uname -m` lies", "        if sysctl hw.optional.x86_64 | grep -q ': 1'; then", "            _cputype=x86_64", "        fi", "    fi", "", "    if [ \"$_ostype\" = SunOS ]; then", "        # Both Solaris and illumos presently announce as \"SunOS\" in \"uname -s\"", "        # so use \"uname -o\" to disambiguate.  We use the full path to the", "        # system uname in case the user has coreutils uname first in PATH,", "        # which has historically sometimes printed the wrong value here.", "        if [ \"$(/usr/bin/uname -o)\" = illumos ]; then", "            _ostype=illumos", "        fi", "", "        # illumos systems have multi-arch userlands, and \"uname -m\" reports the", "        # machine hardware name; e.g., \"i86pc\" on both 32- and 64-bit x86", "        # systems.  Check for the native (widest) instruction set on the", "        # running kernel:", "        if [ \"$_cputype\" = i86pc ]; then", "            _cputype=\"$(isainfo -n)\"", "        fi", "    fi", "", "    case \"$_ostype\" in", "", "        Android)", "            _ostype=linux-android", "            ;;", "", "        Linux)", "            check_proc", "            _ostype=unknown-linux-$_clibtype", "            _bitness=$(get_bitness)", "            ;;", "", "        FreeBSD)", "            _ostype=unknown-freebsd", "            ;;", "", "        NetBSD)", "            _ostype=unknown-netbsd", "            ;;", "", "        DragonFly)", "            _ostype=unknown-dragonfly", "            ;;", "", "        Darwin)", "            _ostype=apple-darwin", "            ;;", "", "        illumos)", "            _ostype=unknown-illumos", "            ;;", "", "        MINGW* | MSYS* | CYGWIN* | Windows_NT)", "            _ostype=pc-windows-gnu", "            ;;", "", "        *)", "            err \"unrecognized OS type: $_ostype\"", "            ;;", "", "    esac", "", "    case \"$_cputype\" in", "", "        i386 | i486 | i686 | i786 | x86)", "            _cputype=i686", "            ;;", "", "        xscale | arm)", "            _cputype=arm", "            if [ \"$_ostype\" = \"linux-android\" ]; then", "                _ostype=linux-androideabi", "            fi", "            ;;", "", "        armv6l)", "            _cputype=arm", "            if [ \"$_ostype\" = \"linux-android\" ]; then", "                _ostype=linux-androideabi", "            else", "                _ostype=\"${_ostype}eabihf\"", "            fi", "            ;;", "", "        armv7l | armv8l)", "            _cputype=armv7", "            if [ \"$_ostype\" = \"linux-android\" ]; then", "                _ostype=linux-androideabi", "            else", "                _ostype=\"${_ostype}eabihf\"", "            fi", "            ;;", "", "        aarch64 | arm64)", "            _cputype=aarch64", "            ;;", "", "        x86_64 | x86-64 | x64 | amd64)", "            _cputype=x86_64", "            ;;", "", "        mips)", "            _cputype=$(get_endianness mips '' el)", "            ;;", "", "        mips64)", "            if [ \"$_bitness\" -eq 64 ]; then", "                # only n64 ABI is supported for now", "                _ostype=\"${_ostype}abi64\"", "                _cputype=$(get_endianness mips64 '' el)", "            fi", "            ;;", "", "        ppc)", "            _cputype=powerpc", "            ;;", "", "        ppc64)", "            _cputype=powerpc64", "            ;;", "", "        ppc64le)", "            _cputype=powerpc64le", "            ;;", "", "        s390x)", "            _cputype=s390x", "            ;;", "        riscv64)", "            _cputype=riscv64gc", "            ;;", "        *)", "            err \"unknown CPU type: $_cputype\"", "", "    esac", "", "    # Detect 64-bit linux with 32-bit userland", "    if [ \"${_ostype}\" = unknown-linux-gnu ] && [ \"${_bitness}\" -eq 32 ]; then", "        case $_cputype in", "            x86_64)", "                if [ -n \"${RUSTUP_CPUTYPE:-}\" ]; then", "                    _cputype=\"$RUSTUP_CPUTYPE\"", "                else {", "                    # 32-bit executable for amd64 = x32", "                    if is_host_amd64_elf; then {", "                         echo \"This host is running an x32 userland; as it stands, x32 support is poor,\" 1>&2", "                         echo \"and there isn't a native toolchain -- you will have to install\" 1>&2", "                         echo \"multiarch compatibility with i686 and/or amd64, then select one\" 1>&2", "                         echo \"by re-running this script with the RUSTUP_CPUTYPE environment variable\" 1>&2", "                         echo \"set to i686 or x86_64, respectively.\" 1>&2", "                         echo 1>&2", "                         echo \"You will be able to add an x32 target after installation by running\" 1>&2", "                         echo \"  rustup target add x86_64-unknown-linux-gnux32\" 1>&2", "                         exit 1", "                    }; else", "                        _cputype=i686", "                    fi", "                }; fi", "                ;;", "            mips64)", "                _cputype=$(get_endianness mips '' el)", "                ;;", "            powerpc64)", "                _cputype=powerpc", "                ;;", "            aarch64)", "                _cputype=armv7", "                if [ \"$_ostype\" = \"linux-android\" ]; then", "                    _ostype=linux-androideabi", "                else", "                    _ostype=\"${_ostype}eabihf\"", "                fi", "                ;;", "            riscv64gc)", "                err \"riscv64 with 32-bit userland unsupported\"", "                ;;", "        esac", "    fi", "", "    # Detect armv7 but without the CPU features Rust needs in that build,", "    # and fall back to arm.", "    # See https://github.com/rust-lang/rustup.rs/issues/587.", "    if [ \"$_ostype\" = \"unknown-linux-gnueabihf\" ] && [ \"$_cputype\" = armv7 ]; then", "        if ensure grep '^Features' /proc/cpuinfo | grep -q -v neon; then", "            # At least one processor does not have NEON.", "            _cputype=arm", "        fi", "    fi", "", "    _arch=\"${_cputype}-${_ostype}\"", "", "    RETVAL=\"$_arch\"", "}", "", "say() {", "    printf 'rustup: %s\\n' \"$1\"", "}", "", "err() {", "    say \"$1\" >&2", "    exit 1", "}", "", "need_cmd() {", "    if ! check_cmd \"$1\"; then", "        err \"need '$1' (command not found)\"", "    fi", "}", "", "check_cmd() {", "    command -v \"$1\" > /dev/null 2>&1", "}", "", "assert_nz() {", "    if [ -z \"$1\" ]; then err \"assert_nz $2\"; fi", "}", "", "# Run a command that should never fail. If the command fails execution", "# will immediately terminate with an error showing the failing", "# command.", "ensure() {", "    if ! \"$@\"; then err \"command failed: $*\"; fi", "}", "", "# This is just for indicating that commands' results are being", "# intentionally ignored. Usually, because it's being executed", "# as part of error handling.", "ignore() {", "    \"$@\"", "}", "", "# This wraps curl or wget. Try curl first, if not installed,", "# use wget instead.", "downloader() {", "    local _dld", "    local _ciphersuites", "    local _err", "    local _status", "    local _retry", "    if check_cmd curl; then", "        _dld=curl", "    elif check_cmd wget; then", "        _dld=wget", "    else", "        _dld='curl or wget' # to be used in error message of need_cmd", "    fi", "", "    if [ \"$1\" = --check ]; then", "        need_cmd \"$_dld\"", "    elif [ \"$_dld\" = curl ]; then", "        check_curl_for_retry_support", "        _retry=\"$RETVAL\"", "        get_ciphersuites_for_curl", "        _ciphersuites=\"$RETVAL\"", "        if [ -n \"$_ciphersuites\" ]; then", "            _err=$(curl $_retry --proto '=https' --tlsv1.2 --ciphers \"$_ciphersuites\" --silent --show-error --fail --location \"$1\" --output \"$2\" 2>&1)", "            _status=$?", "        else", "            echo \"Warning: Not enforcing strong cipher suites for TLS, this is potentially less secure\"", "            if ! check_help_for \"$3\" curl --proto --tlsv1.2; then", "                echo \"Warning: Not enforcing TLS v1.2, this is potentially less secure\"", "                _err=$(curl $_retry --silent --show-error --fail --location \"$1\" --output \"$2\" 2>&1)", "                _status=$?", "            else", "                _err=$(curl $_retry --proto '=https' --tlsv1.2 --silent --show-error --fail --location \"$1\" --output \"$2\" 2>&1)", "                _status=$?", "            fi", "        fi", "        if [ -n \"$_err\" ]; then", "            echo \"$_err\" >&2", "            if echo \"$_err\" | grep -q 404$; then", "                err \"installer for platform '$3' not found, this may be unsupported\"", "            fi", "        fi", "        return $_status", "    elif [ \"$_dld\" = wget ]; then", "        if [ \"$(wget -V 2>&1|head -2|tail -1|cut -f1 -d\" \")\" = \"BusyBox\" ]; then", "            echo \"Warning: using the BusyBox version of wget.  Not enforcing strong cipher suites for TLS or TLS v1.2, this is potentially less secure\"", "            _err=$(wget \"$1\" -O \"$2\" 2>&1)", "            _status=$?", "        else", "            get_ciphersuites_for_wget", "            _ciphersuites=\"$RETVAL\"", "            if [ -n \"$_ciphersuites\" ]; then", "                _err=$(wget --https-only --secure-protocol=TLSv1_2 --ciphers \"$_ciphersuites\" \"$1\" -O \"$2\" 2>&1)", "                _status=$?", "            else", "                echo \"Warning: Not enforcing strong cipher suites for TLS, this is potentially less secure\"", "                if ! check_help_for \"$3\" wget --https-only --secure-protocol; then", "                    echo \"Warning: Not enforcing TLS v1.2, this is potentially less secure\"", "                    _err=$(wget \"$1\" -O \"$2\" 2>&1)", "                    _status=$?", "                else", "                    _err=$(wget --https-only --secure-protocol=TLSv1_2 \"$1\" -O \"$2\" 2>&1)", "                    _status=$?", "                fi", "            fi", "        fi", "        if [ -n \"$_err\" ]; then", "            echo \"$_err\" >&2", "            if echo \"$_err\" | grep -q ' 404 Not Found$'; then", "                err \"installer for platform '$3' not found, this may be unsupported\"", "            fi", "        fi", "        return $_status", "    else", "        err \"Unknown downloader\"   # should not reach here", "    fi", "}", "", "check_help_for() {", "    local _arch", "    local _cmd", "    local _arg", "    _arch=\"$1\"", "    shift", "    _cmd=\"$1\"", "    shift", "", "    local _category", "    if \"$_cmd\" --help | grep -q 'For all options use the manual or \"--help all\".'; then", "      _category=\"all\"", "    else", "      _category=\"\"", "    fi", "", "    case \"$_arch\" in", "", "        *darwin*)", "        if check_cmd sw_vers; then", "            case $(sw_vers -productVersion) in", "                10.*)", "                    # If we're running on macOS, older than 10.13, then we always", "                    # fail to find these options to force fallback", "                    if [ \"$(sw_vers -productVersion | cut -d. -f2)\" -lt 13 ]; then", "                        # Older than 10.13", "                        echo \"Warning: Detected macOS platform older than 10.13\"", "                        return 1", "                    fi", "                    ;;", "                11.*)", "                    # We assume Big Sur will be OK for now", "                    ;;", "                *)", "                    # Unknown product version, warn and continue", "                    echo \"Warning: Detected unknown macOS major version: $(sw_vers -productVersion)\"", "                    echo \"Warning TLS capabilities detection may fail\"", "                    ;;", "            esac", "        fi", "        ;;", "", "    esac", "", "    for _arg in \"$@\"; do", "        if ! \"$_cmd\" --help $_category | grep -q -- \"$_arg\"; then", "            return 1", "        fi", "    done", "", "    true # not strictly needed", "}", "", "# Check if curl supports the --retry flag, then pass it to the curl invocation.", "check_curl_for_retry_support() {", "  local _retry_supported=\"\"", "  # \"unspecified\" is for arch, allows for possibility old OS using macports, homebrew, etc.", "  if check_help_for \"notspecified\" \"curl\" \"--retry\"; then", "    _retry_supported=\"--retry 3\"", "  fi", "", "  RETVAL=\"$_retry_supported\"", "", "}", "", "# Return cipher suite string specified by user, otherwise return strong TLS 1.2-1.3 cipher suites", "# if support by local tools is detected. Detection currently supports these curl backends:", "# GnuTLS and OpenSSL (possibly also LibreSSL and BoringSSL). Return value can be empty.", "get_ciphersuites_for_curl() {", "    if [ -n \"${RUSTUP_TLS_CIPHERSUITES-}\" ]; then", "        # user specified custom cipher suites, assume they know what they're doing", "        RETVAL=\"$RUSTUP_TLS_CIPHERSUITES\"", "        return", "    fi", "", "    local _openssl_syntax=\"no\"", "    local _gnutls_syntax=\"no\"", "    local _backend_supported=\"yes\"", "    if curl -V | grep -q ' OpenSSL/'; then", "        _openssl_syntax=\"yes\"", "    elif curl -V | grep -iq ' LibreSSL/'; then", "        _openssl_syntax=\"yes\"", "    elif curl -V | grep -iq ' BoringSSL/'; then", "        _openssl_syntax=\"yes\"", "    elif curl -V | grep -iq ' GnuTLS/'; then", "        _gnutls_syntax=\"yes\"", "    else", "        _backend_supported=\"no\"", "    fi", "", "    local _args_supported=\"no\"", "    if [ \"$_backend_supported\" = \"yes\" ]; then", "        # \"unspecified\" is for arch, allows for possibility old OS using macports, homebrew, etc.", "        if check_help_for \"notspecified\" \"curl\" \"--tlsv1.2\" \"--ciphers\" \"--proto\"; then", "            _args_supported=\"yes\"", "        fi", "    fi", "", "    local _cs=\"\"", "    if [ \"$_args_supported\" = \"yes\" ]; then", "        if [ \"$_openssl_syntax\" = \"yes\" ]; then", "            _cs=$(get_strong_ciphersuites_for \"openssl\")", "        elif [ \"$_gnutls_syntax\" = \"yes\" ]; then", "            _cs=$(get_strong_ciphersuites_for \"gnutls\")", "        fi", "    fi", "", "    RETVAL=\"$_cs\"", "}", "", "# Return cipher suite string specified by user, otherwise return strong TLS 1.2-1.3 cipher suites", "# if support by local tools is detected. Detection currently supports these wget backends:", "# GnuTLS and OpenSSL (possibly also LibreSSL and BoringSSL). Return value can be empty.", "get_ciphersuites_for_wget() {", "    if [ -n \"${RUSTUP_TLS_CIPHERSUITES-}\" ]; then", "        # user specified custom cipher suites, assume they know what they're doing", "        RETVAL=\"$RUSTUP_TLS_CIPHERSUITES\"", "        return", "    fi", "", "    local _cs=\"\"", "    if wget -V | grep -q '\\-DHAVE_LIBSSL'; then", "        # \"unspecified\" is for arch, allows for possibility old OS using macports, homebrew, etc.", "        if check_help_for \"notspecified\" \"wget\" \"TLSv1_2\" \"--ciphers\" \"--https-only\" \"--secure-protocol\"; then", "            _cs=$(get_strong_ciphersuites_for \"openssl\")", "        fi", "    elif wget -V | grep -q '\\-DHAVE_LIBGNUTLS'; then", "        # \"unspecified\" is for arch, allows for possibility old OS using macports, homebrew, etc.", "        if check_help_for \"notspecified\" \"wget\" \"TLSv1_2\" \"--ciphers\" \"--https-only\" \"--secure-protocol\"; then", "            _cs=$(get_strong_ciphersuites_for \"gnutls\")", "        fi", "    fi", "", "    RETVAL=\"$_cs\"", "}", "", "# Return strong TLS 1.2-1.3 cipher suites in OpenSSL or GnuTLS syntax. TLS 1.2", "# excludes non-ECDHE and non-AEAD cipher suites. DHE is excluded due to bad", "# DH params often found on servers (see RFC 7919). Sequence matches or is", "# similar to Firefox 68 ESR with weak cipher suites disabled via about:config.", "# $1 must be openssl or gnutls.", "get_strong_ciphersuites_for() {", "    if [ \"$1\" = \"openssl\" ]; then", "        # OpenSSL is forgiving of unknown values, no problems with TLS 1.3 values on versions that don't support it yet.", "        echo \"TLS_AES_128_GCM_SHA256:TLS_CHACHA20_POLY1305_SHA256:TLS_AES_256_GCM_SHA384:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384\"", "    elif [ \"$1\" = \"gnutls\" ]; then", "        # GnuTLS isn't forgiving of unknown values, so this may require a GnuTLS version that supports TLS 1.3 even if wget doesn't.", "        # Begin with SECURE128 (and higher) then remove/add to build cipher suites. Produces same 9 cipher suites as OpenSSL but in slightly different order.", "        echo \"SECURE128:-VERS-SSL3.0:-VERS-TLS1.0:-VERS-TLS1.1:-VERS-DTLS-ALL:-CIPHER-ALL:-MAC-ALL:-KX-ALL:+AEAD:+ECDHE-ECDSA:+ECDHE-RSA:+AES-128-GCM:+CHACHA20-POLY1305:+AES-256-GCM\"", "    fi", "}", "", "main \"$@\" || exit 1", "curl: (1) Protocol \"http\" not supported or disabled in libcurl", "curl: (1) Protocol \"http\" not supported or disabled in libcurl"]}
2022-12-30 00:00:39,191 p=87051 u=kal n=ansible | PLAY RECAP *******************************************************************************************************************************************
2022-12-30 00:00:39,191 p=87051 u=kal n=ansible | krpz                       : ok=3    changed=1    unreachable=0    failed=1    skipped=0    rescued=0    ignored=0   
2022-12-30 00:01:26,041 p=87304 u=kal n=ansible | Using /home/kal/MyApplications/dotfiles/playbooks/ansible.cfg as config file
2022-12-30 00:01:26,112 p=87304 u=kal n=ansible | PLAY [localhost] *************************************************************************************************************************************
2022-12-30 00:01:26,119 p=87304 u=kal n=ansible | TASK [Gathering Facts] *******************************************************************************************************************************
2022-12-30 00:01:30,077 p=87304 u=kal n=ansible | ok: [krpz]
2022-12-30 00:01:30,103 p=87304 u=kal n=ansible | TASK [install pexpect] *******************************************************************************************************************************
2022-12-30 00:01:30,536 p=87304 u=kal n=ansible | ok: [krpz] => {"changed": false, "cmd": ["/usr/bin/python2", "-m", "pip.__main__", "install", "pexpect"], "name": ["pexpect"], "requirements": null, "state": "present", "stderr": "DEPRECATION: Python 2.7 reached the end of its life on January 1st, 2020. Please upgrade your Python as Python 2.7 is no longer maintained. pip 21.0 will drop support for Python 2.7 in January 2021. More details about Python 2 support in pip can be found at https://pip.pypa.io/en/latest/development/release-process/#python-2-support pip 21.0 will remove support for this functionality.\n", "stderr_lines": ["DEPRECATION: Python 2.7 reached the end of its life on January 1st, 2020. Please upgrade your Python as Python 2.7 is no longer maintained. pip 21.0 will drop support for Python 2.7 in January 2021. More details about Python 2 support in pip can be found at https://pip.pypa.io/en/latest/development/release-process/#python-2-support pip 21.0 will remove support for this functionality."], "stdout": "Requirement already satisfied: pexpect in /usr/local/lib/python2.7/dist-packages (4.8.0)\nRequirement already satisfied: ptyprocess>=0.5 in /usr/local/lib/python2.7/dist-packages (from pexpect) (0.7.0)\n", "stdout_lines": ["Requirement already satisfied: pexpect in /usr/local/lib/python2.7/dist-packages (4.8.0)", "Requirement already satisfied: ptyprocess>=0.5 in /usr/local/lib/python2.7/dist-packages (from pexpect) (0.7.0)"], "version": null, "virtualenv": null}
2022-12-30 00:01:30,544 p=87304 u=kal n=ansible | TASK [install setuptools] ****************************************************************************************************************************
2022-12-30 00:01:30,884 p=87304 u=kal n=ansible | ok: [krpz] => {"changed": false, "cmd": ["/usr/bin/python2", "-m", "pip.__main__", "install", "setuptools"], "name": ["setuptools"], "requirements": null, "state": "present", "stderr": "DEPRECATION: Python 2.7 reached the end of its life on January 1st, 2020. Please upgrade your Python as Python 2.7 is no longer maintained. pip 21.0 will drop support for Python 2.7 in January 2021. More details about Python 2 support in pip can be found at https://pip.pypa.io/en/latest/development/release-process/#python-2-support pip 21.0 will remove support for this functionality.\n", "stderr_lines": ["DEPRECATION: Python 2.7 reached the end of its life on January 1st, 2020. Please upgrade your Python as Python 2.7 is no longer maintained. pip 21.0 will drop support for Python 2.7 in January 2021. More details about Python 2 support in pip can be found at https://pip.pypa.io/en/latest/development/release-process/#python-2-support pip 21.0 will remove support for this functionality."], "stdout": "Requirement already satisfied: setuptools in /usr/lib/python2.7/dist-packages (44.1.1)\n", "stdout_lines": ["Requirement already satisfied: setuptools in /usr/lib/python2.7/dist-packages (44.1.1)"], "version": null, "virtualenv": null}
2022-12-30 00:01:30,893 p=87304 u=kal n=ansible | TASK [Install Rust] **********************************************************************************************************************************
2022-12-30 00:01:33,036 p=87304 u=kal n=ansible | fatal: [krpz]: FAILED! => {"changed": true, "cmd": "curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh", "delta": "0:00:01.903709", "end": "2022-12-30 00:01:32.957006", "msg": "non-zero return code", "rc": 1, "start": "2022-12-30 00:01:31.053297", "stdout": "#!/bin/sh\r\n# shellcheck shell=dash\r\n\r\n# This is just a little script that can be downloaded from the internet to\r\n# install rustup. It just does platform detection, downloads the installer\r\n# and runs it.\r\n\r\n# It runs on Unix shells like {a,ba,da,k,z}sh. It uses the common `local`\r\n# extension. Note: Most shells limit `local` to 1 var per line, contra bash.\r\n\r\nif [ \"$KSH_VERSION\" = 'Version JM 93t+ 2010-03-05' ]; then\r\n    # The version of ksh93 that ships with many illumos systems does not\r\n    # support the \"local\" extension.  Print a message rather than fail in\r\n    # subtle ways later on:\r\n    echo 'rustup does not work with this ksh93 version; please try bash!' >&2\r\n    exit 1\r\nfi\r\n\r\n\r\nset -u\r\n\r\n# If RUSTUP_UPDATE_ROOT is unset or empty, default it.\r\nRUSTUP_UPDATE_ROOT=\"${RUSTUP_UPDATE_ROOT:-https://static.rust-lang.org/rustup}\"\r\n\r\n#XXX: If you change anything here, please make the same changes in setup_mode.rs\r\nusage() {\r\n    cat 1>&2 <<EOF\r\nrustup-init 1.25.1 (48d233f65 2022-07-12)\r\nThe installer for rustup\r\n\r\nUSAGE:\r\n    rustup-init [FLAGS] [OPTIONS]\r\n\r\nFLAGS:\r\n    -v, --verbose           Enable verbose output\r\n    -q, --quiet             Disable progress output\r\n    -y                      Disable confirmation prompt.\r\n        --no-modify-path    Don't configure the PATH environment variable\r\n    -h, --help              Prints help information\r\n    -V, --version           Prints version information\r\n\r\nOPTIONS:\r\n        --default-host <default-host>              Choose a default host triple\r\n        --default-toolchain <default-toolchain>    Choose a default toolchain to install\r\n        --default-toolchain none                   Do not install any toolchains\r\n        --profile [minimal|default|complete]       Choose a profile\r\n    -c, --component <components>...                Component name to also install\r\n    -t, --target <targets>...                      Target name to also install\r\nEOF\r\n}\r\n\r\nmain() {\r\n    downloader --check\r\n    need_cmd uname\r\n    need_cmd mktemp\r\n    need_cmd chmod\r\n    need_cmd mkdir\r\n    need_cmd rm\r\n    need_cmd rmdir\r\n\r\n    get_architecture || return 1\r\n    local _arch=\"$RETVAL\"\r\n    assert_nz \"$_arch\" \"arch\"\r\n\r\n    local _ext=\"\"\r\n    case \"$_arch\" in\r\n        *windows*)\r\n            _ext=\".exe\"\r\n            ;;\r\n    esac\r\n\r\n    local _url=\"${RUSTUP_UPDATE_ROOT}/dist/${_arch}/rustup-init${_ext}\"\r\n\r\n    local _dir\r\n    _dir=\"$(ensure mktemp -d)\"\r\n    local _file=\"${_dir}/rustup-init${_ext}\"\r\n\r\n    local _ansi_escapes_are_valid=false\r\n    if [ -t 2 ]; then\r\n        if [ \"${TERM+set}\" = 'set' ]; then\r\n            case \"$TERM\" in\r\n                xterm*|rxvt*|urxvt*|linux*|vt*)\r\n                    _ansi_escapes_are_valid=true\r\n                ;;\r\n            esac\r\n        fi\r\n    fi\r\n\r\n    # check if we have to use /dev/tty to prompt the user\r\n    local need_tty=yes\r\n    for arg in \"$@\"; do\r\n        case \"$arg\" in\r\n            --help)\r\n                usage\r\n                exit 0\r\n                ;;\r\n            *)\r\n                OPTIND=1\r\n                if [ \"${arg%%--*}\" = \"\" ]; then\r\n                    # Long option (other than --help);\r\n                    # don't attempt to interpret it.\r\n                    continue\r\n                fi\r\n                while getopts :hy sub_arg \"$arg\"; do\r\n                    case \"$sub_arg\" in\r\n                        h)\r\n                            usage\r\n                            exit 0\r\n                            ;;\r\n                        y)\r\n                            # user wants to skip the prompt --\r\n                            # we don't need /dev/tty\r\n                            need_tty=no\r\n                            ;;\r\n                        *)\r\n                            ;;\r\n                        esac\r\n                done\r\n                ;;\r\n        esac\r\n    done\r\n\r\n    if $_ansi_escapes_are_valid; then\r\n        printf \"\\33[1minfo:\\33[0m downloading installer\\n\" 1>&2\r\n    else\r\n        printf '%s\\n' 'info: downloading installer' 1>&2\r\n    fi\r\n\r\n    ensure mkdir -p \"$_dir\"\r\n    ensure downloader \"$_url\" \"$_file\" \"$_arch\"\r\n    ensure chmod u+x \"$_file\"\r\n    if [ ! -x \"$_file\" ]; then\r\n        printf '%s\\n' \"Cannot execute $_file (likely because of mounting /tmp as noexec).\" 1>&2\r\n        printf '%s\\n' \"Please copy the file to a location where you can execute binaries and run ./rustup-init${_ext}.\" 1>&2\r\n        exit 1\r\n    fi\r\n\r\n    if [ \"$need_tty\" = \"yes\" ] && [ ! -t 0 ]; then\r\n        # The installer is going to want to ask for confirmation by\r\n        # reading stdin.  This script was piped into `sh` though and\r\n        # doesn't have stdin to pass to its children. Instead we're going\r\n        # to explicitly connect /dev/tty to the installer's stdin.\r\n        if [ ! -t 1 ]; then\r\n            err \"Unable to run interactively. Run with -y to accept defaults, --help for additional options\"\r\n        fi\r\n\r\n        ignore \"$_file\" \"$@\" < /dev/tty\r\n    else\r\n        ignore \"$_file\" \"$@\"\r\n    fi\r\n\r\n    local _retval=$?\r\n\r\n    ignore rm \"$_file\"\r\n    ignore rmdir \"$_dir\"\r\n\r\n    return \"$_retval\"\r\n}\r\n\r\ncheck_proc() {\r\n    # Check for /proc by looking for the /proc/self/exe link\r\n    # This is only run on Linux\r\n    if ! test -L /proc/self/exe ; then\r\n        err \"fatal: Unable to find /proc/self/exe.  Is /proc mounted?  Installation cannot proceed without /proc.\"\r\n    fi\r\n}\r\n\r\nget_bitness() {\r\n    need_cmd head\r\n    # Architecture detection without dependencies beyond coreutils.\r\n    # ELF files start out \"\\x7fELF\", and the following byte is\r\n    #   0x01 for 32-bit and\r\n    #   0x02 for 64-bit.\r\n    # The printf builtin on some shells like dash only supports octal\r\n    # escape sequences, so we use those.\r\n    local _current_exe_head\r\n    _current_exe_head=$(head -c 5 /proc/self/exe )\r\n    if [ \"$_current_exe_head\" = \"$(printf '\\177ELF\\001')\" ]; then\r\n        echo 32\r\n    elif [ \"$_current_exe_head\" = \"$(printf '\\177ELF\\002')\" ]; then\r\n        echo 64\r\n    else\r\n        err \"unknown platform bitness\"\r\n    fi\r\n}\r\n\r\nis_host_amd64_elf() {\r\n    need_cmd head\r\n    need_cmd tail\r\n    # ELF e_machine detection without dependencies beyond coreutils.\r\n    # Two-byte field at offset 0x12 indicates the CPU,\r\n    # but we're interested in it being 0x3E to indicate amd64, or not that.\r\n    local _current_exe_machine\r\n    _current_exe_machine=$(head -c 19 /proc/self/exe | tail -c 1)\r\n    [ \"$_current_exe_machine\" = \"$(printf '\\076')\" ]\r\n}\r\n\r\nget_endianness() {\r\n    local cputype=$1\r\n    local suffix_eb=$2\r\n    local suffix_el=$3\r\n\r\n    # detect endianness without od/hexdump, like get_bitness() does.\r\n    need_cmd head\r\n    need_cmd tail\r\n\r\n    local _current_exe_endianness\r\n    _current_exe_endianness=\"$(head -c 6 /proc/self/exe | tail -c 1)\"\r\n    if [ \"$_current_exe_endianness\" = \"$(printf '\\001')\" ]; then\r\n        echo \"${cputype}${suffix_el}\"\r\n    elif [ \"$_current_exe_endianness\" = \"$(printf '\\002')\" ]; then\r\n        echo \"${cputype}${suffix_eb}\"\r\n    else\r\n        err \"unknown platform endianness\"\r\n    fi\r\n}\r\n\r\nget_architecture() {\r\n    local _ostype _cputype _bitness _arch _clibtype\r\n    _ostype=\"$(uname -s)\"\r\n    _cputype=\"$(uname -m)\"\r\n    _clibtype=\"gnu\"\r\n\r\n    if [ \"$_ostype\" = Linux ]; then\r\n        if [ \"$(uname -o)\" = Android ]; then\r\n            _ostype=Android\r\n        fi\r\n        if ldd --version 2>&1 | grep -q 'musl'; then\r\n            _clibtype=\"musl\"\r\n        fi\r\n    fi\r\n\r\n    if [ \"$_ostype\" = Darwin ] && [ \"$_cputype\" = i386 ]; then\r\n        # Darwin `uname -m` lies\r\n        if sysctl hw.optional.x86_64 | grep -q ': 1'; then\r\n            _cputype=x86_64\r\n        fi\r\n    fi\r\n\r\n    if [ \"$_ostype\" = SunOS ]; then\r\n        # Both Solaris and illumos presently announce as \"SunOS\" in \"uname -s\"\r\n        # so use \"uname -o\" to disambiguate.  We use the full path to the\r\n        # system uname in case the user has coreutils uname first in PATH,\r\n        # which has historically sometimes printed the wrong value here.\r\n        if [ \"$(/usr/bin/uname -o)\" = illumos ]; then\r\n            _ostype=illumos\r\n        fi\r\n\r\n        # illumos systems have multi-arch userlands, and \"uname -m\" reports the\r\n        # machine hardware name; e.g., \"i86pc\" on both 32- and 64-bit x86\r\n        # systems.  Check for the native (widest) instruction set on the\r\n        # running kernel:\r\n        if [ \"$_cputype\" = i86pc ]; then\r\n            _cputype=\"$(isainfo -n)\"\r\n        fi\r\n    fi\r\n\r\n    case \"$_ostype\" in\r\n\r\n        Android)\r\n            _ostype=linux-android\r\n            ;;\r\n\r\n        Linux)\r\n            check_proc\r\n            _ostype=unknown-linux-$_clibtype\r\n            _bitness=$(get_bitness)\r\n            ;;\r\n\r\n        FreeBSD)\r\n            _ostype=unknown-freebsd\r\n            ;;\r\n\r\n        NetBSD)\r\n            _ostype=unknown-netbsd\r\n            ;;\r\n\r\n        DragonFly)\r\n            _ostype=unknown-dragonfly\r\n            ;;\r\n\r\n        Darwin)\r\n            _ostype=apple-darwin\r\n            ;;\r\n\r\n        illumos)\r\n            _ostype=unknown-illumos\r\n            ;;\r\n\r\n        MINGW* | MSYS* | CYGWIN* | Windows_NT)\r\n            _ostype=pc-windows-gnu\r\n            ;;\r\n\r\n        *)\r\n            err \"unrecognized OS type: $_ostype\"\r\n            ;;\r\n\r\n    esac\r\n\r\n    case \"$_cputype\" in\r\n\r\n        i386 | i486 | i686 | i786 | x86)\r\n            _cputype=i686\r\n            ;;\r\n\r\n        xscale | arm)\r\n            _cputype=arm\r\n            if [ \"$_ostype\" = \"linux-android\" ]; then\r\n                _ostype=linux-androideabi\r\n            fi\r\n            ;;\r\n\r\n        armv6l)\r\n            _cputype=arm\r\n            if [ \"$_ostype\" = \"linux-android\" ]; then\r\n                _ostype=linux-androideabi\r\n            else\r\n                _ostype=\"${_ostype}eabihf\"\r\n            fi\r\n            ;;\r\n\r\n        armv7l | armv8l)\r\n            _cputype=armv7\r\n            if [ \"$_ostype\" = \"linux-android\" ]; then\r\n                _ostype=linux-androideabi\r\n            else\r\n                _ostype=\"${_ostype}eabihf\"\r\n            fi\r\n            ;;\r\n\r\n        aarch64 | arm64)\r\n            _cputype=aarch64\r\n            ;;\r\n\r\n        x86_64 | x86-64 | x64 | amd64)\r\n            _cputype=x86_64\r\n            ;;\r\n\r\n        mips)\r\n            _cputype=$(get_endianness mips '' el)\r\n            ;;\r\n\r\n        mips64)\r\n            if [ \"$_bitness\" -eq 64 ]; then\r\n                # only n64 ABI is supported for now\r\n                _ostype=\"${_ostype}abi64\"\r\n                _cputype=$(get_endianness mips64 '' el)\r\n            fi\r\n            ;;\r\n\r\n        ppc)\r\n            _cputype=powerpc\r\n            ;;\r\n\r\n        ppc64)\r\n            _cputype=powerpc64\r\n            ;;\r\n\r\n        ppc64le)\r\n            _cputype=powerpc64le\r\n            ;;\r\n\r\n        s390x)\r\n            _cputype=s390x\r\n            ;;\r\n        riscv64)\r\n            _cputype=riscv64gc\r\n            ;;\r\n        *)\r\n            err \"unknown CPU type: $_cputype\"\r\n\r\n    esac\r\n\r\n    # Detect 64-bit linux with 32-bit userland\r\n    if [ \"${_ostype}\" = unknown-linux-gnu ] && [ \"${_bitness}\" -eq 32 ]; then\r\n        case $_cputype in\r\n            x86_64)\r\n                if [ -n \"${RUSTUP_CPUTYPE:-}\" ]; then\r\n                    _cputype=\"$RUSTUP_CPUTYPE\"\r\n                else {\r\n                    # 32-bit executable for amd64 = x32\r\n                    if is_host_amd64_elf; then {\r\n                         echo \"This host is running an x32 userland; as it stands, x32 support is poor,\" 1>&2\r\n                         echo \"and there isn't a native toolchain -- you will have to install\" 1>&2\r\n                         echo \"multiarch compatibility with i686 and/or amd64, then select one\" 1>&2\r\n                         echo \"by re-running this script with the RUSTUP_CPUTYPE environment variable\" 1>&2\r\n                         echo \"set to i686 or x86_64, respectively.\" 1>&2\r\n                         echo 1>&2\r\n                         echo \"You will be able to add an x32 target after installation by running\" 1>&2\r\n                         echo \"  rustup target add x86_64-unknown-linux-gnux32\" 1>&2\r\n                         exit 1\r\n                    }; else\r\n                        _cputype=i686\r\n                    fi\r\n                }; fi\r\n                ;;\r\n            mips64)\r\n                _cputype=$(get_endianness mips '' el)\r\n                ;;\r\n            powerpc64)\r\n                _cputype=powerpc\r\n                ;;\r\n            aarch64)\r\n                _cputype=armv7\r\n                if [ \"$_ostype\" = \"linux-android\" ]; then\r\n                    _ostype=linux-androideabi\r\n                else\r\n                    _ostype=\"${_ostype}eabihf\"\r\n                fi\r\n                ;;\r\n            riscv64gc)\r\n                err \"riscv64 with 32-bit userland unsupported\"\r\n                ;;\r\n        esac\r\n    fi\r\n\r\n    # Detect armv7 but without the CPU features Rust needs in that build,\r\n    # and fall back to arm.\r\n    # See https://github.com/rust-lang/rustup.rs/issues/587.\r\n    if [ \"$_ostype\" = \"unknown-linux-gnueabihf\" ] && [ \"$_cputype\" = armv7 ]; then\r\n        if ensure grep '^Features' /proc/cpuinfo | grep -q -v neon; then\r\n            # At least one processor does not have NEON.\r\n            _cputype=arm\r\n        fi\r\n    fi\r\n\r\n    _arch=\"${_cputype}-${_ostype}\"\r\n\r\n    RETVAL=\"$_arch\"\r\n}\r\n\r\nsay() {\r\n    printf 'rustup: %s\\n' \"$1\"\r\n}\r\n\r\nerr() {\r\n    say \"$1\" >&2\r\n    exit 1\r\n}\r\n\r\nneed_cmd() {\r\n    if ! check_cmd \"$1\"; then\r\n        err \"need '$1' (command not found)\"\r\n    fi\r\n}\r\n\r\ncheck_cmd() {\r\n    command -v \"$1\" > /dev/null 2>&1\r\n}\r\n\r\nassert_nz() {\r\n    if [ -z \"$1\" ]; then err \"assert_nz $2\"; fi\r\n}\r\n\r\n# Run a command that should never fail. If the command fails execution\r\n# will immediately terminate with an error showing the failing\r\n# command.\r\nensure() {\r\n    if ! \"$@\"; then err \"command failed: $*\"; fi\r\n}\r\n\r\n# This is just for indicating that commands' results are being\r\n# intentionally ignored. Usually, because it's being executed\r\n# as part of error handling.\r\nignore() {\r\n    \"$@\"\r\n}\r\n\r\n# This wraps curl or wget. Try curl first, if not installed,\r\n# use wget instead.\r\ndownloader() {\r\n    local _dld\r\n    local _ciphersuites\r\n    local _err\r\n    local _status\r\n    local _retry\r\n    if check_cmd curl; then\r\n        _dld=curl\r\n    elif check_cmd wget; then\r\n        _dld=wget\r\n    else\r\n        _dld='curl or wget' # to be used in error message of need_cmd\r\n    fi\r\n\r\n    if [ \"$1\" = --check ]; then\r\n        need_cmd \"$_dld\"\r\n    elif [ \"$_dld\" = curl ]; then\r\n        check_curl_for_retry_support\r\n        _retry=\"$RETVAL\"\r\n        get_ciphersuites_for_curl\r\n        _ciphersuites=\"$RETVAL\"\r\n        if [ -n \"$_ciphersuites\" ]; then\r\n            _err=$(curl $_retry --proto '=https' --tlsv1.2 --ciphers \"$_ciphersuites\" --silent --show-error --fail --location \"$1\" --output \"$2\" 2>&1)\r\n            _status=$?\r\n        else\r\n            echo \"Warning: Not enforcing strong cipher suites for TLS, this is potentially less secure\"\r\n            if ! check_help_for \"$3\" curl --proto --tlsv1.2; then\r\n                echo \"Warning: Not enforcing TLS v1.2, this is potentially less secure\"\r\n                _err=$(curl $_retry --silent --show-error --fail --location \"$1\" --output \"$2\" 2>&1)\r\n                _status=$?\r\n            else\r\n                _err=$(curl $_retry --proto '=https' --tlsv1.2 --silent --show-error --fail --location \"$1\" --output \"$2\" 2>&1)\r\n                _status=$?\r\n            fi\r\n        fi\r\n        if [ -n \"$_err\" ]; then\r\n            echo \"$_err\" >&2\r\n            if echo \"$_err\" | grep -q 404$; then\r\n                err \"installer for platform '$3' not found, this may be unsupported\"\r\n            fi\r\n        fi\r\n        return $_status\r\n    elif [ \"$_dld\" = wget ]; then\r\n        if [ \"$(wget -V 2>&1|head -2|tail -1|cut -f1 -d\" \")\" = \"BusyBox\" ]; then\r\n            echo \"Warning: using the BusyBox version of wget.  Not enforcing strong cipher suites for TLS or TLS v1.2, this is potentially less secure\"\r\n            _err=$(wget \"$1\" -O \"$2\" 2>&1)\r\n            _status=$?\r\n        else\r\n            get_ciphersuites_for_wget\r\n            _ciphersuites=\"$RETVAL\"\r\n            if [ -n \"$_ciphersuites\" ]; then\r\n                _err=$(wget --https-only --secure-protocol=TLSv1_2 --ciphers \"$_ciphersuites\" \"$1\" -O \"$2\" 2>&1)\r\n                _status=$?\r\n            else\r\n                echo \"Warning: Not enforcing strong cipher suites for TLS, this is potentially less secure\"\r\n                if ! check_help_for \"$3\" wget --https-only --secure-protocol; then\r\n                    echo \"Warning: Not enforcing TLS v1.2, this is potentially less secure\"\r\n                    _err=$(wget \"$1\" -O \"$2\" 2>&1)\r\n                    _status=$?\r\n                else\r\n                    _err=$(wget --https-only --secure-protocol=TLSv1_2 \"$1\" -O \"$2\" 2>&1)\r\n                    _status=$?\r\n                fi\r\n            fi\r\n        fi\r\n        if [ -n \"$_err\" ]; then\r\n            echo \"$_err\" >&2\r\n            if echo \"$_err\" | grep -q ' 404 Not Found$'; then\r\n                err \"installer for platform '$3' not found, this may be unsupported\"\r\n            fi\r\n        fi\r\n        return $_status\r\n    else\r\n        err \"Unknown downloader\"   # should not reach here\r\n    fi\r\n}\r\n\r\ncheck_help_for() {\r\n    local _arch\r\n    local _cmd\r\n    local _arg\r\n    _arch=\"$1\"\r\n    shift\r\n    _cmd=\"$1\"\r\n    shift\r\n\r\n    local _category\r\n    if \"$_cmd\" --help | grep -q 'For all options use the manual or \"--help all\".'; then\r\n      _category=\"all\"\r\n    else\r\n      _category=\"\"\r\n    fi\r\n\r\n    case \"$_arch\" in\r\n\r\n        *darwin*)\r\n        if check_cmd sw_vers; then\r\n            case $(sw_vers -productVersion) in\r\n                10.*)\r\n                    # If we're running on macOS, older than 10.13, then we always\r\n                    # fail to find these options to force fallback\r\n                    if [ \"$(sw_vers -productVersion | cut -d. -f2)\" -lt 13 ]; then\r\n                        # Older than 10.13\r\n                        echo \"Warning: Detected macOS platform older than 10.13\"\r\n                        return 1\r\n                    fi\r\n                    ;;\r\n                11.*)\r\n                    # We assume Big Sur will be OK for now\r\n                    ;;\r\n                *)\r\n                    # Unknown product version, warn and continue\r\n                    echo \"Warning: Detected unknown macOS major version: $(sw_vers -productVersion)\"\r\n                    echo \"Warning TLS capabilities detection may fail\"\r\n                    ;;\r\n            esac\r\n        fi\r\n        ;;\r\n\r\n    esac\r\n\r\n    for _arg in \"$@\"; do\r\n        if ! \"$_cmd\" --help $_category | grep -q -- \"$_arg\"; then\r\n            return 1\r\n        fi\r\n    done\r\n\r\n    true # not strictly needed\r\n}\r\n\r\n# Check if curl supports the --retry flag, then pass it to the curl invocation.\r\ncheck_curl_for_retry_support() {\r\n  local _retry_supported=\"\"\r\n  # \"unspecified\" is for arch, allows for possibility old OS using macports, homebrew, etc.\r\n  if check_help_for \"notspecified\" \"curl\" \"--retry\"; then\r\n    _retry_supported=\"--retry 3\"\r\n  fi\r\n\r\n  RETVAL=\"$_retry_supported\"\r\n\r\n}\r\n\r\n# Return cipher suite string specified by user, otherwise return strong TLS 1.2-1.3 cipher suites\r\n# if support by local tools is detected. Detection currently supports these curl backends:\r\n# GnuTLS and OpenSSL (possibly also LibreSSL and BoringSSL). Return value can be empty.\r\nget_ciphersuites_for_curl() {\r\n    if [ -n \"${RUSTUP_TLS_CIPHERSUITES-}\" ]; then\r\n        # user specified custom cipher suites, assume they know what they're doing\r\n        RETVAL=\"$RUSTUP_TLS_CIPHERSUITES\"\r\n        return\r\n    fi\r\n\r\n    local _openssl_syntax=\"no\"\r\n    local _gnutls_syntax=\"no\"\r\n    local _backend_supported=\"yes\"\r\n    if curl -V | grep -q ' OpenSSL/'; then\r\n        _openssl_syntax=\"yes\"\r\n    elif curl -V | grep -iq ' LibreSSL/'; then\r\n        _openssl_syntax=\"yes\"\r\n    elif curl -V | grep -iq ' BoringSSL/'; then\r\n        _openssl_syntax=\"yes\"\r\n    elif curl -V | grep -iq ' GnuTLS/'; then\r\n        _gnutls_syntax=\"yes\"\r\n    else\r\n        _backend_supported=\"no\"\r\n    fi\r\n\r\n    local _args_supported=\"no\"\r\n    if [ \"$_backend_supported\" = \"yes\" ]; then\r\n        # \"unspecified\" is for arch, allows for possibility old OS using macports, homebrew, etc.\r\n        if check_help_for \"notspecified\" \"curl\" \"--tlsv1.2\" \"--ciphers\" \"--proto\"; then\r\n            _args_supported=\"yes\"\r\n        fi\r\n    fi\r\n\r\n    local _cs=\"\"\r\n    if [ \"$_args_supported\" = \"yes\" ]; then\r\n        if [ \"$_openssl_syntax\" = \"yes\" ]; then\r\n            _cs=$(get_strong_ciphersuites_for \"openssl\")\r\n        elif [ \"$_gnutls_syntax\" = \"yes\" ]; then\r\n            _cs=$(get_strong_ciphersuites_for \"gnutls\")\r\n        fi\r\n    fi\r\n\r\n    RETVAL=\"$_cs\"\r\n}\r\n\r\n# Return cipher suite string specified by user, otherwise return strong TLS 1.2-1.3 cipher suites\r\n# if support by local tools is detected. Detection currently supports these wget backends:\r\n# GnuTLS and OpenSSL (possibly also LibreSSL and BoringSSL). Return value can be empty.\r\nget_ciphersuites_for_wget() {\r\n    if [ -n \"${RUSTUP_TLS_CIPHERSUITES-}\" ]; then\r\n        # user specified custom cipher suites, assume they know what they're doing\r\n        RETVAL=\"$RUSTUP_TLS_CIPHERSUITES\"\r\n        return\r\n    fi\r\n\r\n    local _cs=\"\"\r\n    if wget -V | grep -q '\\-DHAVE_LIBSSL'; then\r\n        # \"unspecified\" is for arch, allows for possibility old OS using macports, homebrew, etc.\r\n        if check_help_for \"notspecified\" \"wget\" \"TLSv1_2\" \"--ciphers\" \"--https-only\" \"--secure-protocol\"; then\r\n            _cs=$(get_strong_ciphersuites_for \"openssl\")\r\n        fi\r\n    elif wget -V | grep -q '\\-DHAVE_LIBGNUTLS'; then\r\n        # \"unspecified\" is for arch, allows for possibility old OS using macports, homebrew, etc.\r\n        if check_help_for \"notspecified\" \"wget\" \"TLSv1_2\" \"--ciphers\" \"--https-only\" \"--secure-protocol\"; then\r\n            _cs=$(get_strong_ciphersuites_for \"gnutls\")\r\n        fi\r\n    fi\r\n\r\n    RETVAL=\"$_cs\"\r\n}\r\n\r\n# Return strong TLS 1.2-1.3 cipher suites in OpenSSL or GnuTLS syntax. TLS 1.2\r\n# excludes non-ECDHE and non-AEAD cipher suites. DHE is excluded due to bad\r\n# DH params often found on servers (see RFC 7919). Sequence matches or is\r\n# similar to Firefox 68 ESR with weak cipher suites disabled via about:config.\r\n# $1 must be openssl or gnutls.\r\nget_strong_ciphersuites_for() {\r\n    if [ \"$1\" = \"openssl\" ]; then\r\n        # OpenSSL is forgiving of unknown values, no problems with TLS 1.3 values on versions that don't support it yet.\r\n        echo \"TLS_AES_128_GCM_SHA256:TLS_CHACHA20_POLY1305_SHA256:TLS_AES_256_GCM_SHA384:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384\"\r\n    elif [ \"$1\" = \"gnutls\" ]; then\r\n        # GnuTLS isn't forgiving of unknown values, so this may require a GnuTLS version that supports TLS 1.3 even if wget doesn't.\r\n        # Begin with SECURE128 (and higher) then remove/add to build cipher suites. Produces same 9 cipher suites as OpenSSL but in slightly different order.\r\n        echo \"SECURE128:-VERS-SSL3.0:-VERS-TLS1.0:-VERS-TLS1.1:-VERS-DTLS-ALL:-CIPHER-ALL:-MAC-ALL:-KX-ALL:+AEAD:+ECDHE-ECDSA:+ECDHE-RSA:+AES-128-GCM:+CHACHA20-POLY1305:+AES-256-GCM\"\r\n    fi\r\n}\r\n\r\nmain \"$@\" || exit 1\r\ncurl: (1) Protocol \"http\" not supported or disabled in libcurl\r\ncurl: (1) Protocol \"http\" not supported or disabled in libcurl", "stdout_lines": ["#!/bin/sh", "# shellcheck shell=dash", "", "# This is just a little script that can be downloaded from the internet to", "# install rustup. It just does platform detection, downloads the installer", "# and runs it.", "", "# It runs on Unix shells like {a,ba,da,k,z}sh. It uses the common `local`", "# extension. Note: Most shells limit `local` to 1 var per line, contra bash.", "", "if [ \"$KSH_VERSION\" = 'Version JM 93t+ 2010-03-05' ]; then", "    # The version of ksh93 that ships with many illumos systems does not", "    # support the \"local\" extension.  Print a message rather than fail in", "    # subtle ways later on:", "    echo 'rustup does not work with this ksh93 version; please try bash!' >&2", "    exit 1", "fi", "", "", "set -u", "", "# If RUSTUP_UPDATE_ROOT is unset or empty, default it.", "RUSTUP_UPDATE_ROOT=\"${RUSTUP_UPDATE_ROOT:-https://static.rust-lang.org/rustup}\"", "", "#XXX: If you change anything here, please make the same changes in setup_mode.rs", "usage() {", "    cat 1>&2 <<EOF", "rustup-init 1.25.1 (48d233f65 2022-07-12)", "The installer for rustup", "", "USAGE:", "    rustup-init [FLAGS] [OPTIONS]", "", "FLAGS:", "    -v, --verbose           Enable verbose output", "    -q, --quiet             Disable progress output", "    -y                      Disable confirmation prompt.", "        --no-modify-path    Don't configure the PATH environment variable", "    -h, --help              Prints help information", "    -V, --version           Prints version information", "", "OPTIONS:", "        --default-host <default-host>              Choose a default host triple", "        --default-toolchain <default-toolchain>    Choose a default toolchain to install", "        --default-toolchain none                   Do not install any toolchains", "        --profile [minimal|default|complete]       Choose a profile", "    -c, --component <components>...                Component name to also install", "    -t, --target <targets>...                      Target name to also install", "EOF", "}", "", "main() {", "    downloader --check", "    need_cmd uname", "    need_cmd mktemp", "    need_cmd chmod", "    need_cmd mkdir", "    need_cmd rm", "    need_cmd rmdir", "", "    get_architecture || return 1", "    local _arch=\"$RETVAL\"", "    assert_nz \"$_arch\" \"arch\"", "", "    local _ext=\"\"", "    case \"$_arch\" in", "        *windows*)", "            _ext=\".exe\"", "            ;;", "    esac", "", "    local _url=\"${RUSTUP_UPDATE_ROOT}/dist/${_arch}/rustup-init${_ext}\"", "", "    local _dir", "    _dir=\"$(ensure mktemp -d)\"", "    local _file=\"${_dir}/rustup-init${_ext}\"", "", "    local _ansi_escapes_are_valid=false", "    if [ -t 2 ]; then", "        if [ \"${TERM+set}\" = 'set' ]; then", "            case \"$TERM\" in", "                xterm*|rxvt*|urxvt*|linux*|vt*)", "                    _ansi_escapes_are_valid=true", "                ;;", "            esac", "        fi", "    fi", "", "    # check if we have to use /dev/tty to prompt the user", "    local need_tty=yes", "    for arg in \"$@\"; do", "        case \"$arg\" in", "            --help)", "                usage", "                exit 0", "                ;;", "            *)", "                OPTIND=1", "                if [ \"${arg%%--*}\" = \"\" ]; then", "                    # Long option (other than --help);", "                    # don't attempt to interpret it.", "                    continue", "                fi", "                while getopts :hy sub_arg \"$arg\"; do", "                    case \"$sub_arg\" in", "                        h)", "                            usage", "                            exit 0", "                            ;;", "                        y)", "                            # user wants to skip the prompt --", "                            # we don't need /dev/tty", "                            need_tty=no", "                            ;;", "                        *)", "                            ;;", "                        esac", "                done", "                ;;", "        esac", "    done", "", "    if $_ansi_escapes_are_valid; then", "        printf \"\\33[1minfo:\\33[0m downloading installer\\n\" 1>&2", "    else", "        printf '%s\\n' 'info: downloading installer' 1>&2", "    fi", "", "    ensure mkdir -p \"$_dir\"", "    ensure downloader \"$_url\" \"$_file\" \"$_arch\"", "    ensure chmod u+x \"$_file\"", "    if [ ! -x \"$_file\" ]; then", "        printf '%s\\n' \"Cannot execute $_file (likely because of mounting /tmp as noexec).\" 1>&2", "        printf '%s\\n' \"Please copy the file to a location where you can execute binaries and run ./rustup-init${_ext}.\" 1>&2", "        exit 1", "    fi", "", "    if [ \"$need_tty\" = \"yes\" ] && [ ! -t 0 ]; then", "        # The installer is going to want to ask for confirmation by", "        # reading stdin.  This script was piped into `sh` though and", "        # doesn't have stdin to pass to its children. Instead we're going", "        # to explicitly connect /dev/tty to the installer's stdin.", "        if [ ! -t 1 ]; then", "            err \"Unable to run interactively. Run with -y to accept defaults, --help for additional options\"", "        fi", "", "        ignore \"$_file\" \"$@\" < /dev/tty", "    else", "        ignore \"$_file\" \"$@\"", "    fi", "", "    local _retval=$?", "", "    ignore rm \"$_file\"", "    ignore rmdir \"$_dir\"", "", "    return \"$_retval\"", "}", "", "check_proc() {", "    # Check for /proc by looking for the /proc/self/exe link", "    # This is only run on Linux", "    if ! test -L /proc/self/exe ; then", "        err \"fatal: Unable to find /proc/self/exe.  Is /proc mounted?  Installation cannot proceed without /proc.\"", "    fi", "}", "", "get_bitness() {", "    need_cmd head", "    # Architecture detection without dependencies beyond coreutils.", "    # ELF files start out \"\\x7fELF\", and the following byte is", "    #   0x01 for 32-bit and", "    #   0x02 for 64-bit.", "    # The printf builtin on some shells like dash only supports octal", "    # escape sequences, so we use those.", "    local _current_exe_head", "    _current_exe_head=$(head -c 5 /proc/self/exe )", "    if [ \"$_current_exe_head\" = \"$(printf '\\177ELF\\001')\" ]; then", "        echo 32", "    elif [ \"$_current_exe_head\" = \"$(printf '\\177ELF\\002')\" ]; then", "        echo 64", "    else", "        err \"unknown platform bitness\"", "    fi", "}", "", "is_host_amd64_elf() {", "    need_cmd head", "    need_cmd tail", "    # ELF e_machine detection without dependencies beyond coreutils.", "    # Two-byte field at offset 0x12 indicates the CPU,", "    # but we're interested in it being 0x3E to indicate amd64, or not that.", "    local _current_exe_machine", "    _current_exe_machine=$(head -c 19 /proc/self/exe | tail -c 1)", "    [ \"$_current_exe_machine\" = \"$(printf '\\076')\" ]", "}", "", "get_endianness() {", "    local cputype=$1", "    local suffix_eb=$2", "    local suffix_el=$3", "", "    # detect endianness without od/hexdump, like get_bitness() does.", "    need_cmd head", "    need_cmd tail", "", "    local _current_exe_endianness", "    _current_exe_endianness=\"$(head -c 6 /proc/self/exe | tail -c 1)\"", "    if [ \"$_current_exe_endianness\" = \"$(printf '\\001')\" ]; then", "        echo \"${cputype}${suffix_el}\"", "    elif [ \"$_current_exe_endianness\" = \"$(printf '\\002')\" ]; then", "        echo \"${cputype}${suffix_eb}\"", "    else", "        err \"unknown platform endianness\"", "    fi", "}", "", "get_architecture() {", "    local _ostype _cputype _bitness _arch _clibtype", "    _ostype=\"$(uname -s)\"", "    _cputype=\"$(uname -m)\"", "    _clibtype=\"gnu\"", "", "    if [ \"$_ostype\" = Linux ]; then", "        if [ \"$(uname -o)\" = Android ]; then", "            _ostype=Android", "        fi", "        if ldd --version 2>&1 | grep -q 'musl'; then", "            _clibtype=\"musl\"", "        fi", "    fi", "", "    if [ \"$_ostype\" = Darwin ] && [ \"$_cputype\" = i386 ]; then", "        # Darwin `uname -m` lies", "        if sysctl hw.optional.x86_64 | grep -q ': 1'; then", "            _cputype=x86_64", "        fi", "    fi", "", "    if [ \"$_ostype\" = SunOS ]; then", "        # Both Solaris and illumos presently announce as \"SunOS\" in \"uname -s\"", "        # so use \"uname -o\" to disambiguate.  We use the full path to the", "        # system uname in case the user has coreutils uname first in PATH,", "        # which has historically sometimes printed the wrong value here.", "        if [ \"$(/usr/bin/uname -o)\" = illumos ]; then", "            _ostype=illumos", "        fi", "", "        # illumos systems have multi-arch userlands, and \"uname -m\" reports the", "        # machine hardware name; e.g., \"i86pc\" on both 32- and 64-bit x86", "        # systems.  Check for the native (widest) instruction set on the", "        # running kernel:", "        if [ \"$_cputype\" = i86pc ]; then", "            _cputype=\"$(isainfo -n)\"", "        fi", "    fi", "", "    case \"$_ostype\" in", "", "        Android)", "            _ostype=linux-android", "            ;;", "", "        Linux)", "            check_proc", "            _ostype=unknown-linux-$_clibtype", "            _bitness=$(get_bitness)", "            ;;", "", "        FreeBSD)", "            _ostype=unknown-freebsd", "            ;;", "", "        NetBSD)", "            _ostype=unknown-netbsd", "            ;;", "", "        DragonFly)", "            _ostype=unknown-dragonfly", "            ;;", "", "        Darwin)", "            _ostype=apple-darwin", "            ;;", "", "        illumos)", "            _ostype=unknown-illumos", "            ;;", "", "        MINGW* | MSYS* | CYGWIN* | Windows_NT)", "            _ostype=pc-windows-gnu", "            ;;", "", "        *)", "            err \"unrecognized OS type: $_ostype\"", "            ;;", "", "    esac", "", "    case \"$_cputype\" in", "", "        i386 | i486 | i686 | i786 | x86)", "            _cputype=i686", "            ;;", "", "        xscale | arm)", "            _cputype=arm", "            if [ \"$_ostype\" = \"linux-android\" ]; then", "                _ostype=linux-androideabi", "            fi", "            ;;", "", "        armv6l)", "            _cputype=arm", "            if [ \"$_ostype\" = \"linux-android\" ]; then", "                _ostype=linux-androideabi", "            else", "                _ostype=\"${_ostype}eabihf\"", "            fi", "            ;;", "", "        armv7l | armv8l)", "            _cputype=armv7", "            if [ \"$_ostype\" = \"linux-android\" ]; then", "                _ostype=linux-androideabi", "            else", "                _ostype=\"${_ostype}eabihf\"", "            fi", "            ;;", "", "        aarch64 | arm64)", "            _cputype=aarch64", "            ;;", "", "        x86_64 | x86-64 | x64 | amd64)", "            _cputype=x86_64", "            ;;", "", "        mips)", "            _cputype=$(get_endianness mips '' el)", "            ;;", "", "        mips64)", "            if [ \"$_bitness\" -eq 64 ]; then", "                # only n64 ABI is supported for now", "                _ostype=\"${_ostype}abi64\"", "                _cputype=$(get_endianness mips64 '' el)", "            fi", "            ;;", "", "        ppc)", "            _cputype=powerpc", "            ;;", "", "        ppc64)", "            _cputype=powerpc64", "            ;;", "", "        ppc64le)", "            _cputype=powerpc64le", "            ;;", "", "        s390x)", "            _cputype=s390x", "            ;;", "        riscv64)", "            _cputype=riscv64gc", "            ;;", "        *)", "            err \"unknown CPU type: $_cputype\"", "", "    esac", "", "    # Detect 64-bit linux with 32-bit userland", "    if [ \"${_ostype}\" = unknown-linux-gnu ] && [ \"${_bitness}\" -eq 32 ]; then", "        case $_cputype in", "            x86_64)", "                if [ -n \"${RUSTUP_CPUTYPE:-}\" ]; then", "                    _cputype=\"$RUSTUP_CPUTYPE\"", "                else {", "                    # 32-bit executable for amd64 = x32", "                    if is_host_amd64_elf; then {", "                         echo \"This host is running an x32 userland; as it stands, x32 support is poor,\" 1>&2", "                         echo \"and there isn't a native toolchain -- you will have to install\" 1>&2", "                         echo \"multiarch compatibility with i686 and/or amd64, then select one\" 1>&2", "                         echo \"by re-running this script with the RUSTUP_CPUTYPE environment variable\" 1>&2", "                         echo \"set to i686 or x86_64, respectively.\" 1>&2", "                         echo 1>&2", "                         echo \"You will be able to add an x32 target after installation by running\" 1>&2", "                         echo \"  rustup target add x86_64-unknown-linux-gnux32\" 1>&2", "                         exit 1", "                    }; else", "                        _cputype=i686", "                    fi", "                }; fi", "                ;;", "            mips64)", "                _cputype=$(get_endianness mips '' el)", "                ;;", "            powerpc64)", "                _cputype=powerpc", "                ;;", "            aarch64)", "                _cputype=armv7", "                if [ \"$_ostype\" = \"linux-android\" ]; then", "                    _ostype=linux-androideabi", "                else", "                    _ostype=\"${_ostype}eabihf\"", "                fi", "                ;;", "            riscv64gc)", "                err \"riscv64 with 32-bit userland unsupported\"", "                ;;", "        esac", "    fi", "", "    # Detect armv7 but without the CPU features Rust needs in that build,", "    # and fall back to arm.", "    # See https://github.com/rust-lang/rustup.rs/issues/587.", "    if [ \"$_ostype\" = \"unknown-linux-gnueabihf\" ] && [ \"$_cputype\" = armv7 ]; then", "        if ensure grep '^Features' /proc/cpuinfo | grep -q -v neon; then", "            # At least one processor does not have NEON.", "            _cputype=arm", "        fi", "    fi", "", "    _arch=\"${_cputype}-${_ostype}\"", "", "    RETVAL=\"$_arch\"", "}", "", "say() {", "    printf 'rustup: %s\\n' \"$1\"", "}", "", "err() {", "    say \"$1\" >&2", "    exit 1", "}", "", "need_cmd() {", "    if ! check_cmd \"$1\"; then", "        err \"need '$1' (command not found)\"", "    fi", "}", "", "check_cmd() {", "    command -v \"$1\" > /dev/null 2>&1", "}", "", "assert_nz() {", "    if [ -z \"$1\" ]; then err \"assert_nz $2\"; fi", "}", "", "# Run a command that should never fail. If the command fails execution", "# will immediately terminate with an error showing the failing", "# command.", "ensure() {", "    if ! \"$@\"; then err \"command failed: $*\"; fi", "}", "", "# This is just for indicating that commands' results are being", "# intentionally ignored. Usually, because it's being executed", "# as part of error handling.", "ignore() {", "    \"$@\"", "}", "", "# This wraps curl or wget. Try curl first, if not installed,", "# use wget instead.", "downloader() {", "    local _dld", "    local _ciphersuites", "    local _err", "    local _status", "    local _retry", "    if check_cmd curl; then", "        _dld=curl", "    elif check_cmd wget; then", "        _dld=wget", "    else", "        _dld='curl or wget' # to be used in error message of need_cmd", "    fi", "", "    if [ \"$1\" = --check ]; then", "        need_cmd \"$_dld\"", "    elif [ \"$_dld\" = curl ]; then", "        check_curl_for_retry_support", "        _retry=\"$RETVAL\"", "        get_ciphersuites_for_curl", "        _ciphersuites=\"$RETVAL\"", "        if [ -n \"$_ciphersuites\" ]; then", "            _err=$(curl $_retry --proto '=https' --tlsv1.2 --ciphers \"$_ciphersuites\" --silent --show-error --fail --location \"$1\" --output \"$2\" 2>&1)", "            _status=$?", "        else", "            echo \"Warning: Not enforcing strong cipher suites for TLS, this is potentially less secure\"", "            if ! check_help_for \"$3\" curl --proto --tlsv1.2; then", "                echo \"Warning: Not enforcing TLS v1.2, this is potentially less secure\"", "                _err=$(curl $_retry --silent --show-error --fail --location \"$1\" --output \"$2\" 2>&1)", "                _status=$?", "            else", "                _err=$(curl $_retry --proto '=https' --tlsv1.2 --silent --show-error --fail --location \"$1\" --output \"$2\" 2>&1)", "                _status=$?", "            fi", "        fi", "        if [ -n \"$_err\" ]; then", "            echo \"$_err\" >&2", "            if echo \"$_err\" | grep -q 404$; then", "                err \"installer for platform '$3' not found, this may be unsupported\"", "            fi", "        fi", "        return $_status", "    elif [ \"$_dld\" = wget ]; then", "        if [ \"$(wget -V 2>&1|head -2|tail -1|cut -f1 -d\" \")\" = \"BusyBox\" ]; then", "            echo \"Warning: using the BusyBox version of wget.  Not enforcing strong cipher suites for TLS or TLS v1.2, this is potentially less secure\"", "            _err=$(wget \"$1\" -O \"$2\" 2>&1)", "            _status=$?", "        else", "            get_ciphersuites_for_wget", "            _ciphersuites=\"$RETVAL\"", "            if [ -n \"$_ciphersuites\" ]; then", "                _err=$(wget --https-only --secure-protocol=TLSv1_2 --ciphers \"$_ciphersuites\" \"$1\" -O \"$2\" 2>&1)", "                _status=$?", "            else", "                echo \"Warning: Not enforcing strong cipher suites for TLS, this is potentially less secure\"", "                if ! check_help_for \"$3\" wget --https-only --secure-protocol; then", "                    echo \"Warning: Not enforcing TLS v1.2, this is potentially less secure\"", "                    _err=$(wget \"$1\" -O \"$2\" 2>&1)", "                    _status=$?", "                else", "                    _err=$(wget --https-only --secure-protocol=TLSv1_2 \"$1\" -O \"$2\" 2>&1)", "                    _status=$?", "                fi", "            fi", "        fi", "        if [ -n \"$_err\" ]; then", "            echo \"$_err\" >&2", "            if echo \"$_err\" | grep -q ' 404 Not Found$'; then", "                err \"installer for platform '$3' not found, this may be unsupported\"", "            fi", "        fi", "        return $_status", "    else", "        err \"Unknown downloader\"   # should not reach here", "    fi", "}", "", "check_help_for() {", "    local _arch", "    local _cmd", "    local _arg", "    _arch=\"$1\"", "    shift", "    _cmd=\"$1\"", "    shift", "", "    local _category", "    if \"$_cmd\" --help | grep -q 'For all options use the manual or \"--help all\".'; then", "      _category=\"all\"", "    else", "      _category=\"\"", "    fi", "", "    case \"$_arch\" in", "", "        *darwin*)", "        if check_cmd sw_vers; then", "            case $(sw_vers -productVersion) in", "                10.*)", "                    # If we're running on macOS, older than 10.13, then we always", "                    # fail to find these options to force fallback", "                    if [ \"$(sw_vers -productVersion | cut -d. -f2)\" -lt 13 ]; then", "                        # Older than 10.13", "                        echo \"Warning: Detected macOS platform older than 10.13\"", "                        return 1", "                    fi", "                    ;;", "                11.*)", "                    # We assume Big Sur will be OK for now", "                    ;;", "                *)", "                    # Unknown product version, warn and continue", "                    echo \"Warning: Detected unknown macOS major version: $(sw_vers -productVersion)\"", "                    echo \"Warning TLS capabilities detection may fail\"", "                    ;;", "            esac", "        fi", "        ;;", "", "    esac", "", "    for _arg in \"$@\"; do", "        if ! \"$_cmd\" --help $_category | grep -q -- \"$_arg\"; then", "            return 1", "        fi", "    done", "", "    true # not strictly needed", "}", "", "# Check if curl supports the --retry flag, then pass it to the curl invocation.", "check_curl_for_retry_support() {", "  local _retry_supported=\"\"", "  # \"unspecified\" is for arch, allows for possibility old OS using macports, homebrew, etc.", "  if check_help_for \"notspecified\" \"curl\" \"--retry\"; then", "    _retry_supported=\"--retry 3\"", "  fi", "", "  RETVAL=\"$_retry_supported\"", "", "}", "", "# Return cipher suite string specified by user, otherwise return strong TLS 1.2-1.3 cipher suites", "# if support by local tools is detected. Detection currently supports these curl backends:", "# GnuTLS and OpenSSL (possibly also LibreSSL and BoringSSL). Return value can be empty.", "get_ciphersuites_for_curl() {", "    if [ -n \"${RUSTUP_TLS_CIPHERSUITES-}\" ]; then", "        # user specified custom cipher suites, assume they know what they're doing", "        RETVAL=\"$RUSTUP_TLS_CIPHERSUITES\"", "        return", "    fi", "", "    local _openssl_syntax=\"no\"", "    local _gnutls_syntax=\"no\"", "    local _backend_supported=\"yes\"", "    if curl -V | grep -q ' OpenSSL/'; then", "        _openssl_syntax=\"yes\"", "    elif curl -V | grep -iq ' LibreSSL/'; then", "        _openssl_syntax=\"yes\"", "    elif curl -V | grep -iq ' BoringSSL/'; then", "        _openssl_syntax=\"yes\"", "    elif curl -V | grep -iq ' GnuTLS/'; then", "        _gnutls_syntax=\"yes\"", "    else", "        _backend_supported=\"no\"", "    fi", "", "    local _args_supported=\"no\"", "    if [ \"$_backend_supported\" = \"yes\" ]; then", "        # \"unspecified\" is for arch, allows for possibility old OS using macports, homebrew, etc.", "        if check_help_for \"notspecified\" \"curl\" \"--tlsv1.2\" \"--ciphers\" \"--proto\"; then", "            _args_supported=\"yes\"", "        fi", "    fi", "", "    local _cs=\"\"", "    if [ \"$_args_supported\" = \"yes\" ]; then", "        if [ \"$_openssl_syntax\" = \"yes\" ]; then", "            _cs=$(get_strong_ciphersuites_for \"openssl\")", "        elif [ \"$_gnutls_syntax\" = \"yes\" ]; then", "            _cs=$(get_strong_ciphersuites_for \"gnutls\")", "        fi", "    fi", "", "    RETVAL=\"$_cs\"", "}", "", "# Return cipher suite string specified by user, otherwise return strong TLS 1.2-1.3 cipher suites", "# if support by local tools is detected. Detection currently supports these wget backends:", "# GnuTLS and OpenSSL (possibly also LibreSSL and BoringSSL). Return value can be empty.", "get_ciphersuites_for_wget() {", "    if [ -n \"${RUSTUP_TLS_CIPHERSUITES-}\" ]; then", "        # user specified custom cipher suites, assume they know what they're doing", "        RETVAL=\"$RUSTUP_TLS_CIPHERSUITES\"", "        return", "    fi", "", "    local _cs=\"\"", "    if wget -V | grep -q '\\-DHAVE_LIBSSL'; then", "        # \"unspecified\" is for arch, allows for possibility old OS using macports, homebrew, etc.", "        if check_help_for \"notspecified\" \"wget\" \"TLSv1_2\" \"--ciphers\" \"--https-only\" \"--secure-protocol\"; then", "            _cs=$(get_strong_ciphersuites_for \"openssl\")", "        fi", "    elif wget -V | grep -q '\\-DHAVE_LIBGNUTLS'; then", "        # \"unspecified\" is for arch, allows for possibility old OS using macports, homebrew, etc.", "        if check_help_for \"notspecified\" \"wget\" \"TLSv1_2\" \"--ciphers\" \"--https-only\" \"--secure-protocol\"; then", "            _cs=$(get_strong_ciphersuites_for \"gnutls\")", "        fi", "    fi", "", "    RETVAL=\"$_cs\"", "}", "", "# Return strong TLS 1.2-1.3 cipher suites in OpenSSL or GnuTLS syntax. TLS 1.2", "# excludes non-ECDHE and non-AEAD cipher suites. DHE is excluded due to bad", "# DH params often found on servers (see RFC 7919). Sequence matches or is", "# similar to Firefox 68 ESR with weak cipher suites disabled via about:config.", "# $1 must be openssl or gnutls.", "get_strong_ciphersuites_for() {", "    if [ \"$1\" = \"openssl\" ]; then", "        # OpenSSL is forgiving of unknown values, no problems with TLS 1.3 values on versions that don't support it yet.", "        echo \"TLS_AES_128_GCM_SHA256:TLS_CHACHA20_POLY1305_SHA256:TLS_AES_256_GCM_SHA384:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384\"", "    elif [ \"$1\" = \"gnutls\" ]; then", "        # GnuTLS isn't forgiving of unknown values, so this may require a GnuTLS version that supports TLS 1.3 even if wget doesn't.", "        # Begin with SECURE128 (and higher) then remove/add to build cipher suites. Produces same 9 cipher suites as OpenSSL but in slightly different order.", "        echo \"SECURE128:-VERS-SSL3.0:-VERS-TLS1.0:-VERS-TLS1.1:-VERS-DTLS-ALL:-CIPHER-ALL:-MAC-ALL:-KX-ALL:+AEAD:+ECDHE-ECDSA:+ECDHE-RSA:+AES-128-GCM:+CHACHA20-POLY1305:+AES-256-GCM\"", "    fi", "}", "", "main \"$@\" || exit 1", "curl: (1) Protocol \"http\" not supported or disabled in libcurl", "curl: (1) Protocol \"http\" not supported or disabled in libcurl"]}
2022-12-30 00:01:33,039 p=87304 u=kal n=ansible | PLAY RECAP *******************************************************************************************************************************************
2022-12-30 00:01:33,040 p=87304 u=kal n=ansible | krpz                       : ok=3    changed=0    unreachable=0    failed=1    skipped=0    rescued=0    ignored=0   
2022-12-30 00:02:43,961 p=87655 u=kal n=ansible | Using /home/kal/MyApplications/dotfiles/playbooks/ansible.cfg as config file
2022-12-30 00:02:44,035 p=87655 u=kal n=ansible | PLAY [localhost] *************************************************************************************************************************************
2022-12-30 00:02:44,042 p=87655 u=kal n=ansible | TASK [Gathering Facts] *******************************************************************************************************************************
2022-12-30 00:02:47,948 p=87655 u=kal n=ansible | ok: [krpz]
2022-12-30 00:02:47,972 p=87655 u=kal n=ansible | TASK [install pexpect] *******************************************************************************************************************************
2022-12-30 00:02:48,400 p=87655 u=kal n=ansible | ok: [krpz] => {"changed": false, "cmd": ["/usr/bin/python2", "-m", "pip.__main__", "install", "pexpect"], "name": ["pexpect"], "requirements": null, "state": "present", "stderr": "DEPRECATION: Python 2.7 reached the end of its life on January 1st, 2020. Please upgrade your Python as Python 2.7 is no longer maintained. pip 21.0 will drop support for Python 2.7 in January 2021. More details about Python 2 support in pip can be found at https://pip.pypa.io/en/latest/development/release-process/#python-2-support pip 21.0 will remove support for this functionality.\n", "stderr_lines": ["DEPRECATION: Python 2.7 reached the end of its life on January 1st, 2020. Please upgrade your Python as Python 2.7 is no longer maintained. pip 21.0 will drop support for Python 2.7 in January 2021. More details about Python 2 support in pip can be found at https://pip.pypa.io/en/latest/development/release-process/#python-2-support pip 21.0 will remove support for this functionality."], "stdout": "Requirement already satisfied: pexpect in /usr/local/lib/python2.7/dist-packages (4.8.0)\nRequirement already satisfied: ptyprocess>=0.5 in /usr/local/lib/python2.7/dist-packages (from pexpect) (0.7.0)\n", "stdout_lines": ["Requirement already satisfied: pexpect in /usr/local/lib/python2.7/dist-packages (4.8.0)", "Requirement already satisfied: ptyprocess>=0.5 in /usr/local/lib/python2.7/dist-packages (from pexpect) (0.7.0)"], "version": null, "virtualenv": null}
2022-12-30 00:02:48,408 p=87655 u=kal n=ansible | TASK [install setuptools] ****************************************************************************************************************************
2022-12-30 00:02:48,753 p=87655 u=kal n=ansible | ok: [krpz] => {"changed": false, "cmd": ["/usr/bin/python2", "-m", "pip.__main__", "install", "setuptools"], "name": ["setuptools"], "requirements": null, "state": "present", "stderr": "DEPRECATION: Python 2.7 reached the end of its life on January 1st, 2020. Please upgrade your Python as Python 2.7 is no longer maintained. pip 21.0 will drop support for Python 2.7 in January 2021. More details about Python 2 support in pip can be found at https://pip.pypa.io/en/latest/development/release-process/#python-2-support pip 21.0 will remove support for this functionality.\n", "stderr_lines": ["DEPRECATION: Python 2.7 reached the end of its life on January 1st, 2020. Please upgrade your Python as Python 2.7 is no longer maintained. pip 21.0 will drop support for Python 2.7 in January 2021. More details about Python 2 support in pip can be found at https://pip.pypa.io/en/latest/development/release-process/#python-2-support pip 21.0 will remove support for this functionality."], "stdout": "Requirement already satisfied: setuptools in /usr/lib/python2.7/dist-packages (44.1.1)\n", "stdout_lines": ["Requirement already satisfied: setuptools in /usr/lib/python2.7/dist-packages (44.1.1)"], "version": null, "virtualenv": null}
2022-12-30 00:02:48,761 p=87655 u=kal n=ansible | TASK [Install Rust] **********************************************************************************************************************************
2022-12-30 00:02:49,314 p=87655 u=kal n=ansible | fatal: [krpz]: FAILED! => {"changed": true, "cmd": "curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh", "delta": "0:00:00.334657", "end": "2022-12-30 00:02:49.258508", "msg": "non-zero return code", "rc": 1, "start": "2022-12-30 00:02:48.923851", "stdout": "#!/bin/sh\r\n# shellcheck shell=dash\r\n\r\n# This is just a little script that can be downloaded from the internet to\r\n# install rustup. It just does platform detection, downloads the installer\r\n# and runs it.\r\n\r\n# It runs on Unix shells like {a,ba,da,k,z}sh. It uses the common `local`\r\n# extension. Note: Most shells limit `local` to 1 var per line, contra bash.\r\n\r\nif [ \"$KSH_VERSION\" = 'Version JM 93t+ 2010-03-05' ]; then\r\n    # The version of ksh93 that ships with many illumos systems does not\r\n    # support the \"local\" extension.  Print a message rather than fail in\r\n    # subtle ways later on:\r\n    echo 'rustup does not work with this ksh93 version; please try bash!' >&2\r\n    exit 1\r\nfi\r\n\r\n\r\nset -u\r\n\r\n# If RUSTUP_UPDATE_ROOT is unset or empty, default it.\r\nRUSTUP_UPDATE_ROOT=\"${RUSTUP_UPDATE_ROOT:-https://static.rust-lang.org/rustup}\"\r\n\r\n#XXX: If you change anything here, please make the same changes in setup_mode.rs\r\nusage() {\r\n    cat 1>&2 <<EOF\r\nrustup-init 1.25.1 (48d233f65 2022-07-12)\r\nThe installer for rustup\r\n\r\nUSAGE:\r\n    rustup-init [FLAGS] [OPTIONS]\r\n\r\nFLAGS:\r\n    -v, --verbose           Enable verbose output\r\n    -q, --quiet             Disable progress output\r\n    -y                      Disable confirmation prompt.\r\n        --no-modify-path    Don't configure the PATH environment variable\r\n    -h, --help              Prints help information\r\n    -V, --version           Prints version information\r\n\r\nOPTIONS:\r\n        --default-host <default-host>              Choose a default host triple\r\n        --default-toolchain <default-toolchain>    Choose a default toolchain to install\r\n        --default-toolchain none                   Do not install any toolchains\r\n        --profile [minimal|default|complete]       Choose a profile\r\n    -c, --component <components>...                Component name to also install\r\n    -t, --target <targets>...                      Target name to also install\r\nEOF\r\n}\r\n\r\nmain() {\r\n    downloader --check\r\n    need_cmd uname\r\n    need_cmd mktemp\r\n    need_cmd chmod\r\n    need_cmd mkdir\r\n    need_cmd rm\r\n    need_cmd rmdir\r\n\r\n    get_architecture || return 1\r\n    local _arch=\"$RETVAL\"\r\n    assert_nz \"$_arch\" \"arch\"\r\n\r\n    local _ext=\"\"\r\n    case \"$_arch\" in\r\n        *windows*)\r\n            _ext=\".exe\"\r\n            ;;\r\n    esac\r\n\r\n    local _url=\"${RUSTUP_UPDATE_ROOT}/dist/${_arch}/rustup-init${_ext}\"\r\n\r\n    local _dir\r\n    _dir=\"$(ensure mktemp -d)\"\r\n    local _file=\"${_dir}/rustup-init${_ext}\"\r\n\r\n    local _ansi_escapes_are_valid=false\r\n    if [ -t 2 ]; then\r\n        if [ \"${TERM+set}\" = 'set' ]; then\r\n            case \"$TERM\" in\r\n                xterm*|rxvt*|urxvt*|linux*|vt*)\r\n                    _ansi_escapes_are_valid=true\r\n                ;;\r\n            esac\r\n        fi\r\n    fi\r\n\r\n    # check if we have to use /dev/tty to prompt the user\r\n    local need_tty=yes\r\n    for arg in \"$@\"; do\r\n        case \"$arg\" in\r\n            --help)\r\n                usage\r\n                exit 0\r\n                ;;\r\n            *)\r\n                OPTIND=1\r\n                if [ \"${arg%%--*}\" = \"\" ]; then\r\n                    # Long option (other than --help);\r\n                    # don't attempt to interpret it.\r\n                    continue\r\n                fi\r\n                while getopts :hy sub_arg \"$arg\"; do\r\n                    case \"$sub_arg\" in\r\n                        h)\r\n                            usage\r\n                            exit 0\r\n                            ;;\r\n                        y)\r\n                            # user wants to skip the prompt --\r\n                            # we don't need /dev/tty\r\n                            need_tty=no\r\n                            ;;\r\n                        *)\r\n                            ;;\r\n                        esac\r\n                done\r\n                ;;\r\n        esac\r\n    done\r\n\r\n    if $_ansi_escapes_are_valid; then\r\n        printf \"\\33[1minfo:\\33[0m downloading installer\\n\" 1>&2\r\n    else\r\n        printf '%s\\n' 'info: downloading installer' 1>&2\r\n    fi\r\n\r\n    ensure mkdir -p \"$_dir\"\r\n    ensure downloader \"$_url\" \"$_file\" \"$_arch\"\r\n    ensure chmod u+x \"$_file\"\r\n    if [ ! -x \"$_file\" ]; then\r\n        printf '%s\\n' \"Cannot execute $_file (likely because of mounting /tmp as noexec).\" 1>&2\r\n        printf '%s\\n' \"Please copy the file to a location where you can execute binaries and run ./rustup-init${_ext}.\" 1>&2\r\n        exit 1\r\n    fi\r\n\r\n    if [ \"$need_tty\" = \"yes\" ] && [ ! -t 0 ]; then\r\n        # The installer is going to want to ask for confirmation by\r\n        # reading stdin.  This script was piped into `sh` though and\r\n        # doesn't have stdin to pass to its children. Instead we're going\r\n        # to explicitly connect /dev/tty to the installer's stdin.\r\n        if [ ! -t 1 ]; then\r\n            err \"Unable to run interactively. Run with -y to accept defaults, --help for additional options\"\r\n        fi\r\n\r\n        ignore \"$_file\" \"$@\" < /dev/tty\r\n    else\r\n        ignore \"$_file\" \"$@\"\r\n    fi\r\n\r\n    local _retval=$?\r\n\r\n    ignore rm \"$_file\"\r\n    ignore rmdir \"$_dir\"\r\n\r\n    return \"$_retval\"\r\n}\r\n\r\ncheck_proc() {\r\n    # Check for /proc by looking for the /proc/self/exe link\r\n    # This is only run on Linux\r\n    if ! test -L /proc/self/exe ; then\r\n        err \"fatal: Unable to find /proc/self/exe.  Is /proc mounted?  Installation cannot proceed without /proc.\"\r\n    fi\r\n}\r\n\r\nget_bitness() {\r\n    need_cmd head\r\n    # Architecture detection without dependencies beyond coreutils.\r\n    # ELF files start out \"\\x7fELF\", and the following byte is\r\n    #   0x01 for 32-bit and\r\n    #   0x02 for 64-bit.\r\n    # The printf builtin on some shells like dash only supports octal\r\n    # escape sequences, so we use those.\r\n    local _current_exe_head\r\n    _current_exe_head=$(head -c 5 /proc/self/exe )\r\n    if [ \"$_current_exe_head\" = \"$(printf '\\177ELF\\001')\" ]; then\r\n        echo 32\r\n    elif [ \"$_current_exe_head\" = \"$(printf '\\177ELF\\002')\" ]; then\r\n        echo 64\r\n    else\r\n        err \"unknown platform bitness\"\r\n    fi\r\n}\r\n\r\nis_host_amd64_elf() {\r\n    need_cmd head\r\n    need_cmd tail\r\n    # ELF e_machine detection without dependencies beyond coreutils.\r\n    # Two-byte field at offset 0x12 indicates the CPU,\r\n    # but we're interested in it being 0x3E to indicate amd64, or not that.\r\n    local _current_exe_machine\r\n    _current_exe_machine=$(head -c 19 /proc/self/exe | tail -c 1)\r\n    [ \"$_current_exe_machine\" = \"$(printf '\\076')\" ]\r\n}\r\n\r\nget_endianness() {\r\n    local cputype=$1\r\n    local suffix_eb=$2\r\n    local suffix_el=$3\r\n\r\n    # detect endianness without od/hexdump, like get_bitness() does.\r\n    need_cmd head\r\n    need_cmd tail\r\n\r\n    local _current_exe_endianness\r\n    _current_exe_endianness=\"$(head -c 6 /proc/self/exe | tail -c 1)\"\r\n    if [ \"$_current_exe_endianness\" = \"$(printf '\\001')\" ]; then\r\n        echo \"${cputype}${suffix_el}\"\r\n    elif [ \"$_current_exe_endianness\" = \"$(printf '\\002')\" ]; then\r\n        echo \"${cputype}${suffix_eb}\"\r\n    else\r\n        err \"unknown platform endianness\"\r\n    fi\r\n}\r\n\r\nget_architecture() {\r\n    local _ostype _cputype _bitness _arch _clibtype\r\n    _ostype=\"$(uname -s)\"\r\n    _cputype=\"$(uname -m)\"\r\n    _clibtype=\"gnu\"\r\n\r\n    if [ \"$_ostype\" = Linux ]; then\r\n        if [ \"$(uname -o)\" = Android ]; then\r\n            _ostype=Android\r\n        fi\r\n        if ldd --version 2>&1 | grep -q 'musl'; then\r\n            _clibtype=\"musl\"\r\n        fi\r\n    fi\r\n\r\n    if [ \"$_ostype\" = Darwin ] && [ \"$_cputype\" = i386 ]; then\r\n        # Darwin `uname -m` lies\r\n        if sysctl hw.optional.x86_64 | grep -q ': 1'; then\r\n            _cputype=x86_64\r\n        fi\r\n    fi\r\n\r\n    if [ \"$_ostype\" = SunOS ]; then\r\n        # Both Solaris and illumos presently announce as \"SunOS\" in \"uname -s\"\r\n        # so use \"uname -o\" to disambiguate.  We use the full path to the\r\n        # system uname in case the user has coreutils uname first in PATH,\r\n        # which has historically sometimes printed the wrong value here.\r\n        if [ \"$(/usr/bin/uname -o)\" = illumos ]; then\r\n            _ostype=illumos\r\n        fi\r\n\r\n        # illumos systems have multi-arch userlands, and \"uname -m\" reports the\r\n        # machine hardware name; e.g., \"i86pc\" on both 32- and 64-bit x86\r\n        # systems.  Check for the native (widest) instruction set on the\r\n        # running kernel:\r\n        if [ \"$_cputype\" = i86pc ]; then\r\n            _cputype=\"$(isainfo -n)\"\r\n        fi\r\n    fi\r\n\r\n    case \"$_ostype\" in\r\n\r\n        Android)\r\n            _ostype=linux-android\r\n            ;;\r\n\r\n        Linux)\r\n            check_proc\r\n            _ostype=unknown-linux-$_clibtype\r\n            _bitness=$(get_bitness)\r\n            ;;\r\n\r\n        FreeBSD)\r\n            _ostype=unknown-freebsd\r\n            ;;\r\n\r\n        NetBSD)\r\n            _ostype=unknown-netbsd\r\n            ;;\r\n\r\n        DragonFly)\r\n            _ostype=unknown-dragonfly\r\n            ;;\r\n\r\n        Darwin)\r\n            _ostype=apple-darwin\r\n            ;;\r\n\r\n        illumos)\r\n            _ostype=unknown-illumos\r\n            ;;\r\n\r\n        MINGW* | MSYS* | CYGWIN* | Windows_NT)\r\n            _ostype=pc-windows-gnu\r\n            ;;\r\n\r\n        *)\r\n            err \"unrecognized OS type: $_ostype\"\r\n            ;;\r\n\r\n    esac\r\n\r\n    case \"$_cputype\" in\r\n\r\n        i386 | i486 | i686 | i786 | x86)\r\n            _cputype=i686\r\n            ;;\r\n\r\n        xscale | arm)\r\n            _cputype=arm\r\n            if [ \"$_ostype\" = \"linux-android\" ]; then\r\n                _ostype=linux-androideabi\r\n            fi\r\n            ;;\r\n\r\n        armv6l)\r\n            _cputype=arm\r\n            if [ \"$_ostype\" = \"linux-android\" ]; then\r\n                _ostype=linux-androideabi\r\n            else\r\n                _ostype=\"${_ostype}eabihf\"\r\n            fi\r\n            ;;\r\n\r\n        armv7l | armv8l)\r\n            _cputype=armv7\r\n            if [ \"$_ostype\" = \"linux-android\" ]; then\r\n                _ostype=linux-androideabi\r\n            else\r\n                _ostype=\"${_ostype}eabihf\"\r\n            fi\r\n            ;;\r\n\r\n        aarch64 | arm64)\r\n            _cputype=aarch64\r\n            ;;\r\n\r\n        x86_64 | x86-64 | x64 | amd64)\r\n            _cputype=x86_64\r\n            ;;\r\n\r\n        mips)\r\n            _cputype=$(get_endianness mips '' el)\r\n            ;;\r\n\r\n        mips64)\r\n            if [ \"$_bitness\" -eq 64 ]; then\r\n                # only n64 ABI is supported for now\r\n                _ostype=\"${_ostype}abi64\"\r\n                _cputype=$(get_endianness mips64 '' el)\r\n            fi\r\n            ;;\r\n\r\n        ppc)\r\n            _cputype=powerpc\r\n            ;;\r\n\r\n        ppc64)\r\n            _cputype=powerpc64\r\n            ;;\r\n\r\n        ppc64le)\r\n            _cputype=powerpc64le\r\n            ;;\r\n\r\n        s390x)\r\n            _cputype=s390x\r\n            ;;\r\n        riscv64)\r\n            _cputype=riscv64gc\r\n            ;;\r\n        *)\r\n            err \"unknown CPU type: $_cputype\"\r\n\r\n    esac\r\n\r\n    # Detect 64-bit linux with 32-bit userland\r\n    if [ \"${_ostype}\" = unknown-linux-gnu ] && [ \"${_bitness}\" -eq 32 ]; then\r\n        case $_cputype in\r\n            x86_64)\r\n                if [ -n \"${RUSTUP_CPUTYPE:-}\" ]; then\r\n                    _cputype=\"$RUSTUP_CPUTYPE\"\r\n                else {\r\n                    # 32-bit executable for amd64 = x32\r\n                    if is_host_amd64_elf; then {\r\n                         echo \"This host is running an x32 userland; as it stands, x32 support is poor,\" 1>&2\r\n                         echo \"and there isn't a native toolchain -- you will have to install\" 1>&2\r\n                         echo \"multiarch compatibility with i686 and/or amd64, then select one\" 1>&2\r\n                         echo \"by re-running this script with the RUSTUP_CPUTYPE environment variable\" 1>&2\r\n                         echo \"set to i686 or x86_64, respectively.\" 1>&2\r\n                         echo 1>&2\r\n                         echo \"You will be able to add an x32 target after installation by running\" 1>&2\r\n                         echo \"  rustup target add x86_64-unknown-linux-gnux32\" 1>&2\r\n                         exit 1\r\n                    }; else\r\n                        _cputype=i686\r\n                    fi\r\n                }; fi\r\n                ;;\r\n            mips64)\r\n                _cputype=$(get_endianness mips '' el)\r\n                ;;\r\n            powerpc64)\r\n                _cputype=powerpc\r\n                ;;\r\n            aarch64)\r\n                _cputype=armv7\r\n                if [ \"$_ostype\" = \"linux-android\" ]; then\r\n                    _ostype=linux-androideabi\r\n                else\r\n                    _ostype=\"${_ostype}eabihf\"\r\n                fi\r\n                ;;\r\n            riscv64gc)\r\n                err \"riscv64 with 32-bit userland unsupported\"\r\n                ;;\r\n        esac\r\n    fi\r\n\r\n    # Detect armv7 but without the CPU features Rust needs in that build,\r\n    # and fall back to arm.\r\n    # See https://github.com/rust-lang/rustup.rs/issues/587.\r\n    if [ \"$_ostype\" = \"unknown-linux-gnueabihf\" ] && [ \"$_cputype\" = armv7 ]; then\r\n        if ensure grep '^Features' /proc/cpuinfo | grep -q -v neon; then\r\n            # At least one processor does not have NEON.\r\n            _cputype=arm\r\n        fi\r\n    fi\r\n\r\n    _arch=\"${_cputype}-${_ostype}\"\r\n\r\n    RETVAL=\"$_arch\"\r\n}\r\n\r\nsay() {\r\n    printf 'rustup: %s\\n' \"$1\"\r\n}\r\n\r\nerr() {\r\n    say \"$1\" >&2\r\n    exit 1\r\n}\r\n\r\nneed_cmd() {\r\n    if ! check_cmd \"$1\"; then\r\n        err \"need '$1' (command not found)\"\r\n    fi\r\n}\r\n\r\ncheck_cmd() {\r\n    command -v \"$1\" > /dev/null 2>&1\r\n}\r\n\r\nassert_nz() {\r\n    if [ -z \"$1\" ]; then err \"assert_nz $2\"; fi\r\n}\r\n\r\n# Run a command that should never fail. If the command fails execution\r\n# will immediately terminate with an error showing the failing\r\n# command.\r\nensure() {\r\n    if ! \"$@\"; then err \"command failed: $*\"; fi\r\n}\r\n\r\n# This is just for indicating that commands' results are being\r\n# intentionally ignored. Usually, because it's being executed\r\n# as part of error handling.\r\nignore() {\r\n    \"$@\"\r\n}\r\n\r\n# This wraps curl or wget. Try curl first, if not installed,\r\n# use wget instead.\r\ndownloader() {\r\n    local _dld\r\n    local _ciphersuites\r\n    local _err\r\n    local _status\r\n    local _retry\r\n    if check_cmd curl; then\r\n        _dld=curl\r\n    elif check_cmd wget; then\r\n        _dld=wget\r\n    else\r\n        _dld='curl or wget' # to be used in error message of need_cmd\r\n    fi\r\n\r\n    if [ \"$1\" = --check ]; then\r\n        need_cmd \"$_dld\"\r\n    elif [ \"$_dld\" = curl ]; then\r\n        check_curl_for_retry_support\r\n        _retry=\"$RETVAL\"\r\n        get_ciphersuites_for_curl\r\n        _ciphersuites=\"$RETVAL\"\r\n        if [ -n \"$_ciphersuites\" ]; then\r\n            _err=$(curl $_retry --proto '=https' --tlsv1.2 --ciphers \"$_ciphersuites\" --silent --show-error --fail --location \"$1\" --output \"$2\" 2>&1)\r\n            _status=$?\r\n        else\r\n            echo \"Warning: Not enforcing strong cipher suites for TLS, this is potentially less secure\"\r\n            if ! check_help_for \"$3\" curl --proto --tlsv1.2; then\r\n                echo \"Warning: Not enforcing TLS v1.2, this is potentially less secure\"\r\n                _err=$(curl $_retry --silent --show-error --fail --location \"$1\" --output \"$2\" 2>&1)\r\n                _status=$?\r\n            else\r\n                _err=$(curl $_retry --proto '=https' --tlsv1.2 --silent --show-error --fail --location \"$1\" --output \"$2\" 2>&1)\r\n                _status=$?\r\n            fi\r\n        fi\r\n        if [ -n \"$_err\" ]; then\r\n            echo \"$_err\" >&2\r\n            if echo \"$_err\" | grep -q 404$; then\r\n                err \"installer for platform '$3' not found, this may be unsupported\"\r\n            fi\r\n        fi\r\n        return $_status\r\n    elif [ \"$_dld\" = wget ]; then\r\n        if [ \"$(wget -V 2>&1|head -2|tail -1|cut -f1 -d\" \")\" = \"BusyBox\" ]; then\r\n            echo \"Warning: using the BusyBox version of wget.  Not enforcing strong cipher suites for TLS or TLS v1.2, this is potentially less secure\"\r\n            _err=$(wget \"$1\" -O \"$2\" 2>&1)\r\n            _status=$?\r\n        else\r\n            get_ciphersuites_for_wget\r\n            _ciphersuites=\"$RETVAL\"\r\n            if [ -n \"$_ciphersuites\" ]; then\r\n                _err=$(wget --https-only --secure-protocol=TLSv1_2 --ciphers \"$_ciphersuites\" \"$1\" -O \"$2\" 2>&1)\r\n                _status=$?\r\n            else\r\n                echo \"Warning: Not enforcing strong cipher suites for TLS, this is potentially less secure\"\r\n                if ! check_help_for \"$3\" wget --https-only --secure-protocol; then\r\n                    echo \"Warning: Not enforcing TLS v1.2, this is potentially less secure\"\r\n                    _err=$(wget \"$1\" -O \"$2\" 2>&1)\r\n                    _status=$?\r\n                else\r\n                    _err=$(wget --https-only --secure-protocol=TLSv1_2 \"$1\" -O \"$2\" 2>&1)\r\n                    _status=$?\r\n                fi\r\n            fi\r\n        fi\r\n        if [ -n \"$_err\" ]; then\r\n            echo \"$_err\" >&2\r\n            if echo \"$_err\" | grep -q ' 404 Not Found$'; then\r\n                err \"installer for platform '$3' not found, this may be unsupported\"\r\n            fi\r\n        fi\r\n        return $_status\r\n    else\r\n        err \"Unknown downloader\"   # should not reach here\r\n    fi\r\n}\r\n\r\ncheck_help_for() {\r\n    local _arch\r\n    local _cmd\r\n    local _arg\r\n    _arch=\"$1\"\r\n    shift\r\n    _cmd=\"$1\"\r\n    shift\r\n\r\n    local _category\r\n    if \"$_cmd\" --help | grep -q 'For all options use the manual or \"--help all\".'; then\r\n      _category=\"all\"\r\n    else\r\n      _category=\"\"\r\n    fi\r\n\r\n    case \"$_arch\" in\r\n\r\n        *darwin*)\r\n        if check_cmd sw_vers; then\r\n            case $(sw_vers -productVersion) in\r\n                10.*)\r\n                    # If we're running on macOS, older than 10.13, then we always\r\n                    # fail to find these options to force fallback\r\n                    if [ \"$(sw_vers -productVersion | cut -d. -f2)\" -lt 13 ]; then\r\n                        # Older than 10.13\r\n                        echo \"Warning: Detected macOS platform older than 10.13\"\r\n                        return 1\r\n                    fi\r\n                    ;;\r\n                11.*)\r\n                    # We assume Big Sur will be OK for now\r\n                    ;;\r\n                *)\r\n                    # Unknown product version, warn and continue\r\n                    echo \"Warning: Detected unknown macOS major version: $(sw_vers -productVersion)\"\r\n                    echo \"Warning TLS capabilities detection may fail\"\r\n                    ;;\r\n            esac\r\n        fi\r\n        ;;\r\n\r\n    esac\r\n\r\n    for _arg in \"$@\"; do\r\n        if ! \"$_cmd\" --help $_category | grep -q -- \"$_arg\"; then\r\n            return 1\r\n        fi\r\n    done\r\n\r\n    true # not strictly needed\r\n}\r\n\r\n# Check if curl supports the --retry flag, then pass it to the curl invocation.\r\ncheck_curl_for_retry_support() {\r\n  local _retry_supported=\"\"\r\n  # \"unspecified\" is for arch, allows for possibility old OS using macports, homebrew, etc.\r\n  if check_help_for \"notspecified\" \"curl\" \"--retry\"; then\r\n    _retry_supported=\"--retry 3\"\r\n  fi\r\n\r\n  RETVAL=\"$_retry_supported\"\r\n\r\n}\r\n\r\n# Return cipher suite string specified by user, otherwise return strong TLS 1.2-1.3 cipher suites\r\n# if support by local tools is detected. Detection currently supports these curl backends:\r\n# GnuTLS and OpenSSL (possibly also LibreSSL and BoringSSL). Return value can be empty.\r\nget_ciphersuites_for_curl() {\r\n    if [ -n \"${RUSTUP_TLS_CIPHERSUITES-}\" ]; then\r\n        # user specified custom cipher suites, assume they know what they're doing\r\n        RETVAL=\"$RUSTUP_TLS_CIPHERSUITES\"\r\n        return\r\n    fi\r\n\r\n    local _openssl_syntax=\"no\"\r\n    local _gnutls_syntax=\"no\"\r\n    local _backend_supported=\"yes\"\r\n    if curl -V | grep -q ' OpenSSL/'; then\r\n        _openssl_syntax=\"yes\"\r\n    elif curl -V | grep -iq ' LibreSSL/'; then\r\n        _openssl_syntax=\"yes\"\r\n    elif curl -V | grep -iq ' BoringSSL/'; then\r\n        _openssl_syntax=\"yes\"\r\n    elif curl -V | grep -iq ' GnuTLS/'; then\r\n        _gnutls_syntax=\"yes\"\r\n    else\r\n        _backend_supported=\"no\"\r\n    fi\r\n\r\n    local _args_supported=\"no\"\r\n    if [ \"$_backend_supported\" = \"yes\" ]; then\r\n        # \"unspecified\" is for arch, allows for possibility old OS using macports, homebrew, etc.\r\n        if check_help_for \"notspecified\" \"curl\" \"--tlsv1.2\" \"--ciphers\" \"--proto\"; then\r\n            _args_supported=\"yes\"\r\n        fi\r\n    fi\r\n\r\n    local _cs=\"\"\r\n    if [ \"$_args_supported\" = \"yes\" ]; then\r\n        if [ \"$_openssl_syntax\" = \"yes\" ]; then\r\n            _cs=$(get_strong_ciphersuites_for \"openssl\")\r\n        elif [ \"$_gnutls_syntax\" = \"yes\" ]; then\r\n            _cs=$(get_strong_ciphersuites_for \"gnutls\")\r\n        fi\r\n    fi\r\n\r\n    RETVAL=\"$_cs\"\r\n}\r\n\r\n# Return cipher suite string specified by user, otherwise return strong TLS 1.2-1.3 cipher suites\r\n# if support by local tools is detected. Detection currently supports these wget backends:\r\n# GnuTLS and OpenSSL (possibly also LibreSSL and BoringSSL). Return value can be empty.\r\nget_ciphersuites_for_wget() {\r\n    if [ -n \"${RUSTUP_TLS_CIPHERSUITES-}\" ]; then\r\n        # user specified custom cipher suites, assume they know what they're doing\r\n        RETVAL=\"$RUSTUP_TLS_CIPHERSUITES\"\r\n        return\r\n    fi\r\n\r\n    local _cs=\"\"\r\n    if wget -V | grep -q '\\-DHAVE_LIBSSL'; then\r\n        # \"unspecified\" is for arch, allows for possibility old OS using macports, homebrew, etc.\r\n        if check_help_for \"notspecified\" \"wget\" \"TLSv1_2\" \"--ciphers\" \"--https-only\" \"--secure-protocol\"; then\r\n            _cs=$(get_strong_ciphersuites_for \"openssl\")\r\n        fi\r\n    elif wget -V | grep -q '\\-DHAVE_LIBGNUTLS'; then\r\n        # \"unspecified\" is for arch, allows for possibility old OS using macports, homebrew, etc.\r\n        if check_help_for \"notspecified\" \"wget\" \"TLSv1_2\" \"--ciphers\" \"--https-only\" \"--secure-protocol\"; then\r\n            _cs=$(get_strong_ciphersuites_for \"gnutls\")\r\n        fi\r\n    fi\r\n\r\n    RETVAL=\"$_cs\"\r\n}\r\n\r\n# Return strong TLS 1.2-1.3 cipher suites in OpenSSL or GnuTLS syntax. TLS 1.2\r\n# excludes non-ECDHE and non-AEAD cipher suites. DHE is excluded due to bad\r\n# DH params often found on servers (see RFC 7919). Sequence matches or is\r\n# similar to Firefox 68 ESR with weak cipher suites disabled via about:config.\r\n# $1 must be openssl or gnutls.\r\nget_strong_ciphersuites_for() {\r\n    if [ \"$1\" = \"openssl\" ]; then\r\n        # OpenSSL is forgiving of unknown values, no problems with TLS 1.3 values on versions that don't support it yet.\r\n        echo \"TLS_AES_128_GCM_SHA256:TLS_CHACHA20_POLY1305_SHA256:TLS_AES_256_GCM_SHA384:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384\"\r\n    elif [ \"$1\" = \"gnutls\" ]; then\r\n        # GnuTLS isn't forgiving of unknown values, so this may require a GnuTLS version that supports TLS 1.3 even if wget doesn't.\r\n        # Begin with SECURE128 (and higher) then remove/add to build cipher suites. Produces same 9 cipher suites as OpenSSL but in slightly different order.\r\n        echo \"SECURE128:-VERS-SSL3.0:-VERS-TLS1.0:-VERS-TLS1.1:-VERS-DTLS-ALL:-CIPHER-ALL:-MAC-ALL:-KX-ALL:+AEAD:+ECDHE-ECDSA:+ECDHE-RSA:+AES-128-GCM:+CHACHA20-POLY1305:+AES-256-GCM\"\r\n    fi\r\n}\r\n\r\nmain \"$@\" || exit 1\r\ncurl: (1) Protocol \"http\" not supported or disabled in libcurl\r\ncurl: (1) Protocol \"http\" not supported or disabled in libcurl", "stdout_lines": ["#!/bin/sh", "# shellcheck shell=dash", "", "# This is just a little script that can be downloaded from the internet to", "# install rustup. It just does platform detection, downloads the installer", "# and runs it.", "", "# It runs on Unix shells like {a,ba,da,k,z}sh. It uses the common `local`", "# extension. Note: Most shells limit `local` to 1 var per line, contra bash.", "", "if [ \"$KSH_VERSION\" = 'Version JM 93t+ 2010-03-05' ]; then", "    # The version of ksh93 that ships with many illumos systems does not", "    # support the \"local\" extension.  Print a message rather than fail in", "    # subtle ways later on:", "    echo 'rustup does not work with this ksh93 version; please try bash!' >&2", "    exit 1", "fi", "", "", "set -u", "", "# If RUSTUP_UPDATE_ROOT is unset or empty, default it.", "RUSTUP_UPDATE_ROOT=\"${RUSTUP_UPDATE_ROOT:-https://static.rust-lang.org/rustup}\"", "", "#XXX: If you change anything here, please make the same changes in setup_mode.rs", "usage() {", "    cat 1>&2 <<EOF", "rustup-init 1.25.1 (48d233f65 2022-07-12)", "The installer for rustup", "", "USAGE:", "    rustup-init [FLAGS] [OPTIONS]", "", "FLAGS:", "    -v, --verbose           Enable verbose output", "    -q, --quiet             Disable progress output", "    -y                      Disable confirmation prompt.", "        --no-modify-path    Don't configure the PATH environment variable", "    -h, --help              Prints help information", "    -V, --version           Prints version information", "", "OPTIONS:", "        --default-host <default-host>              Choose a default host triple", "        --default-toolchain <default-toolchain>    Choose a default toolchain to install", "        --default-toolchain none                   Do not install any toolchains", "        --profile [minimal|default|complete]       Choose a profile", "    -c, --component <components>...                Component name to also install", "    -t, --target <targets>...                      Target name to also install", "EOF", "}", "", "main() {", "    downloader --check", "    need_cmd uname", "    need_cmd mktemp", "    need_cmd chmod", "    need_cmd mkdir", "    need_cmd rm", "    need_cmd rmdir", "", "    get_architecture || return 1", "    local _arch=\"$RETVAL\"", "    assert_nz \"$_arch\" \"arch\"", "", "    local _ext=\"\"", "    case \"$_arch\" in", "        *windows*)", "            _ext=\".exe\"", "            ;;", "    esac", "", "    local _url=\"${RUSTUP_UPDATE_ROOT}/dist/${_arch}/rustup-init${_ext}\"", "", "    local _dir", "    _dir=\"$(ensure mktemp -d)\"", "    local _file=\"${_dir}/rustup-init${_ext}\"", "", "    local _ansi_escapes_are_valid=false", "    if [ -t 2 ]; then", "        if [ \"${TERM+set}\" = 'set' ]; then", "            case \"$TERM\" in", "                xterm*|rxvt*|urxvt*|linux*|vt*)", "                    _ansi_escapes_are_valid=true", "                ;;", "            esac", "        fi", "    fi", "", "    # check if we have to use /dev/tty to prompt the user", "    local need_tty=yes", "    for arg in \"$@\"; do", "        case \"$arg\" in", "            --help)", "                usage", "                exit 0", "                ;;", "            *)", "                OPTIND=1", "                if [ \"${arg%%--*}\" = \"\" ]; then", "                    # Long option (other than --help);", "                    # don't attempt to interpret it.", "                    continue", "                fi", "                while getopts :hy sub_arg \"$arg\"; do", "                    case \"$sub_arg\" in", "                        h)", "                            usage", "                            exit 0", "                            ;;", "                        y)", "                            # user wants to skip the prompt --", "                            # we don't need /dev/tty", "                            need_tty=no", "                            ;;", "                        *)", "                            ;;", "                        esac", "                done", "                ;;", "        esac", "    done", "", "    if $_ansi_escapes_are_valid; then", "        printf \"\\33[1minfo:\\33[0m downloading installer\\n\" 1>&2", "    else", "        printf '%s\\n' 'info: downloading installer' 1>&2", "    fi", "", "    ensure mkdir -p \"$_dir\"", "    ensure downloader \"$_url\" \"$_file\" \"$_arch\"", "    ensure chmod u+x \"$_file\"", "    if [ ! -x \"$_file\" ]; then", "        printf '%s\\n' \"Cannot execute $_file (likely because of mounting /tmp as noexec).\" 1>&2", "        printf '%s\\n' \"Please copy the file to a location where you can execute binaries and run ./rustup-init${_ext}.\" 1>&2", "        exit 1", "    fi", "", "    if [ \"$need_tty\" = \"yes\" ] && [ ! -t 0 ]; then", "        # The installer is going to want to ask for confirmation by", "        # reading stdin.  This script was piped into `sh` though and", "        # doesn't have stdin to pass to its children. Instead we're going", "        # to explicitly connect /dev/tty to the installer's stdin.", "        if [ ! -t 1 ]; then", "            err \"Unable to run interactively. Run with -y to accept defaults, --help for additional options\"", "        fi", "", "        ignore \"$_file\" \"$@\" < /dev/tty", "    else", "        ignore \"$_file\" \"$@\"", "    fi", "", "    local _retval=$?", "", "    ignore rm \"$_file\"", "    ignore rmdir \"$_dir\"", "", "    return \"$_retval\"", "}", "", "check_proc() {", "    # Check for /proc by looking for the /proc/self/exe link", "    # This is only run on Linux", "    if ! test -L /proc/self/exe ; then", "        err \"fatal: Unable to find /proc/self/exe.  Is /proc mounted?  Installation cannot proceed without /proc.\"", "    fi", "}", "", "get_bitness() {", "    need_cmd head", "    # Architecture detection without dependencies beyond coreutils.", "    # ELF files start out \"\\x7fELF\", and the following byte is", "    #   0x01 for 32-bit and", "    #   0x02 for 64-bit.", "    # The printf builtin on some shells like dash only supports octal", "    # escape sequences, so we use those.", "    local _current_exe_head", "    _current_exe_head=$(head -c 5 /proc/self/exe )", "    if [ \"$_current_exe_head\" = \"$(printf '\\177ELF\\001')\" ]; then", "        echo 32", "    elif [ \"$_current_exe_head\" = \"$(printf '\\177ELF\\002')\" ]; then", "        echo 64", "    else", "        err \"unknown platform bitness\"", "    fi", "}", "", "is_host_amd64_elf() {", "    need_cmd head", "    need_cmd tail", "    # ELF e_machine detection without dependencies beyond coreutils.", "    # Two-byte field at offset 0x12 indicates the CPU,", "    # but we're interested in it being 0x3E to indicate amd64, or not that.", "    local _current_exe_machine", "    _current_exe_machine=$(head -c 19 /proc/self/exe | tail -c 1)", "    [ \"$_current_exe_machine\" = \"$(printf '\\076')\" ]", "}", "", "get_endianness() {", "    local cputype=$1", "    local suffix_eb=$2", "    local suffix_el=$3", "", "    # detect endianness without od/hexdump, like get_bitness() does.", "    need_cmd head", "    need_cmd tail", "", "    local _current_exe_endianness", "    _current_exe_endianness=\"$(head -c 6 /proc/self/exe | tail -c 1)\"", "    if [ \"$_current_exe_endianness\" = \"$(printf '\\001')\" ]; then", "        echo \"${cputype}${suffix_el}\"", "    elif [ \"$_current_exe_endianness\" = \"$(printf '\\002')\" ]; then", "        echo \"${cputype}${suffix_eb}\"", "    else", "        err \"unknown platform endianness\"", "    fi", "}", "", "get_architecture() {", "    local _ostype _cputype _bitness _arch _clibtype", "    _ostype=\"$(uname -s)\"", "    _cputype=\"$(uname -m)\"", "    _clibtype=\"gnu\"", "", "    if [ \"$_ostype\" = Linux ]; then", "        if [ \"$(uname -o)\" = Android ]; then", "            _ostype=Android", "        fi", "        if ldd --version 2>&1 | grep -q 'musl'; then", "            _clibtype=\"musl\"", "        fi", "    fi", "", "    if [ \"$_ostype\" = Darwin ] && [ \"$_cputype\" = i386 ]; then", "        # Darwin `uname -m` lies", "        if sysctl hw.optional.x86_64 | grep -q ': 1'; then", "            _cputype=x86_64", "        fi", "    fi", "", "    if [ \"$_ostype\" = SunOS ]; then", "        # Both Solaris and illumos presently announce as \"SunOS\" in \"uname -s\"", "        # so use \"uname -o\" to disambiguate.  We use the full path to the", "        # system uname in case the user has coreutils uname first in PATH,", "        # which has historically sometimes printed the wrong value here.", "        if [ \"$(/usr/bin/uname -o)\" = illumos ]; then", "            _ostype=illumos", "        fi", "", "        # illumos systems have multi-arch userlands, and \"uname -m\" reports the", "        # machine hardware name; e.g., \"i86pc\" on both 32- and 64-bit x86", "        # systems.  Check for the native (widest) instruction set on the", "        # running kernel:", "        if [ \"$_cputype\" = i86pc ]; then", "            _cputype=\"$(isainfo -n)\"", "        fi", "    fi", "", "    case \"$_ostype\" in", "", "        Android)", "            _ostype=linux-android", "            ;;", "", "        Linux)", "            check_proc", "            _ostype=unknown-linux-$_clibtype", "            _bitness=$(get_bitness)", "            ;;", "", "        FreeBSD)", "            _ostype=unknown-freebsd", "            ;;", "", "        NetBSD)", "            _ostype=unknown-netbsd", "            ;;", "", "        DragonFly)", "            _ostype=unknown-dragonfly", "            ;;", "", "        Darwin)", "            _ostype=apple-darwin", "            ;;", "", "        illumos)", "            _ostype=unknown-illumos", "            ;;", "", "        MINGW* | MSYS* | CYGWIN* | Windows_NT)", "            _ostype=pc-windows-gnu", "            ;;", "", "        *)", "            err \"unrecognized OS type: $_ostype\"", "            ;;", "", "    esac", "", "    case \"$_cputype\" in", "", "        i386 | i486 | i686 | i786 | x86)", "            _cputype=i686", "            ;;", "", "        xscale | arm)", "            _cputype=arm", "            if [ \"$_ostype\" = \"linux-android\" ]; then", "                _ostype=linux-androideabi", "            fi", "            ;;", "", "        armv6l)", "            _cputype=arm", "            if [ \"$_ostype\" = \"linux-android\" ]; then", "                _ostype=linux-androideabi", "            else", "                _ostype=\"${_ostype}eabihf\"", "            fi", "            ;;", "", "        armv7l | armv8l)", "            _cputype=armv7", "            if [ \"$_ostype\" = \"linux-android\" ]; then", "                _ostype=linux-androideabi", "            else", "                _ostype=\"${_ostype}eabihf\"", "            fi", "            ;;", "", "        aarch64 | arm64)", "            _cputype=aarch64", "            ;;", "", "        x86_64 | x86-64 | x64 | amd64)", "            _cputype=x86_64", "            ;;", "", "        mips)", "            _cputype=$(get_endianness mips '' el)", "            ;;", "", "        mips64)", "            if [ \"$_bitness\" -eq 64 ]; then", "                # only n64 ABI is supported for now", "                _ostype=\"${_ostype}abi64\"", "                _cputype=$(get_endianness mips64 '' el)", "            fi", "            ;;", "", "        ppc)", "            _cputype=powerpc", "            ;;", "", "        ppc64)", "            _cputype=powerpc64", "            ;;", "", "        ppc64le)", "            _cputype=powerpc64le", "            ;;", "", "        s390x)", "            _cputype=s390x", "            ;;", "        riscv64)", "            _cputype=riscv64gc", "            ;;", "        *)", "            err \"unknown CPU type: $_cputype\"", "", "    esac", "", "    # Detect 64-bit linux with 32-bit userland", "    if [ \"${_ostype}\" = unknown-linux-gnu ] && [ \"${_bitness}\" -eq 32 ]; then", "        case $_cputype in", "            x86_64)", "                if [ -n \"${RUSTUP_CPUTYPE:-}\" ]; then", "                    _cputype=\"$RUSTUP_CPUTYPE\"", "                else {", "                    # 32-bit executable for amd64 = x32", "                    if is_host_amd64_elf; then {", "                         echo \"This host is running an x32 userland; as it stands, x32 support is poor,\" 1>&2", "                         echo \"and there isn't a native toolchain -- you will have to install\" 1>&2", "                         echo \"multiarch compatibility with i686 and/or amd64, then select one\" 1>&2", "                         echo \"by re-running this script with the RUSTUP_CPUTYPE environment variable\" 1>&2", "                         echo \"set to i686 or x86_64, respectively.\" 1>&2", "                         echo 1>&2", "                         echo \"You will be able to add an x32 target after installation by running\" 1>&2", "                         echo \"  rustup target add x86_64-unknown-linux-gnux32\" 1>&2", "                         exit 1", "                    }; else", "                        _cputype=i686", "                    fi", "                }; fi", "                ;;", "            mips64)", "                _cputype=$(get_endianness mips '' el)", "                ;;", "            powerpc64)", "                _cputype=powerpc", "                ;;", "            aarch64)", "                _cputype=armv7", "                if [ \"$_ostype\" = \"linux-android\" ]; then", "                    _ostype=linux-androideabi", "                else", "                    _ostype=\"${_ostype}eabihf\"", "                fi", "                ;;", "            riscv64gc)", "                err \"riscv64 with 32-bit userland unsupported\"", "                ;;", "        esac", "    fi", "", "    # Detect armv7 but without the CPU features Rust needs in that build,", "    # and fall back to arm.", "    # See https://github.com/rust-lang/rustup.rs/issues/587.", "    if [ \"$_ostype\" = \"unknown-linux-gnueabihf\" ] && [ \"$_cputype\" = armv7 ]; then", "        if ensure grep '^Features' /proc/cpuinfo | grep -q -v neon; then", "            # At least one processor does not have NEON.", "            _cputype=arm", "        fi", "    fi", "", "    _arch=\"${_cputype}-${_ostype}\"", "", "    RETVAL=\"$_arch\"", "}", "", "say() {", "    printf 'rustup: %s\\n' \"$1\"", "}", "", "err() {", "    say \"$1\" >&2", "    exit 1", "}", "", "need_cmd() {", "    if ! check_cmd \"$1\"; then", "        err \"need '$1' (command not found)\"", "    fi", "}", "", "check_cmd() {", "    command -v \"$1\" > /dev/null 2>&1", "}", "", "assert_nz() {", "    if [ -z \"$1\" ]; then err \"assert_nz $2\"; fi", "}", "", "# Run a command that should never fail. If the command fails execution", "# will immediately terminate with an error showing the failing", "# command.", "ensure() {", "    if ! \"$@\"; then err \"command failed: $*\"; fi", "}", "", "# This is just for indicating that commands' results are being", "# intentionally ignored. Usually, because it's being executed", "# as part of error handling.", "ignore() {", "    \"$@\"", "}", "", "# This wraps curl or wget. Try curl first, if not installed,", "# use wget instead.", "downloader() {", "    local _dld", "    local _ciphersuites", "    local _err", "    local _status", "    local _retry", "    if check_cmd curl; then", "        _dld=curl", "    elif check_cmd wget; then", "        _dld=wget", "    else", "        _dld='curl or wget' # to be used in error message of need_cmd", "    fi", "", "    if [ \"$1\" = --check ]; then", "        need_cmd \"$_dld\"", "    elif [ \"$_dld\" = curl ]; then", "        check_curl_for_retry_support", "        _retry=\"$RETVAL\"", "        get_ciphersuites_for_curl", "        _ciphersuites=\"$RETVAL\"", "        if [ -n \"$_ciphersuites\" ]; then", "            _err=$(curl $_retry --proto '=https' --tlsv1.2 --ciphers \"$_ciphersuites\" --silent --show-error --fail --location \"$1\" --output \"$2\" 2>&1)", "            _status=$?", "        else", "            echo \"Warning: Not enforcing strong cipher suites for TLS, this is potentially less secure\"", "            if ! check_help_for \"$3\" curl --proto --tlsv1.2; then", "                echo \"Warning: Not enforcing TLS v1.2, this is potentially less secure\"", "                _err=$(curl $_retry --silent --show-error --fail --location \"$1\" --output \"$2\" 2>&1)", "                _status=$?", "            else", "                _err=$(curl $_retry --proto '=https' --tlsv1.2 --silent --show-error --fail --location \"$1\" --output \"$2\" 2>&1)", "                _status=$?", "            fi", "        fi", "        if [ -n \"$_err\" ]; then", "            echo \"$_err\" >&2", "            if echo \"$_err\" | grep -q 404$; then", "                err \"installer for platform '$3' not found, this may be unsupported\"", "            fi", "        fi", "        return $_status", "    elif [ \"$_dld\" = wget ]; then", "        if [ \"$(wget -V 2>&1|head -2|tail -1|cut -f1 -d\" \")\" = \"BusyBox\" ]; then", "            echo \"Warning: using the BusyBox version of wget.  Not enforcing strong cipher suites for TLS or TLS v1.2, this is potentially less secure\"", "            _err=$(wget \"$1\" -O \"$2\" 2>&1)", "            _status=$?", "        else", "            get_ciphersuites_for_wget", "            _ciphersuites=\"$RETVAL\"", "            if [ -n \"$_ciphersuites\" ]; then", "                _err=$(wget --https-only --secure-protocol=TLSv1_2 --ciphers \"$_ciphersuites\" \"$1\" -O \"$2\" 2>&1)", "                _status=$?", "            else", "                echo \"Warning: Not enforcing strong cipher suites for TLS, this is potentially less secure\"", "                if ! check_help_for \"$3\" wget --https-only --secure-protocol; then", "                    echo \"Warning: Not enforcing TLS v1.2, this is potentially less secure\"", "                    _err=$(wget \"$1\" -O \"$2\" 2>&1)", "                    _status=$?", "                else", "                    _err=$(wget --https-only --secure-protocol=TLSv1_2 \"$1\" -O \"$2\" 2>&1)", "                    _status=$?", "                fi", "            fi", "        fi", "        if [ -n \"$_err\" ]; then", "            echo \"$_err\" >&2", "            if echo \"$_err\" | grep -q ' 404 Not Found$'; then", "                err \"installer for platform '$3' not found, this may be unsupported\"", "            fi", "        fi", "        return $_status", "    else", "        err \"Unknown downloader\"   # should not reach here", "    fi", "}", "", "check_help_for() {", "    local _arch", "    local _cmd", "    local _arg", "    _arch=\"$1\"", "    shift", "    _cmd=\"$1\"", "    shift", "", "    local _category", "    if \"$_cmd\" --help | grep -q 'For all options use the manual or \"--help all\".'; then", "      _category=\"all\"", "    else", "      _category=\"\"", "    fi", "", "    case \"$_arch\" in", "", "        *darwin*)", "        if check_cmd sw_vers; then", "            case $(sw_vers -productVersion) in", "                10.*)", "                    # If we're running on macOS, older than 10.13, then we always", "                    # fail to find these options to force fallback", "                    if [ \"$(sw_vers -productVersion | cut -d. -f2)\" -lt 13 ]; then", "                        # Older than 10.13", "                        echo \"Warning: Detected macOS platform older than 10.13\"", "                        return 1", "                    fi", "                    ;;", "                11.*)", "                    # We assume Big Sur will be OK for now", "                    ;;", "                *)", "                    # Unknown product version, warn and continue", "                    echo \"Warning: Detected unknown macOS major version: $(sw_vers -productVersion)\"", "                    echo \"Warning TLS capabilities detection may fail\"", "                    ;;", "            esac", "        fi", "        ;;", "", "    esac", "", "    for _arg in \"$@\"; do", "        if ! \"$_cmd\" --help $_category | grep -q -- \"$_arg\"; then", "            return 1", "        fi", "    done", "", "    true # not strictly needed", "}", "", "# Check if curl supports the --retry flag, then pass it to the curl invocation.", "check_curl_for_retry_support() {", "  local _retry_supported=\"\"", "  # \"unspecified\" is for arch, allows for possibility old OS using macports, homebrew, etc.", "  if check_help_for \"notspecified\" \"curl\" \"--retry\"; then", "    _retry_supported=\"--retry 3\"", "  fi", "", "  RETVAL=\"$_retry_supported\"", "", "}", "", "# Return cipher suite string specified by user, otherwise return strong TLS 1.2-1.3 cipher suites", "# if support by local tools is detected. Detection currently supports these curl backends:", "# GnuTLS and OpenSSL (possibly also LibreSSL and BoringSSL). Return value can be empty.", "get_ciphersuites_for_curl() {", "    if [ -n \"${RUSTUP_TLS_CIPHERSUITES-}\" ]; then", "        # user specified custom cipher suites, assume they know what they're doing", "        RETVAL=\"$RUSTUP_TLS_CIPHERSUITES\"", "        return", "    fi", "", "    local _openssl_syntax=\"no\"", "    local _gnutls_syntax=\"no\"", "    local _backend_supported=\"yes\"", "    if curl -V | grep -q ' OpenSSL/'; then", "        _openssl_syntax=\"yes\"", "    elif curl -V | grep -iq ' LibreSSL/'; then", "        _openssl_syntax=\"yes\"", "    elif curl -V | grep -iq ' BoringSSL/'; then", "        _openssl_syntax=\"yes\"", "    elif curl -V | grep -iq ' GnuTLS/'; then", "        _gnutls_syntax=\"yes\"", "    else", "        _backend_supported=\"no\"", "    fi", "", "    local _args_supported=\"no\"", "    if [ \"$_backend_supported\" = \"yes\" ]; then", "        # \"unspecified\" is for arch, allows for possibility old OS using macports, homebrew, etc.", "        if check_help_for \"notspecified\" \"curl\" \"--tlsv1.2\" \"--ciphers\" \"--proto\"; then", "            _args_supported=\"yes\"", "        fi", "    fi", "", "    local _cs=\"\"", "    if [ \"$_args_supported\" = \"yes\" ]; then", "        if [ \"$_openssl_syntax\" = \"yes\" ]; then", "            _cs=$(get_strong_ciphersuites_for \"openssl\")", "        elif [ \"$_gnutls_syntax\" = \"yes\" ]; then", "            _cs=$(get_strong_ciphersuites_for \"gnutls\")", "        fi", "    fi", "", "    RETVAL=\"$_cs\"", "}", "", "# Return cipher suite string specified by user, otherwise return strong TLS 1.2-1.3 cipher suites", "# if support by local tools is detected. Detection currently supports these wget backends:", "# GnuTLS and OpenSSL (possibly also LibreSSL and BoringSSL). Return value can be empty.", "get_ciphersuites_for_wget() {", "    if [ -n \"${RUSTUP_TLS_CIPHERSUITES-}\" ]; then", "        # user specified custom cipher suites, assume they know what they're doing", "        RETVAL=\"$RUSTUP_TLS_CIPHERSUITES\"", "        return", "    fi", "", "    local _cs=\"\"", "    if wget -V | grep -q '\\-DHAVE_LIBSSL'; then", "        # \"unspecified\" is for arch, allows for possibility old OS using macports, homebrew, etc.", "        if check_help_for \"notspecified\" \"wget\" \"TLSv1_2\" \"--ciphers\" \"--https-only\" \"--secure-protocol\"; then", "            _cs=$(get_strong_ciphersuites_for \"openssl\")", "        fi", "    elif wget -V | grep -q '\\-DHAVE_LIBGNUTLS'; then", "        # \"unspecified\" is for arch, allows for possibility old OS using macports, homebrew, etc.", "        if check_help_for \"notspecified\" \"wget\" \"TLSv1_2\" \"--ciphers\" \"--https-only\" \"--secure-protocol\"; then", "            _cs=$(get_strong_ciphersuites_for \"gnutls\")", "        fi", "    fi", "", "    RETVAL=\"$_cs\"", "}", "", "# Return strong TLS 1.2-1.3 cipher suites in OpenSSL or GnuTLS syntax. TLS 1.2", "# excludes non-ECDHE and non-AEAD cipher suites. DHE is excluded due to bad", "# DH params often found on servers (see RFC 7919). Sequence matches or is", "# similar to Firefox 68 ESR with weak cipher suites disabled via about:config.", "# $1 must be openssl or gnutls.", "get_strong_ciphersuites_for() {", "    if [ \"$1\" = \"openssl\" ]; then", "        # OpenSSL is forgiving of unknown values, no problems with TLS 1.3 values on versions that don't support it yet.", "        echo \"TLS_AES_128_GCM_SHA256:TLS_CHACHA20_POLY1305_SHA256:TLS_AES_256_GCM_SHA384:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384\"", "    elif [ \"$1\" = \"gnutls\" ]; then", "        # GnuTLS isn't forgiving of unknown values, so this may require a GnuTLS version that supports TLS 1.3 even if wget doesn't.", "        # Begin with SECURE128 (and higher) then remove/add to build cipher suites. Produces same 9 cipher suites as OpenSSL but in slightly different order.", "        echo \"SECURE128:-VERS-SSL3.0:-VERS-TLS1.0:-VERS-TLS1.1:-VERS-DTLS-ALL:-CIPHER-ALL:-MAC-ALL:-KX-ALL:+AEAD:+ECDHE-ECDSA:+ECDHE-RSA:+AES-128-GCM:+CHACHA20-POLY1305:+AES-256-GCM\"", "    fi", "}", "", "main \"$@\" || exit 1", "curl: (1) Protocol \"http\" not supported or disabled in libcurl", "curl: (1) Protocol \"http\" not supported or disabled in libcurl"]}
2022-12-30 00:02:49,316 p=87655 u=kal n=ansible | PLAY RECAP *******************************************************************************************************************************************
2022-12-30 00:02:49,317 p=87655 u=kal n=ansible | krpz                       : ok=3    changed=0    unreachable=0    failed=1    skipped=0    rescued=0    ignored=0   
2022-12-30 00:04:34,034 p=88111 u=kal n=ansible | Using /home/kal/MyApplications/dotfiles/playbooks/ansible.cfg as config file
2022-12-30 00:04:34,105 p=88111 u=kal n=ansible | PLAY [localhost] *************************************************************************************************************************************
2022-12-30 00:04:34,112 p=88111 u=kal n=ansible | TASK [Gathering Facts] *******************************************************************************************************************************
2022-12-30 00:04:38,149 p=88111 u=kal n=ansible | ok: [krpz]
2022-12-30 00:04:38,171 p=88111 u=kal n=ansible | TASK [install pexpect] *******************************************************************************************************************************
2022-12-30 00:04:38,600 p=88111 u=kal n=ansible | ok: [krpz] => {"changed": false, "cmd": ["/usr/bin/python2", "-m", "pip.__main__", "install", "pexpect"], "name": ["pexpect"], "requirements": null, "state": "present", "stderr": "DEPRECATION: Python 2.7 reached the end of its life on January 1st, 2020. Please upgrade your Python as Python 2.7 is no longer maintained. pip 21.0 will drop support for Python 2.7 in January 2021. More details about Python 2 support in pip can be found at https://pip.pypa.io/en/latest/development/release-process/#python-2-support pip 21.0 will remove support for this functionality.\n", "stderr_lines": ["DEPRECATION: Python 2.7 reached the end of its life on January 1st, 2020. Please upgrade your Python as Python 2.7 is no longer maintained. pip 21.0 will drop support for Python 2.7 in January 2021. More details about Python 2 support in pip can be found at https://pip.pypa.io/en/latest/development/release-process/#python-2-support pip 21.0 will remove support for this functionality."], "stdout": "Requirement already satisfied: pexpect in /usr/local/lib/python2.7/dist-packages (4.8.0)\nRequirement already satisfied: ptyprocess>=0.5 in /usr/local/lib/python2.7/dist-packages (from pexpect) (0.7.0)\n", "stdout_lines": ["Requirement already satisfied: pexpect in /usr/local/lib/python2.7/dist-packages (4.8.0)", "Requirement already satisfied: ptyprocess>=0.5 in /usr/local/lib/python2.7/dist-packages (from pexpect) (0.7.0)"], "version": null, "virtualenv": null}
2022-12-30 00:04:38,608 p=88111 u=kal n=ansible | TASK [install setuptools] ****************************************************************************************************************************
2022-12-30 00:04:38,953 p=88111 u=kal n=ansible | ok: [krpz] => {"changed": false, "cmd": ["/usr/bin/python2", "-m", "pip.__main__", "install", "setuptools"], "name": ["setuptools"], "requirements": null, "state": "present", "stderr": "DEPRECATION: Python 2.7 reached the end of its life on January 1st, 2020. Please upgrade your Python as Python 2.7 is no longer maintained. pip 21.0 will drop support for Python 2.7 in January 2021. More details about Python 2 support in pip can be found at https://pip.pypa.io/en/latest/development/release-process/#python-2-support pip 21.0 will remove support for this functionality.\n", "stderr_lines": ["DEPRECATION: Python 2.7 reached the end of its life on January 1st, 2020. Please upgrade your Python as Python 2.7 is no longer maintained. pip 21.0 will drop support for Python 2.7 in January 2021. More details about Python 2 support in pip can be found at https://pip.pypa.io/en/latest/development/release-process/#python-2-support pip 21.0 will remove support for this functionality."], "stdout": "Requirement already satisfied: setuptools in /usr/lib/python2.7/dist-packages (44.1.1)\n", "stdout_lines": ["Requirement already satisfied: setuptools in /usr/lib/python2.7/dist-packages (44.1.1)"], "version": null, "virtualenv": null}
2022-12-30 00:04:38,961 p=88111 u=kal n=ansible | TASK [Install Rust] **********************************************************************************************************************************
2022-12-30 00:04:39,377 p=88111 u=kal n=ansible | fatal: [krpz]: FAILED! => {"changed": true, "cmd": "curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh", "delta": "0:00:00.225422", "end": "2022-12-30 00:04:39.349422", "msg": "non-zero return code", "rc": 1, "start": "2022-12-30 00:04:39.124000", "stdout": "#!/bin/sh\r\n# shellcheck shell=dash\r\n\r\n# This is just a little script that can be downloaded from the internet to\r\n# install rustup. It just does platform detection, downloads the installer\r\n# and runs it.\r\n\r\n# It runs on Unix shells like {a,ba,da,k,z}sh. It uses the common `local`\r\n# extension. Note: Most shells limit `local` to 1 var per line, contra bash.\r\n\r\nif [ \"$KSH_VERSION\" = 'Version JM 93t+ 2010-03-05' ]; then\r\n    # The version of ksh93 that ships with many illumos systems does not\r\n    # support the \"local\" extension.  Print a message rather than fail in\r\n    # subtle ways later on:\r\n    echo 'rustup does not work with this ksh93 version; please try bash!' >&2\r\n    exit 1\r\nfi\r\n\r\n\r\nset -u\r\n\r\n# If RUSTUP_UPDATE_ROOT is unset or empty, default it.\r\nRUSTUP_UPDATE_ROOT=\"${RUSTUP_UPDATE_ROOT:-https://static.rust-lang.org/rustup}\"\r\n\r\n#XXX: If you change anything here, please make the same changes in setup_mode.rs\r\nusage() {\r\n    cat 1>&2 <<EOF\r\nrustup-init 1.25.1 (48d233f65 2022-07-12)\r\nThe installer for rustup\r\n\r\nUSAGE:\r\n    rustup-init [FLAGS] [OPTIONS]\r\n\r\nFLAGS:\r\n    -v, --verbose           Enable verbose output\r\n    -q, --quiet             Disable progress output\r\n    -y                      Disable confirmation prompt.\r\n        --no-modify-path    Don't configure the PATH environment variable\r\n    -h, --help              Prints help information\r\n    -V, --version           Prints version information\r\n\r\nOPTIONS:\r\n        --default-host <default-host>              Choose a default host triple\r\n        --default-toolchain <default-toolchain>    Choose a default toolchain to install\r\n        --default-toolchain none                   Do not install any toolchains\r\n        --profile [minimal|default|complete]       Choose a profile\r\n    -c, --component <components>...                Component name to also install\r\n    -t, --target <targets>...                      Target name to also install\r\nEOF\r\n}\r\n\r\nmain() {\r\n    downloader --check\r\n    need_cmd uname\r\n    need_cmd mktemp\r\n    need_cmd chmod\r\n    need_cmd mkdir\r\n    need_cmd rm\r\n    need_cmd rmdir\r\n\r\n    get_architecture || return 1\r\n    local _arch=\"$RETVAL\"\r\n    assert_nz \"$_arch\" \"arch\"\r\n\r\n    local _ext=\"\"\r\n    case \"$_arch\" in\r\n        *windows*)\r\n            _ext=\".exe\"\r\n            ;;\r\n    esac\r\n\r\n    local _url=\"${RUSTUP_UPDATE_ROOT}/dist/${_arch}/rustup-init${_ext}\"\r\n\r\n    local _dir\r\n    _dir=\"$(ensure mktemp -d)\"\r\n    local _file=\"${_dir}/rustup-init${_ext}\"\r\n\r\n    local _ansi_escapes_are_valid=false\r\n    if [ -t 2 ]; then\r\n        if [ \"${TERM+set}\" = 'set' ]; then\r\n            case \"$TERM\" in\r\n                xterm*|rxvt*|urxvt*|linux*|vt*)\r\n                    _ansi_escapes_are_valid=true\r\n                ;;\r\n            esac\r\n        fi\r\n    fi\r\n\r\n    # check if we have to use /dev/tty to prompt the user\r\n    local need_tty=yes\r\n    for arg in \"$@\"; do\r\n        case \"$arg\" in\r\n            --help)\r\n                usage\r\n                exit 0\r\n                ;;\r\n            *)\r\n                OPTIND=1\r\n                if [ \"${arg%%--*}\" = \"\" ]; then\r\n                    # Long option (other than --help);\r\n                    # don't attempt to interpret it.\r\n                    continue\r\n                fi\r\n                while getopts :hy sub_arg \"$arg\"; do\r\n                    case \"$sub_arg\" in\r\n                        h)\r\n                            usage\r\n                            exit 0\r\n                            ;;\r\n                        y)\r\n                            # user wants to skip the prompt --\r\n                            # we don't need /dev/tty\r\n                            need_tty=no\r\n                            ;;\r\n                        *)\r\n                            ;;\r\n                        esac\r\n                done\r\n                ;;\r\n        esac\r\n    done\r\n\r\n    if $_ansi_escapes_are_valid; then\r\n        printf \"\\33[1minfo:\\33[0m downloading installer\\n\" 1>&2\r\n    else\r\n        printf '%s\\n' 'info: downloading installer' 1>&2\r\n    fi\r\n\r\n    ensure mkdir -p \"$_dir\"\r\n    ensure downloader \"$_url\" \"$_file\" \"$_arch\"\r\n    ensure chmod u+x \"$_file\"\r\n    if [ ! -x \"$_file\" ]; then\r\n        printf '%s\\n' \"Cannot execute $_file (likely because of mounting /tmp as noexec).\" 1>&2\r\n        printf '%s\\n' \"Please copy the file to a location where you can execute binaries and run ./rustup-init${_ext}.\" 1>&2\r\n        exit 1\r\n    fi\r\n\r\n    if [ \"$need_tty\" = \"yes\" ] && [ ! -t 0 ]; then\r\n        # The installer is going to want to ask for confirmation by\r\n        # reading stdin.  This script was piped into `sh` though and\r\n        # doesn't have stdin to pass to its children. Instead we're going\r\n        # to explicitly connect /dev/tty to the installer's stdin.\r\n        if [ ! -t 1 ]; then\r\n            err \"Unable to run interactively. Run with -y to accept defaults, --help for additional options\"\r\n        fi\r\n\r\n        ignore \"$_file\" \"$@\" < /dev/tty\r\n    else\r\n        ignore \"$_file\" \"$@\"\r\n    fi\r\n\r\n    local _retval=$?\r\n\r\n    ignore rm \"$_file\"\r\n    ignore rmdir \"$_dir\"\r\n\r\n    return \"$_retval\"\r\n}\r\n\r\ncheck_proc() {\r\n    # Check for /proc by looking for the /proc/self/exe link\r\n    # This is only run on Linux\r\n    if ! test -L /proc/self/exe ; then\r\n        err \"fatal: Unable to find /proc/self/exe.  Is /proc mounted?  Installation cannot proceed without /proc.\"\r\n    fi\r\n}\r\n\r\nget_bitness() {\r\n    need_cmd head\r\n    # Architecture detection without dependencies beyond coreutils.\r\n    # ELF files start out \"\\x7fELF\", and the following byte is\r\n    #   0x01 for 32-bit and\r\n    #   0x02 for 64-bit.\r\n    # The printf builtin on some shells like dash only supports octal\r\n    # escape sequences, so we use those.\r\n    local _current_exe_head\r\n    _current_exe_head=$(head -c 5 /proc/self/exe )\r\n    if [ \"$_current_exe_head\" = \"$(printf '\\177ELF\\001')\" ]; then\r\n        echo 32\r\n    elif [ \"$_current_exe_head\" = \"$(printf '\\177ELF\\002')\" ]; then\r\n        echo 64\r\n    else\r\n        err \"unknown platform bitness\"\r\n    fi\r\n}\r\n\r\nis_host_amd64_elf() {\r\n    need_cmd head\r\n    need_cmd tail\r\n    # ELF e_machine detection without dependencies beyond coreutils.\r\n    # Two-byte field at offset 0x12 indicates the CPU,\r\n    # but we're interested in it being 0x3E to indicate amd64, or not that.\r\n    local _current_exe_machine\r\n    _current_exe_machine=$(head -c 19 /proc/self/exe | tail -c 1)\r\n    [ \"$_current_exe_machine\" = \"$(printf '\\076')\" ]\r\n}\r\n\r\nget_endianness() {\r\n    local cputype=$1\r\n    local suffix_eb=$2\r\n    local suffix_el=$3\r\n\r\n    # detect endianness without od/hexdump, like get_bitness() does.\r\n    need_cmd head\r\n    need_cmd tail\r\n\r\n    local _current_exe_endianness\r\n    _current_exe_endianness=\"$(head -c 6 /proc/self/exe | tail -c 1)\"\r\n    if [ \"$_current_exe_endianness\" = \"$(printf '\\001')\" ]; then\r\n        echo \"${cputype}${suffix_el}\"\r\n    elif [ \"$_current_exe_endianness\" = \"$(printf '\\002')\" ]; then\r\n        echo \"${cputype}${suffix_eb}\"\r\n    else\r\n        err \"unknown platform endianness\"\r\n    fi\r\n}\r\n\r\nget_architecture() {\r\n    local _ostype _cputype _bitness _arch _clibtype\r\n    _ostype=\"$(uname -s)\"\r\n    _cputype=\"$(uname -m)\"\r\n    _clibtype=\"gnu\"\r\n\r\n    if [ \"$_ostype\" = Linux ]; then\r\n        if [ \"$(uname -o)\" = Android ]; then\r\n            _ostype=Android\r\n        fi\r\n        if ldd --version 2>&1 | grep -q 'musl'; then\r\n            _clibtype=\"musl\"\r\n        fi\r\n    fi\r\n\r\n    if [ \"$_ostype\" = Darwin ] && [ \"$_cputype\" = i386 ]; then\r\n        # Darwin `uname -m` lies\r\n        if sysctl hw.optional.x86_64 | grep -q ': 1'; then\r\n            _cputype=x86_64\r\n        fi\r\n    fi\r\n\r\n    if [ \"$_ostype\" = SunOS ]; then\r\n        # Both Solaris and illumos presently announce as \"SunOS\" in \"uname -s\"\r\n        # so use \"uname -o\" to disambiguate.  We use the full path to the\r\n        # system uname in case the user has coreutils uname first in PATH,\r\n        # which has historically sometimes printed the wrong value here.\r\n        if [ \"$(/usr/bin/uname -o)\" = illumos ]; then\r\n            _ostype=illumos\r\n        fi\r\n\r\n        # illumos systems have multi-arch userlands, and \"uname -m\" reports the\r\n        # machine hardware name; e.g., \"i86pc\" on both 32- and 64-bit x86\r\n        # systems.  Check for the native (widest) instruction set on the\r\n        # running kernel:\r\n        if [ \"$_cputype\" = i86pc ]; then\r\n            _cputype=\"$(isainfo -n)\"\r\n        fi\r\n    fi\r\n\r\n    case \"$_ostype\" in\r\n\r\n        Android)\r\n            _ostype=linux-android\r\n            ;;\r\n\r\n        Linux)\r\n            check_proc\r\n            _ostype=unknown-linux-$_clibtype\r\n            _bitness=$(get_bitness)\r\n            ;;\r\n\r\n        FreeBSD)\r\n            _ostype=unknown-freebsd\r\n            ;;\r\n\r\n        NetBSD)\r\n            _ostype=unknown-netbsd\r\n            ;;\r\n\r\n        DragonFly)\r\n            _ostype=unknown-dragonfly\r\n            ;;\r\n\r\n        Darwin)\r\n            _ostype=apple-darwin\r\n            ;;\r\n\r\n        illumos)\r\n            _ostype=unknown-illumos\r\n            ;;\r\n\r\n        MINGW* | MSYS* | CYGWIN* | Windows_NT)\r\n            _ostype=pc-windows-gnu\r\n            ;;\r\n\r\n        *)\r\n            err \"unrecognized OS type: $_ostype\"\r\n            ;;\r\n\r\n    esac\r\n\r\n    case \"$_cputype\" in\r\n\r\n        i386 | i486 | i686 | i786 | x86)\r\n            _cputype=i686\r\n            ;;\r\n\r\n        xscale | arm)\r\n            _cputype=arm\r\n            if [ \"$_ostype\" = \"linux-android\" ]; then\r\n                _ostype=linux-androideabi\r\n            fi\r\n            ;;\r\n\r\n        armv6l)\r\n            _cputype=arm\r\n            if [ \"$_ostype\" = \"linux-android\" ]; then\r\n                _ostype=linux-androideabi\r\n            else\r\n                _ostype=\"${_ostype}eabihf\"\r\n            fi\r\n            ;;\r\n\r\n        armv7l | armv8l)\r\n            _cputype=armv7\r\n            if [ \"$_ostype\" = \"linux-android\" ]; then\r\n                _ostype=linux-androideabi\r\n            else\r\n                _ostype=\"${_ostype}eabihf\"\r\n            fi\r\n            ;;\r\n\r\n        aarch64 | arm64)\r\n            _cputype=aarch64\r\n            ;;\r\n\r\n        x86_64 | x86-64 | x64 | amd64)\r\n            _cputype=x86_64\r\n            ;;\r\n\r\n        mips)\r\n            _cputype=$(get_endianness mips '' el)\r\n            ;;\r\n\r\n        mips64)\r\n            if [ \"$_bitness\" -eq 64 ]; then\r\n                # only n64 ABI is supported for now\r\n                _ostype=\"${_ostype}abi64\"\r\n                _cputype=$(get_endianness mips64 '' el)\r\n            fi\r\n            ;;\r\n\r\n        ppc)\r\n            _cputype=powerpc\r\n            ;;\r\n\r\n        ppc64)\r\n            _cputype=powerpc64\r\n            ;;\r\n\r\n        ppc64le)\r\n            _cputype=powerpc64le\r\n            ;;\r\n\r\n        s390x)\r\n            _cputype=s390x\r\n            ;;\r\n        riscv64)\r\n            _cputype=riscv64gc\r\n            ;;\r\n        *)\r\n            err \"unknown CPU type: $_cputype\"\r\n\r\n    esac\r\n\r\n    # Detect 64-bit linux with 32-bit userland\r\n    if [ \"${_ostype}\" = unknown-linux-gnu ] && [ \"${_bitness}\" -eq 32 ]; then\r\n        case $_cputype in\r\n            x86_64)\r\n                if [ -n \"${RUSTUP_CPUTYPE:-}\" ]; then\r\n                    _cputype=\"$RUSTUP_CPUTYPE\"\r\n                else {\r\n                    # 32-bit executable for amd64 = x32\r\n                    if is_host_amd64_elf; then {\r\n                         echo \"This host is running an x32 userland; as it stands, x32 support is poor,\" 1>&2\r\n                         echo \"and there isn't a native toolchain -- you will have to install\" 1>&2\r\n                         echo \"multiarch compatibility with i686 and/or amd64, then select one\" 1>&2\r\n                         echo \"by re-running this script with the RUSTUP_CPUTYPE environment variable\" 1>&2\r\n                         echo \"set to i686 or x86_64, respectively.\" 1>&2\r\n                         echo 1>&2\r\n                         echo \"You will be able to add an x32 target after installation by running\" 1>&2\r\n                         echo \"  rustup target add x86_64-unknown-linux-gnux32\" 1>&2\r\n                         exit 1\r\n                    }; else\r\n                        _cputype=i686\r\n                    fi\r\n                }; fi\r\n                ;;\r\n            mips64)\r\n                _cputype=$(get_endianness mips '' el)\r\n                ;;\r\n            powerpc64)\r\n                _cputype=powerpc\r\n                ;;\r\n            aarch64)\r\n                _cputype=armv7\r\n                if [ \"$_ostype\" = \"linux-android\" ]; then\r\n                    _ostype=linux-androideabi\r\n                else\r\n                    _ostype=\"${_ostype}eabihf\"\r\n                fi\r\n                ;;\r\n            riscv64gc)\r\n                err \"riscv64 with 32-bit userland unsupported\"\r\n                ;;\r\n        esac\r\n    fi\r\n\r\n    # Detect armv7 but without the CPU features Rust needs in that build,\r\n    # and fall back to arm.\r\n    # See https://github.com/rust-lang/rustup.rs/issues/587.\r\n    if [ \"$_ostype\" = \"unknown-linux-gnueabihf\" ] && [ \"$_cputype\" = armv7 ]; then\r\n        if ensure grep '^Features' /proc/cpuinfo | grep -q -v neon; then\r\n            # At least one processor does not have NEON.\r\n            _cputype=arm\r\n        fi\r\n    fi\r\n\r\n    _arch=\"${_cputype}-${_ostype}\"\r\n\r\n    RETVAL=\"$_arch\"\r\n}\r\n\r\nsay() {\r\n    printf 'rustup: %s\\n' \"$1\"\r\n}\r\n\r\nerr() {\r\n    say \"$1\" >&2\r\n    exit 1\r\n}\r\n\r\nneed_cmd() {\r\n    if ! check_cmd \"$1\"; then\r\n        err \"need '$1' (command not found)\"\r\n    fi\r\n}\r\n\r\ncheck_cmd() {\r\n    command -v \"$1\" > /dev/null 2>&1\r\n}\r\n\r\nassert_nz() {\r\n    if [ -z \"$1\" ]; then err \"assert_nz $2\"; fi\r\n}\r\n\r\n# Run a command that should never fail. If the command fails execution\r\n# will immediately terminate with an error showing the failing\r\n# command.\r\nensure() {\r\n    if ! \"$@\"; then err \"command failed: $*\"; fi\r\n}\r\n\r\n# This is just for indicating that commands' results are being\r\n# intentionally ignored. Usually, because it's being executed\r\n# as part of error handling.\r\nignore() {\r\n    \"$@\"\r\n}\r\n\r\n# This wraps curl or wget. Try curl first, if not installed,\r\n# use wget instead.\r\ndownloader() {\r\n    local _dld\r\n    local _ciphersuites\r\n    local _err\r\n    local _status\r\n    local _retry\r\n    if check_cmd curl; then\r\n        _dld=curl\r\n    elif check_cmd wget; then\r\n        _dld=wget\r\n    else\r\n        _dld='curl or wget' # to be used in error message of need_cmd\r\n    fi\r\n\r\n    if [ \"$1\" = --check ]; then\r\n        need_cmd \"$_dld\"\r\n    elif [ \"$_dld\" = curl ]; then\r\n        check_curl_for_retry_support\r\n        _retry=\"$RETVAL\"\r\n        get_ciphersuites_for_curl\r\n        _ciphersuites=\"$RETVAL\"\r\n        if [ -n \"$_ciphersuites\" ]; then\r\n            _err=$(curl $_retry --proto '=https' --tlsv1.2 --ciphers \"$_ciphersuites\" --silent --show-error --fail --location \"$1\" --output \"$2\" 2>&1)\r\n            _status=$?\r\n        else\r\n            echo \"Warning: Not enforcing strong cipher suites for TLS, this is potentially less secure\"\r\n            if ! check_help_for \"$3\" curl --proto --tlsv1.2; then\r\n                echo \"Warning: Not enforcing TLS v1.2, this is potentially less secure\"\r\n                _err=$(curl $_retry --silent --show-error --fail --location \"$1\" --output \"$2\" 2>&1)\r\n                _status=$?\r\n            else\r\n                _err=$(curl $_retry --proto '=https' --tlsv1.2 --silent --show-error --fail --location \"$1\" --output \"$2\" 2>&1)\r\n                _status=$?\r\n            fi\r\n        fi\r\n        if [ -n \"$_err\" ]; then\r\n            echo \"$_err\" >&2\r\n            if echo \"$_err\" | grep -q 404$; then\r\n                err \"installer for platform '$3' not found, this may be unsupported\"\r\n            fi\r\n        fi\r\n        return $_status\r\n    elif [ \"$_dld\" = wget ]; then\r\n        if [ \"$(wget -V 2>&1|head -2|tail -1|cut -f1 -d\" \")\" = \"BusyBox\" ]; then\r\n            echo \"Warning: using the BusyBox version of wget.  Not enforcing strong cipher suites for TLS or TLS v1.2, this is potentially less secure\"\r\n            _err=$(wget \"$1\" -O \"$2\" 2>&1)\r\n            _status=$?\r\n        else\r\n            get_ciphersuites_for_wget\r\n            _ciphersuites=\"$RETVAL\"\r\n            if [ -n \"$_ciphersuites\" ]; then\r\n                _err=$(wget --https-only --secure-protocol=TLSv1_2 --ciphers \"$_ciphersuites\" \"$1\" -O \"$2\" 2>&1)\r\n                _status=$?\r\n            else\r\n                echo \"Warning: Not enforcing strong cipher suites for TLS, this is potentially less secure\"\r\n                if ! check_help_for \"$3\" wget --https-only --secure-protocol; then\r\n                    echo \"Warning: Not enforcing TLS v1.2, this is potentially less secure\"\r\n                    _err=$(wget \"$1\" -O \"$2\" 2>&1)\r\n                    _status=$?\r\n                else\r\n                    _err=$(wget --https-only --secure-protocol=TLSv1_2 \"$1\" -O \"$2\" 2>&1)\r\n                    _status=$?\r\n                fi\r\n            fi\r\n        fi\r\n        if [ -n \"$_err\" ]; then\r\n            echo \"$_err\" >&2\r\n            if echo \"$_err\" | grep -q ' 404 Not Found$'; then\r\n                err \"installer for platform '$3' not found, this may be unsupported\"\r\n            fi\r\n        fi\r\n        return $_status\r\n    else\r\n        err \"Unknown downloader\"   # should not reach here\r\n    fi\r\n}\r\n\r\ncheck_help_for() {\r\n    local _arch\r\n    local _cmd\r\n    local _arg\r\n    _arch=\"$1\"\r\n    shift\r\n    _cmd=\"$1\"\r\n    shift\r\n\r\n    local _category\r\n    if \"$_cmd\" --help | grep -q 'For all options use the manual or \"--help all\".'; then\r\n      _category=\"all\"\r\n    else\r\n      _category=\"\"\r\n    fi\r\n\r\n    case \"$_arch\" in\r\n\r\n        *darwin*)\r\n        if check_cmd sw_vers; then\r\n            case $(sw_vers -productVersion) in\r\n                10.*)\r\n                    # If we're running on macOS, older than 10.13, then we always\r\n                    # fail to find these options to force fallback\r\n                    if [ \"$(sw_vers -productVersion | cut -d. -f2)\" -lt 13 ]; then\r\n                        # Older than 10.13\r\n                        echo \"Warning: Detected macOS platform older than 10.13\"\r\n                        return 1\r\n                    fi\r\n                    ;;\r\n                11.*)\r\n                    # We assume Big Sur will be OK for now\r\n                    ;;\r\n                *)\r\n                    # Unknown product version, warn and continue\r\n                    echo \"Warning: Detected unknown macOS major version: $(sw_vers -productVersion)\"\r\n                    echo \"Warning TLS capabilities detection may fail\"\r\n                    ;;\r\n            esac\r\n        fi\r\n        ;;\r\n\r\n    esac\r\n\r\n    for _arg in \"$@\"; do\r\n        if ! \"$_cmd\" --help $_category | grep -q -- \"$_arg\"; then\r\n            return 1\r\n        fi\r\n    done\r\n\r\n    true # not strictly needed\r\n}\r\n\r\n# Check if curl supports the --retry flag, then pass it to the curl invocation.\r\ncheck_curl_for_retry_support() {\r\n  local _retry_supported=\"\"\r\n  # \"unspecified\" is for arch, allows for possibility old OS using macports, homebrew, etc.\r\n  if check_help_for \"notspecified\" \"curl\" \"--retry\"; then\r\n    _retry_supported=\"--retry 3\"\r\n  fi\r\n\r\n  RETVAL=\"$_retry_supported\"\r\n\r\n}\r\n\r\n# Return cipher suite string specified by user, otherwise return strong TLS 1.2-1.3 cipher suites\r\n# if support by local tools is detected. Detection currently supports these curl backends:\r\n# GnuTLS and OpenSSL (possibly also LibreSSL and BoringSSL). Return value can be empty.\r\nget_ciphersuites_for_curl() {\r\n    if [ -n \"${RUSTUP_TLS_CIPHERSUITES-}\" ]; then\r\n        # user specified custom cipher suites, assume they know what they're doing\r\n        RETVAL=\"$RUSTUP_TLS_CIPHERSUITES\"\r\n        return\r\n    fi\r\n\r\n    local _openssl_syntax=\"no\"\r\n    local _gnutls_syntax=\"no\"\r\n    local _backend_supported=\"yes\"\r\n    if curl -V | grep -q ' OpenSSL/'; then\r\n        _openssl_syntax=\"yes\"\r\n    elif curl -V | grep -iq ' LibreSSL/'; then\r\n        _openssl_syntax=\"yes\"\r\n    elif curl -V | grep -iq ' BoringSSL/'; then\r\n        _openssl_syntax=\"yes\"\r\n    elif curl -V | grep -iq ' GnuTLS/'; then\r\n        _gnutls_syntax=\"yes\"\r\n    else\r\n        _backend_supported=\"no\"\r\n    fi\r\n\r\n    local _args_supported=\"no\"\r\n    if [ \"$_backend_supported\" = \"yes\" ]; then\r\n        # \"unspecified\" is for arch, allows for possibility old OS using macports, homebrew, etc.\r\n        if check_help_for \"notspecified\" \"curl\" \"--tlsv1.2\" \"--ciphers\" \"--proto\"; then\r\n            _args_supported=\"yes\"\r\n        fi\r\n    fi\r\n\r\n    local _cs=\"\"\r\n    if [ \"$_args_supported\" = \"yes\" ]; then\r\n        if [ \"$_openssl_syntax\" = \"yes\" ]; then\r\n            _cs=$(get_strong_ciphersuites_for \"openssl\")\r\n        elif [ \"$_gnutls_syntax\" = \"yes\" ]; then\r\n            _cs=$(get_strong_ciphersuites_for \"gnutls\")\r\n        fi\r\n    fi\r\n\r\n    RETVAL=\"$_cs\"\r\n}\r\n\r\n# Return cipher suite string specified by user, otherwise return strong TLS 1.2-1.3 cipher suites\r\n# if support by local tools is detected. Detection currently supports these wget backends:\r\n# GnuTLS and OpenSSL (possibly also LibreSSL and BoringSSL). Return value can be empty.\r\nget_ciphersuites_for_wget() {\r\n    if [ -n \"${RUSTUP_TLS_CIPHERSUITES-}\" ]; then\r\n        # user specified custom cipher suites, assume they know what they're doing\r\n        RETVAL=\"$RUSTUP_TLS_CIPHERSUITES\"\r\n        return\r\n    fi\r\n\r\n    local _cs=\"\"\r\n    if wget -V | grep -q '\\-DHAVE_LIBSSL'; then\r\n        # \"unspecified\" is for arch, allows for possibility old OS using macports, homebrew, etc.\r\n        if check_help_for \"notspecified\" \"wget\" \"TLSv1_2\" \"--ciphers\" \"--https-only\" \"--secure-protocol\"; then\r\n            _cs=$(get_strong_ciphersuites_for \"openssl\")\r\n        fi\r\n    elif wget -V | grep -q '\\-DHAVE_LIBGNUTLS'; then\r\n        # \"unspecified\" is for arch, allows for possibility old OS using macports, homebrew, etc.\r\n        if check_help_for \"notspecified\" \"wget\" \"TLSv1_2\" \"--ciphers\" \"--https-only\" \"--secure-protocol\"; then\r\n            _cs=$(get_strong_ciphersuites_for \"gnutls\")\r\n        fi\r\n    fi\r\n\r\n    RETVAL=\"$_cs\"\r\n}\r\n\r\n# Return strong TLS 1.2-1.3 cipher suites in OpenSSL or GnuTLS syntax. TLS 1.2\r\n# excludes non-ECDHE and non-AEAD cipher suites. DHE is excluded due to bad\r\n# DH params often found on servers (see RFC 7919). Sequence matches or is\r\n# similar to Firefox 68 ESR with weak cipher suites disabled via about:config.\r\n# $1 must be openssl or gnutls.\r\nget_strong_ciphersuites_for() {\r\n    if [ \"$1\" = \"openssl\" ]; then\r\n        # OpenSSL is forgiving of unknown values, no problems with TLS 1.3 values on versions that don't support it yet.\r\n        echo \"TLS_AES_128_GCM_SHA256:TLS_CHACHA20_POLY1305_SHA256:TLS_AES_256_GCM_SHA384:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384\"\r\n    elif [ \"$1\" = \"gnutls\" ]; then\r\n        # GnuTLS isn't forgiving of unknown values, so this may require a GnuTLS version that supports TLS 1.3 even if wget doesn't.\r\n        # Begin with SECURE128 (and higher) then remove/add to build cipher suites. Produces same 9 cipher suites as OpenSSL but in slightly different order.\r\n        echo \"SECURE128:-VERS-SSL3.0:-VERS-TLS1.0:-VERS-TLS1.1:-VERS-DTLS-ALL:-CIPHER-ALL:-MAC-ALL:-KX-ALL:+AEAD:+ECDHE-ECDSA:+ECDHE-RSA:+AES-128-GCM:+CHACHA20-POLY1305:+AES-256-GCM\"\r\n    fi\r\n}\r\n\r\nmain \"$@\" || exit 1\r\ncurl: (1) Protocol \"http\" not supported or disabled in libcurl\r\ncurl: (1) Protocol \"http\" not supported or disabled in libcurl", "stdout_lines": ["#!/bin/sh", "# shellcheck shell=dash", "", "# This is just a little script that can be downloaded from the internet to", "# install rustup. It just does platform detection, downloads the installer", "# and runs it.", "", "# It runs on Unix shells like {a,ba,da,k,z}sh. It uses the common `local`", "# extension. Note: Most shells limit `local` to 1 var per line, contra bash.", "", "if [ \"$KSH_VERSION\" = 'Version JM 93t+ 2010-03-05' ]; then", "    # The version of ksh93 that ships with many illumos systems does not", "    # support the \"local\" extension.  Print a message rather than fail in", "    # subtle ways later on:", "    echo 'rustup does not work with this ksh93 version; please try bash!' >&2", "    exit 1", "fi", "", "", "set -u", "", "# If RUSTUP_UPDATE_ROOT is unset or empty, default it.", "RUSTUP_UPDATE_ROOT=\"${RUSTUP_UPDATE_ROOT:-https://static.rust-lang.org/rustup}\"", "", "#XXX: If you change anything here, please make the same changes in setup_mode.rs", "usage() {", "    cat 1>&2 <<EOF", "rustup-init 1.25.1 (48d233f65 2022-07-12)", "The installer for rustup", "", "USAGE:", "    rustup-init [FLAGS] [OPTIONS]", "", "FLAGS:", "    -v, --verbose           Enable verbose output", "    -q, --quiet             Disable progress output", "    -y                      Disable confirmation prompt.", "        --no-modify-path    Don't configure the PATH environment variable", "    -h, --help              Prints help information", "    -V, --version           Prints version information", "", "OPTIONS:", "        --default-host <default-host>              Choose a default host triple", "        --default-toolchain <default-toolchain>    Choose a default toolchain to install", "        --default-toolchain none                   Do not install any toolchains", "        --profile [minimal|default|complete]       Choose a profile", "    -c, --component <components>...                Component name to also install", "    -t, --target <targets>...                      Target name to also install", "EOF", "}", "", "main() {", "    downloader --check", "    need_cmd uname", "    need_cmd mktemp", "    need_cmd chmod", "    need_cmd mkdir", "    need_cmd rm", "    need_cmd rmdir", "", "    get_architecture || return 1", "    local _arch=\"$RETVAL\"", "    assert_nz \"$_arch\" \"arch\"", "", "    local _ext=\"\"", "    case \"$_arch\" in", "        *windows*)", "            _ext=\".exe\"", "            ;;", "    esac", "", "    local _url=\"${RUSTUP_UPDATE_ROOT}/dist/${_arch}/rustup-init${_ext}\"", "", "    local _dir", "    _dir=\"$(ensure mktemp -d)\"", "    local _file=\"${_dir}/rustup-init${_ext}\"", "", "    local _ansi_escapes_are_valid=false", "    if [ -t 2 ]; then", "        if [ \"${TERM+set}\" = 'set' ]; then", "            case \"$TERM\" in", "                xterm*|rxvt*|urxvt*|linux*|vt*)", "                    _ansi_escapes_are_valid=true", "                ;;", "            esac", "        fi", "    fi", "", "    # check if we have to use /dev/tty to prompt the user", "    local need_tty=yes", "    for arg in \"$@\"; do", "        case \"$arg\" in", "            --help)", "                usage", "                exit 0", "                ;;", "            *)", "                OPTIND=1", "                if [ \"${arg%%--*}\" = \"\" ]; then", "                    # Long option (other than --help);", "                    # don't attempt to interpret it.", "                    continue", "                fi", "                while getopts :hy sub_arg \"$arg\"; do", "                    case \"$sub_arg\" in", "                        h)", "                            usage", "                            exit 0", "                            ;;", "                        y)", "                            # user wants to skip the prompt --", "                            # we don't need /dev/tty", "                            need_tty=no", "                            ;;", "                        *)", "                            ;;", "                        esac", "                done", "                ;;", "        esac", "    done", "", "    if $_ansi_escapes_are_valid; then", "        printf \"\\33[1minfo:\\33[0m downloading installer\\n\" 1>&2", "    else", "        printf '%s\\n' 'info: downloading installer' 1>&2", "    fi", "", "    ensure mkdir -p \"$_dir\"", "    ensure downloader \"$_url\" \"$_file\" \"$_arch\"", "    ensure chmod u+x \"$_file\"", "    if [ ! -x \"$_file\" ]; then", "        printf '%s\\n' \"Cannot execute $_file (likely because of mounting /tmp as noexec).\" 1>&2", "        printf '%s\\n' \"Please copy the file to a location where you can execute binaries and run ./rustup-init${_ext}.\" 1>&2", "        exit 1", "    fi", "", "    if [ \"$need_tty\" = \"yes\" ] && [ ! -t 0 ]; then", "        # The installer is going to want to ask for confirmation by", "        # reading stdin.  This script was piped into `sh` though and", "        # doesn't have stdin to pass to its children. Instead we're going", "        # to explicitly connect /dev/tty to the installer's stdin.", "        if [ ! -t 1 ]; then", "            err \"Unable to run interactively. Run with -y to accept defaults, --help for additional options\"", "        fi", "", "        ignore \"$_file\" \"$@\" < /dev/tty", "    else", "        ignore \"$_file\" \"$@\"", "    fi", "", "    local _retval=$?", "", "    ignore rm \"$_file\"", "    ignore rmdir \"$_dir\"", "", "    return \"$_retval\"", "}", "", "check_proc() {", "    # Check for /proc by looking for the /proc/self/exe link", "    # This is only run on Linux", "    if ! test -L /proc/self/exe ; then", "        err \"fatal: Unable to find /proc/self/exe.  Is /proc mounted?  Installation cannot proceed without /proc.\"", "    fi", "}", "", "get_bitness() {", "    need_cmd head", "    # Architecture detection without dependencies beyond coreutils.", "    # ELF files start out \"\\x7fELF\", and the following byte is", "    #   0x01 for 32-bit and", "    #   0x02 for 64-bit.", "    # The printf builtin on some shells like dash only supports octal", "    # escape sequences, so we use those.", "    local _current_exe_head", "    _current_exe_head=$(head -c 5 /proc/self/exe )", "    if [ \"$_current_exe_head\" = \"$(printf '\\177ELF\\001')\" ]; then", "        echo 32", "    elif [ \"$_current_exe_head\" = \"$(printf '\\177ELF\\002')\" ]; then", "        echo 64", "    else", "        err \"unknown platform bitness\"", "    fi", "}", "", "is_host_amd64_elf() {", "    need_cmd head", "    need_cmd tail", "    # ELF e_machine detection without dependencies beyond coreutils.", "    # Two-byte field at offset 0x12 indicates the CPU,", "    # but we're interested in it being 0x3E to indicate amd64, or not that.", "    local _current_exe_machine", "    _current_exe_machine=$(head -c 19 /proc/self/exe | tail -c 1)", "    [ \"$_current_exe_machine\" = \"$(printf '\\076')\" ]", "}", "", "get_endianness() {", "    local cputype=$1", "    local suffix_eb=$2", "    local suffix_el=$3", "", "    # detect endianness without od/hexdump, like get_bitness() does.", "    need_cmd head", "    need_cmd tail", "", "    local _current_exe_endianness", "    _current_exe_endianness=\"$(head -c 6 /proc/self/exe | tail -c 1)\"", "    if [ \"$_current_exe_endianness\" = \"$(printf '\\001')\" ]; then", "        echo \"${cputype}${suffix_el}\"", "    elif [ \"$_current_exe_endianness\" = \"$(printf '\\002')\" ]; then", "        echo \"${cputype}${suffix_eb}\"", "    else", "        err \"unknown platform endianness\"", "    fi", "}", "", "get_architecture() {", "    local _ostype _cputype _bitness _arch _clibtype", "    _ostype=\"$(uname -s)\"", "    _cputype=\"$(uname -m)\"", "    _clibtype=\"gnu\"", "", "    if [ \"$_ostype\" = Linux ]; then", "        if [ \"$(uname -o)\" = Android ]; then", "            _ostype=Android", "        fi", "        if ldd --version 2>&1 | grep -q 'musl'; then", "            _clibtype=\"musl\"", "        fi", "    fi", "", "    if [ \"$_ostype\" = Darwin ] && [ \"$_cputype\" = i386 ]; then", "        # Darwin `uname -m` lies", "        if sysctl hw.optional.x86_64 | grep -q ': 1'; then", "            _cputype=x86_64", "        fi", "    fi", "", "    if [ \"$_ostype\" = SunOS ]; then", "        # Both Solaris and illumos presently announce as \"SunOS\" in \"uname -s\"", "        # so use \"uname -o\" to disambiguate.  We use the full path to the", "        # system uname in case the user has coreutils uname first in PATH,", "        # which has historically sometimes printed the wrong value here.", "        if [ \"$(/usr/bin/uname -o)\" = illumos ]; then", "            _ostype=illumos", "        fi", "", "        # illumos systems have multi-arch userlands, and \"uname -m\" reports the", "        # machine hardware name; e.g., \"i86pc\" on both 32- and 64-bit x86", "        # systems.  Check for the native (widest) instruction set on the", "        # running kernel:", "        if [ \"$_cputype\" = i86pc ]; then", "            _cputype=\"$(isainfo -n)\"", "        fi", "    fi", "", "    case \"$_ostype\" in", "", "        Android)", "            _ostype=linux-android", "            ;;", "", "        Linux)", "            check_proc", "            _ostype=unknown-linux-$_clibtype", "            _bitness=$(get_bitness)", "            ;;", "", "        FreeBSD)", "            _ostype=unknown-freebsd", "            ;;", "", "        NetBSD)", "            _ostype=unknown-netbsd", "            ;;", "", "        DragonFly)", "            _ostype=unknown-dragonfly", "            ;;", "", "        Darwin)", "            _ostype=apple-darwin", "            ;;", "", "        illumos)", "            _ostype=unknown-illumos", "            ;;", "", "        MINGW* | MSYS* | CYGWIN* | Windows_NT)", "            _ostype=pc-windows-gnu", "            ;;", "", "        *)", "            err \"unrecognized OS type: $_ostype\"", "            ;;", "", "    esac", "", "    case \"$_cputype\" in", "", "        i386 | i486 | i686 | i786 | x86)", "            _cputype=i686", "            ;;", "", "        xscale | arm)", "            _cputype=arm", "            if [ \"$_ostype\" = \"linux-android\" ]; then", "                _ostype=linux-androideabi", "            fi", "            ;;", "", "        armv6l)", "            _cputype=arm", "            if [ \"$_ostype\" = \"linux-android\" ]; then", "                _ostype=linux-androideabi", "            else", "                _ostype=\"${_ostype}eabihf\"", "            fi", "            ;;", "", "        armv7l | armv8l)", "            _cputype=armv7", "            if [ \"$_ostype\" = \"linux-android\" ]; then", "                _ostype=linux-androideabi", "            else", "                _ostype=\"${_ostype}eabihf\"", "            fi", "            ;;", "", "        aarch64 | arm64)", "            _cputype=aarch64", "            ;;", "", "        x86_64 | x86-64 | x64 | amd64)", "            _cputype=x86_64", "            ;;", "", "        mips)", "            _cputype=$(get_endianness mips '' el)", "            ;;", "", "        mips64)", "            if [ \"$_bitness\" -eq 64 ]; then", "                # only n64 ABI is supported for now", "                _ostype=\"${_ostype}abi64\"", "                _cputype=$(get_endianness mips64 '' el)", "            fi", "            ;;", "", "        ppc)", "            _cputype=powerpc", "            ;;", "", "        ppc64)", "            _cputype=powerpc64", "            ;;", "", "        ppc64le)", "            _cputype=powerpc64le", "            ;;", "", "        s390x)", "            _cputype=s390x", "            ;;", "        riscv64)", "            _cputype=riscv64gc", "            ;;", "        *)", "            err \"unknown CPU type: $_cputype\"", "", "    esac", "", "    # Detect 64-bit linux with 32-bit userland", "    if [ \"${_ostype}\" = unknown-linux-gnu ] && [ \"${_bitness}\" -eq 32 ]; then", "        case $_cputype in", "            x86_64)", "                if [ -n \"${RUSTUP_CPUTYPE:-}\" ]; then", "                    _cputype=\"$RUSTUP_CPUTYPE\"", "                else {", "                    # 32-bit executable for amd64 = x32", "                    if is_host_amd64_elf; then {", "                         echo \"This host is running an x32 userland; as it stands, x32 support is poor,\" 1>&2", "                         echo \"and there isn't a native toolchain -- you will have to install\" 1>&2", "                         echo \"multiarch compatibility with i686 and/or amd64, then select one\" 1>&2", "                         echo \"by re-running this script with the RUSTUP_CPUTYPE environment variable\" 1>&2", "                         echo \"set to i686 or x86_64, respectively.\" 1>&2", "                         echo 1>&2", "                         echo \"You will be able to add an x32 target after installation by running\" 1>&2", "                         echo \"  rustup target add x86_64-unknown-linux-gnux32\" 1>&2", "                         exit 1", "                    }; else", "                        _cputype=i686", "                    fi", "                }; fi", "                ;;", "            mips64)", "                _cputype=$(get_endianness mips '' el)", "                ;;", "            powerpc64)", "                _cputype=powerpc", "                ;;", "            aarch64)", "                _cputype=armv7", "                if [ \"$_ostype\" = \"linux-android\" ]; then", "                    _ostype=linux-androideabi", "                else", "                    _ostype=\"${_ostype}eabihf\"", "                fi", "                ;;", "            riscv64gc)", "                err \"riscv64 with 32-bit userland unsupported\"", "                ;;", "        esac", "    fi", "", "    # Detect armv7 but without the CPU features Rust needs in that build,", "    # and fall back to arm.", "    # See https://github.com/rust-lang/rustup.rs/issues/587.", "    if [ \"$_ostype\" = \"unknown-linux-gnueabihf\" ] && [ \"$_cputype\" = armv7 ]; then", "        if ensure grep '^Features' /proc/cpuinfo | grep -q -v neon; then", "            # At least one processor does not have NEON.", "            _cputype=arm", "        fi", "    fi", "", "    _arch=\"${_cputype}-${_ostype}\"", "", "    RETVAL=\"$_arch\"", "}", "", "say() {", "    printf 'rustup: %s\\n' \"$1\"", "}", "", "err() {", "    say \"$1\" >&2", "    exit 1", "}", "", "need_cmd() {", "    if ! check_cmd \"$1\"; then", "        err \"need '$1' (command not found)\"", "    fi", "}", "", "check_cmd() {", "    command -v \"$1\" > /dev/null 2>&1", "}", "", "assert_nz() {", "    if [ -z \"$1\" ]; then err \"assert_nz $2\"; fi", "}", "", "# Run a command that should never fail. If the command fails execution", "# will immediately terminate with an error showing the failing", "# command.", "ensure() {", "    if ! \"$@\"; then err \"command failed: $*\"; fi", "}", "", "# This is just for indicating that commands' results are being", "# intentionally ignored. Usually, because it's being executed", "# as part of error handling.", "ignore() {", "    \"$@\"", "}", "", "# This wraps curl or wget. Try curl first, if not installed,", "# use wget instead.", "downloader() {", "    local _dld", "    local _ciphersuites", "    local _err", "    local _status", "    local _retry", "    if check_cmd curl; then", "        _dld=curl", "    elif check_cmd wget; then", "        _dld=wget", "    else", "        _dld='curl or wget' # to be used in error message of need_cmd", "    fi", "", "    if [ \"$1\" = --check ]; then", "        need_cmd \"$_dld\"", "    elif [ \"$_dld\" = curl ]; then", "        check_curl_for_retry_support", "        _retry=\"$RETVAL\"", "        get_ciphersuites_for_curl", "        _ciphersuites=\"$RETVAL\"", "        if [ -n \"$_ciphersuites\" ]; then", "            _err=$(curl $_retry --proto '=https' --tlsv1.2 --ciphers \"$_ciphersuites\" --silent --show-error --fail --location \"$1\" --output \"$2\" 2>&1)", "            _status=$?", "        else", "            echo \"Warning: Not enforcing strong cipher suites for TLS, this is potentially less secure\"", "            if ! check_help_for \"$3\" curl --proto --tlsv1.2; then", "                echo \"Warning: Not enforcing TLS v1.2, this is potentially less secure\"", "                _err=$(curl $_retry --silent --show-error --fail --location \"$1\" --output \"$2\" 2>&1)", "                _status=$?", "            else", "                _err=$(curl $_retry --proto '=https' --tlsv1.2 --silent --show-error --fail --location \"$1\" --output \"$2\" 2>&1)", "                _status=$?", "            fi", "        fi", "        if [ -n \"$_err\" ]; then", "            echo \"$_err\" >&2", "            if echo \"$_err\" | grep -q 404$; then", "                err \"installer for platform '$3' not found, this may be unsupported\"", "            fi", "        fi", "        return $_status", "    elif [ \"$_dld\" = wget ]; then", "        if [ \"$(wget -V 2>&1|head -2|tail -1|cut -f1 -d\" \")\" = \"BusyBox\" ]; then", "            echo \"Warning: using the BusyBox version of wget.  Not enforcing strong cipher suites for TLS or TLS v1.2, this is potentially less secure\"", "            _err=$(wget \"$1\" -O \"$2\" 2>&1)", "            _status=$?", "        else", "            get_ciphersuites_for_wget", "            _ciphersuites=\"$RETVAL\"", "            if [ -n \"$_ciphersuites\" ]; then", "                _err=$(wget --https-only --secure-protocol=TLSv1_2 --ciphers \"$_ciphersuites\" \"$1\" -O \"$2\" 2>&1)", "                _status=$?", "            else", "                echo \"Warning: Not enforcing strong cipher suites for TLS, this is potentially less secure\"", "                if ! check_help_for \"$3\" wget --https-only --secure-protocol; then", "                    echo \"Warning: Not enforcing TLS v1.2, this is potentially less secure\"", "                    _err=$(wget \"$1\" -O \"$2\" 2>&1)", "                    _status=$?", "                else", "                    _err=$(wget --https-only --secure-protocol=TLSv1_2 \"$1\" -O \"$2\" 2>&1)", "                    _status=$?", "                fi", "            fi", "        fi", "        if [ -n \"$_err\" ]; then", "            echo \"$_err\" >&2", "            if echo \"$_err\" | grep -q ' 404 Not Found$'; then", "                err \"installer for platform '$3' not found, this may be unsupported\"", "            fi", "        fi", "        return $_status", "    else", "        err \"Unknown downloader\"   # should not reach here", "    fi", "}", "", "check_help_for() {", "    local _arch", "    local _cmd", "    local _arg", "    _arch=\"$1\"", "    shift", "    _cmd=\"$1\"", "    shift", "", "    local _category", "    if \"$_cmd\" --help | grep -q 'For all options use the manual or \"--help all\".'; then", "      _category=\"all\"", "    else", "      _category=\"\"", "    fi", "", "    case \"$_arch\" in", "", "        *darwin*)", "        if check_cmd sw_vers; then", "            case $(sw_vers -productVersion) in", "                10.*)", "                    # If we're running on macOS, older than 10.13, then we always", "                    # fail to find these options to force fallback", "                    if [ \"$(sw_vers -productVersion | cut -d. -f2)\" -lt 13 ]; then", "                        # Older than 10.13", "                        echo \"Warning: Detected macOS platform older than 10.13\"", "                        return 1", "                    fi", "                    ;;", "                11.*)", "                    # We assume Big Sur will be OK for now", "                    ;;", "                *)", "                    # Unknown product version, warn and continue", "                    echo \"Warning: Detected unknown macOS major version: $(sw_vers -productVersion)\"", "                    echo \"Warning TLS capabilities detection may fail\"", "                    ;;", "            esac", "        fi", "        ;;", "", "    esac", "", "    for _arg in \"$@\"; do", "        if ! \"$_cmd\" --help $_category | grep -q -- \"$_arg\"; then", "            return 1", "        fi", "    done", "", "    true # not strictly needed", "}", "", "# Check if curl supports the --retry flag, then pass it to the curl invocation.", "check_curl_for_retry_support() {", "  local _retry_supported=\"\"", "  # \"unspecified\" is for arch, allows for possibility old OS using macports, homebrew, etc.", "  if check_help_for \"notspecified\" \"curl\" \"--retry\"; then", "    _retry_supported=\"--retry 3\"", "  fi", "", "  RETVAL=\"$_retry_supported\"", "", "}", "", "# Return cipher suite string specified by user, otherwise return strong TLS 1.2-1.3 cipher suites", "# if support by local tools is detected. Detection currently supports these curl backends:", "# GnuTLS and OpenSSL (possibly also LibreSSL and BoringSSL). Return value can be empty.", "get_ciphersuites_for_curl() {", "    if [ -n \"${RUSTUP_TLS_CIPHERSUITES-}\" ]; then", "        # user specified custom cipher suites, assume they know what they're doing", "        RETVAL=\"$RUSTUP_TLS_CIPHERSUITES\"", "        return", "    fi", "", "    local _openssl_syntax=\"no\"", "    local _gnutls_syntax=\"no\"", "    local _backend_supported=\"yes\"", "    if curl -V | grep -q ' OpenSSL/'; then", "        _openssl_syntax=\"yes\"", "    elif curl -V | grep -iq ' LibreSSL/'; then", "        _openssl_syntax=\"yes\"", "    elif curl -V | grep -iq ' BoringSSL/'; then", "        _openssl_syntax=\"yes\"", "    elif curl -V | grep -iq ' GnuTLS/'; then", "        _gnutls_syntax=\"yes\"", "    else", "        _backend_supported=\"no\"", "    fi", "", "    local _args_supported=\"no\"", "    if [ \"$_backend_supported\" = \"yes\" ]; then", "        # \"unspecified\" is for arch, allows for possibility old OS using macports, homebrew, etc.", "        if check_help_for \"notspecified\" \"curl\" \"--tlsv1.2\" \"--ciphers\" \"--proto\"; then", "            _args_supported=\"yes\"", "        fi", "    fi", "", "    local _cs=\"\"", "    if [ \"$_args_supported\" = \"yes\" ]; then", "        if [ \"$_openssl_syntax\" = \"yes\" ]; then", "            _cs=$(get_strong_ciphersuites_for \"openssl\")", "        elif [ \"$_gnutls_syntax\" = \"yes\" ]; then", "            _cs=$(get_strong_ciphersuites_for \"gnutls\")", "        fi", "    fi", "", "    RETVAL=\"$_cs\"", "}", "", "# Return cipher suite string specified by user, otherwise return strong TLS 1.2-1.3 cipher suites", "# if support by local tools is detected. Detection currently supports these wget backends:", "# GnuTLS and OpenSSL (possibly also LibreSSL and BoringSSL). Return value can be empty.", "get_ciphersuites_for_wget() {", "    if [ -n \"${RUSTUP_TLS_CIPHERSUITES-}\" ]; then", "        # user specified custom cipher suites, assume they know what they're doing", "        RETVAL=\"$RUSTUP_TLS_CIPHERSUITES\"", "        return", "    fi", "", "    local _cs=\"\"", "    if wget -V | grep -q '\\-DHAVE_LIBSSL'; then", "        # \"unspecified\" is for arch, allows for possibility old OS using macports, homebrew, etc.", "        if check_help_for \"notspecified\" \"wget\" \"TLSv1_2\" \"--ciphers\" \"--https-only\" \"--secure-protocol\"; then", "            _cs=$(get_strong_ciphersuites_for \"openssl\")", "        fi", "    elif wget -V | grep -q '\\-DHAVE_LIBGNUTLS'; then", "        # \"unspecified\" is for arch, allows for possibility old OS using macports, homebrew, etc.", "        if check_help_for \"notspecified\" \"wget\" \"TLSv1_2\" \"--ciphers\" \"--https-only\" \"--secure-protocol\"; then", "            _cs=$(get_strong_ciphersuites_for \"gnutls\")", "        fi", "    fi", "", "    RETVAL=\"$_cs\"", "}", "", "# Return strong TLS 1.2-1.3 cipher suites in OpenSSL or GnuTLS syntax. TLS 1.2", "# excludes non-ECDHE and non-AEAD cipher suites. DHE is excluded due to bad", "# DH params often found on servers (see RFC 7919). Sequence matches or is", "# similar to Firefox 68 ESR with weak cipher suites disabled via about:config.", "# $1 must be openssl or gnutls.", "get_strong_ciphersuites_for() {", "    if [ \"$1\" = \"openssl\" ]; then", "        # OpenSSL is forgiving of unknown values, no problems with TLS 1.3 values on versions that don't support it yet.", "        echo \"TLS_AES_128_GCM_SHA256:TLS_CHACHA20_POLY1305_SHA256:TLS_AES_256_GCM_SHA384:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384\"", "    elif [ \"$1\" = \"gnutls\" ]; then", "        # GnuTLS isn't forgiving of unknown values, so this may require a GnuTLS version that supports TLS 1.3 even if wget doesn't.", "        # Begin with SECURE128 (and higher) then remove/add to build cipher suites. Produces same 9 cipher suites as OpenSSL but in slightly different order.", "        echo \"SECURE128:-VERS-SSL3.0:-VERS-TLS1.0:-VERS-TLS1.1:-VERS-DTLS-ALL:-CIPHER-ALL:-MAC-ALL:-KX-ALL:+AEAD:+ECDHE-ECDSA:+ECDHE-RSA:+AES-128-GCM:+CHACHA20-POLY1305:+AES-256-GCM\"", "    fi", "}", "", "main \"$@\" || exit 1", "curl: (1) Protocol \"http\" not supported or disabled in libcurl", "curl: (1) Protocol \"http\" not supported or disabled in libcurl"]}
2022-12-30 00:04:39,378 p=88111 u=kal n=ansible | PLAY RECAP *******************************************************************************************************************************************
2022-12-30 00:04:39,379 p=88111 u=kal n=ansible | krpz                       : ok=3    changed=0    unreachable=0    failed=1    skipped=0    rescued=0    ignored=0   
2022-12-30 00:05:00,771 p=88373 u=kal n=ansible | Using /home/kal/MyApplications/dotfiles/playbooks/ansible.cfg as config file
2022-12-30 00:05:00,842 p=88373 u=kal n=ansible | PLAY [localhost] *************************************************************************************************************************************
2022-12-30 00:05:00,849 p=88373 u=kal n=ansible | TASK [Gathering Facts] *******************************************************************************************************************************
2022-12-30 00:05:04,783 p=88373 u=kal n=ansible | ok: [krpz]
2022-12-30 00:05:04,809 p=88373 u=kal n=ansible | TASK [install pexpect] *******************************************************************************************************************************
2022-12-30 00:05:05,244 p=88373 u=kal n=ansible | ok: [krpz] => {"changed": false, "cmd": ["/usr/bin/python2", "-m", "pip.__main__", "install", "pexpect"], "name": ["pexpect"], "requirements": null, "state": "present", "stderr": "DEPRECATION: Python 2.7 reached the end of its life on January 1st, 2020. Please upgrade your Python as Python 2.7 is no longer maintained. pip 21.0 will drop support for Python 2.7 in January 2021. More details about Python 2 support in pip can be found at https://pip.pypa.io/en/latest/development/release-process/#python-2-support pip 21.0 will remove support for this functionality.\n", "stderr_lines": ["DEPRECATION: Python 2.7 reached the end of its life on January 1st, 2020. Please upgrade your Python as Python 2.7 is no longer maintained. pip 21.0 will drop support for Python 2.7 in January 2021. More details about Python 2 support in pip can be found at https://pip.pypa.io/en/latest/development/release-process/#python-2-support pip 21.0 will remove support for this functionality."], "stdout": "Requirement already satisfied: pexpect in /usr/local/lib/python2.7/dist-packages (4.8.0)\nRequirement already satisfied: ptyprocess>=0.5 in /usr/local/lib/python2.7/dist-packages (from pexpect) (0.7.0)\n", "stdout_lines": ["Requirement already satisfied: pexpect in /usr/local/lib/python2.7/dist-packages (4.8.0)", "Requirement already satisfied: ptyprocess>=0.5 in /usr/local/lib/python2.7/dist-packages (from pexpect) (0.7.0)"], "version": null, "virtualenv": null}
2022-12-30 00:05:05,252 p=88373 u=kal n=ansible | TASK [install setuptools] ****************************************************************************************************************************
2022-12-30 00:05:05,595 p=88373 u=kal n=ansible | ok: [krpz] => {"changed": false, "cmd": ["/usr/bin/python2", "-m", "pip.__main__", "install", "setuptools"], "name": ["setuptools"], "requirements": null, "state": "present", "stderr": "DEPRECATION: Python 2.7 reached the end of its life on January 1st, 2020. Please upgrade your Python as Python 2.7 is no longer maintained. pip 21.0 will drop support for Python 2.7 in January 2021. More details about Python 2 support in pip can be found at https://pip.pypa.io/en/latest/development/release-process/#python-2-support pip 21.0 will remove support for this functionality.\n", "stderr_lines": ["DEPRECATION: Python 2.7 reached the end of its life on January 1st, 2020. Please upgrade your Python as Python 2.7 is no longer maintained. pip 21.0 will drop support for Python 2.7 in January 2021. More details about Python 2 support in pip can be found at https://pip.pypa.io/en/latest/development/release-process/#python-2-support pip 21.0 will remove support for this functionality."], "stdout": "Requirement already satisfied: setuptools in /usr/lib/python2.7/dist-packages (44.1.1)\n", "stdout_lines": ["Requirement already satisfied: setuptools in /usr/lib/python2.7/dist-packages (44.1.1)"], "version": null, "virtualenv": null}
2022-12-30 00:05:05,603 p=88373 u=kal n=ansible | TASK [Install Rust] **********************************************************************************************************************************
2022-12-30 00:05:06,442 p=88373 u=kal n=ansible | fatal: [krpz]: FAILED! => {"changed": true, "cmd": "curl -sSf https://sh.rustup.rs | sh", "delta": "0:00:00.611825", "end": "2022-12-30 00:05:06.376736", "msg": "non-zero return code", "rc": 6, "start": "2022-12-30 00:05:05.764911", "stdout": "#!/bin/sh\r\n# shellcheck shell=dash\r\n\r\n# This is just a little script that can be downloaded from the internet to\r\n# install rustup. It just does platform detection, downloads the installer\r\n# and runs it.\r\n\r\n# It runs on Unix shells like {a,ba,da,k,z}sh. It uses the common `local`\r\n# extension. Note: Most shells limit `local` to 1 var per line, contra bash.\r\n\r\nif [ \"$KSH_VERSION\" = 'Version JM 93t+ 2010-03-05' ]; then\r\n    # The version of ksh93 that ships with many illumos systems does not\r\n    # support the \"local\" extension.  Print a message rather than fail in\r\n    # subtle ways later on:\r\n    echo 'rustup does not work with this ksh93 version; please try bash!' >&2\r\n    exit 1\r\nfi\r\n\r\n\r\nset -u\r\n\r\n# If RUSTUP_UPDATE_ROOT is unset or empty, default it.\r\nRUSTUP_UPDATE_ROOT=\"${RUSTUP_UPDATE_ROOT:-https://static.rust-lang.org/rustup}\"\r\n\r\n#XXX: If you change anything here, please make the same changes in setup_mode.rs\r\nusage() {\r\n    cat 1>&2 <<EOF\r\nrustup-init 1.25.1 (48d233f65 2022-07-12)\r\nThe installer for rustup\r\n\r\nUSAGE:\r\n    rustup-init [FLAGS] [OPTIONS]\r\n\r\nFLAGS:\r\n    -v, --verbose           Enable verbose output\r\n    -q, --quiet             Disable progress output\r\n    -y                      Disable confirmation prompt.\r\n        --no-modify-path    Don't configure the PATH environment variable\r\n    -h, --help              Prints help information\r\n    -V, --version           Prints version information\r\n\r\nOPTIONS:\r\n        --default-host <default-host>              Choose a default host triple\r\n        --default-toolchain <default-toolchain>    Choose a default toolchain to install\r\n        --default-toolchain none                   Do not install any toolchains\r\n        --profile [minimal|default|complete]       Choose a profile\r\n    -c, --component <components>...                Component name to also install\r\n    -t, --target <targets>...                      Target name to also install\r\nEOF\r\n}\r\n\r\nmain() {\r\n    downloader --check\r\n    need_cmd uname\r\n    need_cmd mktemp\r\n    need_cmd chmod\r\n    need_cmd mkdir\r\n    need_cmd rm\r\n    need_cmd rmdir\r\n\r\n    get_architecture || return 1\r\n    local _arch=\"$RETVAL\"\r\n    assert_nz \"$_arch\" \"arch\"\r\n\r\n    local _ext=\"\"\r\n    case \"$_arch\" in\r\n        *windows*)\r\n            _ext=\".exe\"\r\n            ;;\r\n    esac\r\n\r\n    local _url=\"${RUSTUP_UPDATE_ROOT}/dist/${_arch}/rustup-init${_ext}\"\r\n\r\n    local _dir\r\n    _dir=\"$(ensure mktemp -d)\"\r\n    local _file=\"${_dir}/rustup-init${_ext}\"\r\n\r\n    local _ansi_escapes_are_valid=false\r\n    if [ -t 2 ]; then\r\n        if [ \"${TERM+set}\" = 'set' ]; then\r\n            case \"$TERM\" in\r\n                xterm*|rxvt*|urxvt*|linux*|vt*)\r\n                    _ansi_escapes_are_valid=true\r\n                ;;\r\n            esac\r\n        fi\r\n    fi\r\n\r\n    # check if we have to use /dev/tty to prompt the user\r\n    local need_tty=yes\r\n    for arg in \"$@\"; do\r\n        case \"$arg\" in\r\n            --help)\r\n                usage\r\n                exit 0\r\n                ;;\r\n            *)\r\n                OPTIND=1\r\n                if [ \"${arg%%--*}\" = \"\" ]; then\r\n                    # Long option (other than --help);\r\n                    # don't attempt to interpret it.\r\n                    continue\r\n                fi\r\n                while getopts :hy sub_arg \"$arg\"; do\r\n                    case \"$sub_arg\" in\r\n                        h)\r\n                            usage\r\n                            exit 0\r\n                            ;;\r\n                        y)\r\n                            # user wants to skip the prompt --\r\n                            # we don't need /dev/tty\r\n                            need_tty=no\r\n                            ;;\r\n                        *)\r\n                            ;;\r\n                        esac\r\n                done\r\n                ;;\r\n        esac\r\n    done\r\n\r\n    if $_ansi_escapes_are_valid; then\r\n        printf \"\\33[1minfo:\\33[0m downloading installer\\n\" 1>&2\r\n    else\r\n        printf '%s\\n' 'info: downloading installer' 1>&2\r\n    fi\r\n\r\n    ensure mkdir -p \"$_dir\"\r\n    ensure downloader \"$_url\" \"$_file\" \"$_arch\"\r\n    ensure chmod u+x \"$_file\"\r\n    if [ ! -x \"$_file\" ]; then\r\n        printf '%s\\n' \"Cannot execute $_file (likely because of mounting /tmp as noexec).\" 1>&2\r\n        printf '%s\\n' \"Please copy the file to a location where you can execute binaries and run ./rustup-init${_ext}.\" 1>&2\r\n        exit 1\r\n    fi\r\n\r\n    if [ \"$need_tty\" = \"yes\" ] && [ ! -t 0 ]; then\r\n        # The installer is going to want to ask for confirmation by\r\n        # reading stdin.  This script was piped into `sh` though and\r\n        # doesn't have stdin to pass to its children. Instead we're going\r\n        # to explicitly connect /dev/tty to the installer's stdin.\r\n        if [ ! -t 1 ]; then\r\n            err \"Unable to run interactively. Run with -y to accept defaults, --help for additional options\"\r\n        fi\r\n\r\n        ignore \"$_file\" \"$@\" < /dev/tty\r\n    else\r\n        ignore \"$_file\" \"$@\"\r\n    fi\r\n\r\n    local _retval=$?\r\n\r\n    ignore rm \"$_file\"\r\n    ignore rmdir \"$_dir\"\r\n\r\n    return \"$_retval\"\r\n}\r\n\r\ncheck_proc() {\r\n    # Check for /proc by looking for the /proc/self/exe link\r\n    # This is only run on Linux\r\n    if ! test -L /proc/self/exe ; then\r\n        err \"fatal: Unable to find /proc/self/exe.  Is /proc mounted?  Installation cannot proceed without /proc.\"\r\n    fi\r\n}\r\n\r\nget_bitness() {\r\n    need_cmd head\r\n    # Architecture detection without dependencies beyond coreutils.\r\n    # ELF files start out \"\\x7fELF\", and the following byte is\r\n    #   0x01 for 32-bit and\r\n    #   0x02 for 64-bit.\r\n    # The printf builtin on some shells like dash only supports octal\r\n    # escape sequences, so we use those.\r\n    local _current_exe_head\r\n    _current_exe_head=$(head -c 5 /proc/self/exe )\r\n    if [ \"$_current_exe_head\" = \"$(printf '\\177ELF\\001')\" ]; then\r\n        echo 32\r\n    elif [ \"$_current_exe_head\" = \"$(printf '\\177ELF\\002')\" ]; then\r\n        echo 64\r\n    else\r\n        err \"unknown platform bitness\"\r\n    fi\r\n}\r\n\r\nis_host_amd64_elf() {\r\n    need_cmd head\r\n    need_cmd tail\r\n    # ELF e_machine detection without dependencies beyond coreutils.\r\n    # Two-byte field at offset 0x12 indicates the CPU,\r\n    # but we're interested in it being 0x3E to indicate amd64, or not that.\r\n    local _current_exe_machine\r\n    _current_exe_machine=$(head -c 19 /proc/self/exe | tail -c 1)\r\n    [ \"$_current_exe_machine\" = \"$(printf '\\076')\" ]\r\n}\r\n\r\nget_endianness() {\r\n    local cputype=$1\r\n    local suffix_eb=$2\r\n    local suffix_el=$3\r\n\r\n    # detect endianness without od/hexdump, like get_bitness() does.\r\n    need_cmd head\r\n    need_cmd tail\r\n\r\n    local _current_exe_endianness\r\n    _current_exe_endianness=\"$(head -c 6 /proc/self/exe | tail -c 1)\"\r\n    if [ \"$_current_exe_endianness\" = \"$(printf '\\001')\" ]; then\r\n        echo \"${cputype}${suffix_el}\"\r\n    elif [ \"$_current_exe_endianness\" = \"$(printf '\\002')\" ]; then\r\n        echo \"${cputype}${suffix_eb}\"\r\n    else\r\n        err \"unknown platform endianness\"\r\n    fi\r\n}\r\n\r\nget_architecture() {\r\n    local _ostype _cputype _bitness _arch _clibtype\r\n    _ostype=\"$(uname -s)\"\r\n    _cputype=\"$(uname -m)\"\r\n    _clibtype=\"gnu\"\r\n\r\n    if [ \"$_ostype\" = Linux ]; then\r\n        if [ \"$(uname -o)\" = Android ]; then\r\n            _ostype=Android\r\n        fi\r\n        if ldd --version 2>&1 | grep -q 'musl'; then\r\n            _clibtype=\"musl\"\r\n        fi\r\n    fi\r\n\r\n    if [ \"$_ostype\" = Darwin ] && [ \"$_cputype\" = i386 ]; then\r\n        # Darwin `uname -m` lies\r\n        if sysctl hw.optional.x86_64 | grep -q ': 1'; then\r\n            _cputype=x86_64\r\n        fi\r\n    fi\r\n\r\n    if [ \"$_ostype\" = SunOS ]; then\r\n        # Both Solaris and illumos presently announce as \"SunOS\" in \"uname -s\"\r\n        # so use \"uname -o\" to disambiguate.  We use the full path to the\r\n        # system uname in case the user has coreutils uname first in PATH,\r\n        # which has historically sometimes printed the wrong value here.\r\n        if [ \"$(/usr/bin/uname -o)\" = illumos ]; then\r\n            _ostype=illumos\r\n        fi\r\n\r\n        # illumos systems have multi-arch userlands, and \"uname -m\" reports the\r\n        # machine hardware name; e.g., \"i86pc\" on both 32- and 64-bit x86\r\n        # systems.  Check for the native (widest) instruction set on the\r\n        # running kernel:\r\n        if [ \"$_cputype\" = i86pc ]; then\r\n            _cputype=\"$(isainfo -n)\"\r\n        fi\r\n    fi\r\n\r\n    case \"$_ostype\" in\r\n\r\n        Android)\r\n            _ostype=linux-android\r\n            ;;\r\n\r\n        Linux)\r\n            check_proc\r\n            _ostype=unknown-linux-$_clibtype\r\n            _bitness=$(get_bitness)\r\n            ;;\r\n\r\n        FreeBSD)\r\n            _ostype=unknown-freebsd\r\n            ;;\r\n\r\n        NetBSD)\r\n            _ostype=unknown-netbsd\r\n            ;;\r\n\r\n        DragonFly)\r\n            _ostype=unknown-dragonfly\r\n            ;;\r\n\r\n        Darwin)\r\n            _ostype=apple-darwin\r\n            ;;\r\n\r\n        illumos)\r\n            _ostype=unknown-illumos\r\n            ;;\r\n\r\n        MINGW* | MSYS* | CYGWIN* | Windows_NT)\r\n            _ostype=pc-windows-gnu\r\n            ;;\r\n\r\n        *)\r\n            err \"unrecognized OS type: $_ostype\"\r\n            ;;\r\n\r\n    esac\r\n\r\n    case \"$_cputype\" in\r\n\r\n        i386 | i486 | i686 | i786 | x86)\r\n            _cputype=i686\r\n            ;;\r\n\r\n        xscale | arm)\r\n            _cputype=arm\r\n            if [ \"$_ostype\" = \"linux-android\" ]; then\r\n                _ostype=linux-androideabi\r\n            fi\r\n            ;;\r\n\r\n        armv6l)\r\n            _cputype=arm\r\n            if [ \"$_ostype\" = \"linux-android\" ]; then\r\n                _ostype=linux-androideabi\r\n            else\r\n                _ostype=\"${_ostype}eabihf\"\r\n            fi\r\n            ;;\r\n\r\n        armv7l | armv8l)\r\n            _cputype=armv7\r\n            if [ \"$_ostype\" = \"linux-android\" ]; then\r\n                _ostype=linux-androideabi\r\n            else\r\n                _ostype=\"${_ostype}eabihf\"\r\n            fi\r\n            ;;\r\n\r\n        aarch64 | arm64)\r\n            _cputype=aarch64\r\n            ;;\r\n\r\n        x86_64 | x86-64 | x64 | amd64)\r\n            _cputype=x86_64\r\n            ;;\r\n\r\n        mips)\r\n            _cputype=$(get_endianness mips '' el)\r\n            ;;\r\n\r\n        mips64)\r\n            if [ \"$_bitness\" -eq 64 ]; then\r\n                # only n64 ABI is supported for now\r\n                _ostype=\"${_ostype}abi64\"\r\n                _cputype=$(get_endianness mips64 '' el)\r\n            fi\r\n            ;;\r\n\r\n        ppc)\r\n            _cputype=powerpc\r\n            ;;\r\n\r\n        ppc64)\r\n            _cputype=powerpc64\r\n            ;;\r\n\r\n        ppc64le)\r\n            _cputype=powerpc64le\r\n            ;;\r\n\r\n        s390x)\r\n            _cputype=s390x\r\n            ;;\r\n        riscv64)\r\n            _cputype=riscv64gc\r\n            ;;\r\n        *)\r\n            err \"unknown CPU type: $_cputype\"\r\n\r\n    esac\r\n\r\n    # Detect 64-bit linux with 32-bit userland\r\n    if [ \"${_ostype}\" = unknown-linux-gnu ] && [ \"${_bitness}\" -eq 32 ]; then\r\n        case $_cputype in\r\n            x86_64)\r\n                if [ -n \"${RUSTUP_CPUTYPE:-}\" ]; then\r\n                    _cputype=\"$RUSTUP_CPUTYPE\"\r\n                else {\r\n                    # 32-bit executable for amd64 = x32\r\n                    if is_host_amd64_elf; then {\r\n                         echo \"This host is running an x32 userland; as it stands, x32 support is poor,\" 1>&2\r\n                         echo \"and there isn't a native toolchain -- you will have to install\" 1>&2\r\n                         echo \"multiarch compatibility with i686 and/or amd64, then select one\" 1>&2\r\n                         echo \"by re-running this script with the RUSTUP_CPUTYPE environment variable\" 1>&2\r\n                         echo \"set to i686 or x86_64, respectively.\" 1>&2\r\n                         echo 1>&2\r\n                         echo \"You will be able to add an x32 target after installation by running\" 1>&2\r\n                         echo \"  rustup target add x86_64-unknown-linux-gnux32\" 1>&2\r\n                         exit 1\r\n                    }; else\r\n                        _cputype=i686\r\n                    fi\r\n                }; fi\r\n                ;;\r\n            mips64)\r\n                _cputype=$(get_endianness mips '' el)\r\n                ;;\r\n            powerpc64)\r\n                _cputype=powerpc\r\n                ;;\r\n            aarch64)\r\n                _cputype=armv7\r\n                if [ \"$_ostype\" = \"linux-android\" ]; then\r\n                    _ostype=linux-androideabi\r\n                else\r\n                    _ostype=\"${_ostype}eabihf\"\r\n                fi\r\n                ;;\r\n            riscv64gc)\r\n                err \"riscv64 with 32-bit userland unsupported\"\r\n                ;;\r\n        esac\r\n    fi\r\n\r\n    # Detect armv7 but without the CPU features Rust needs in that build,\r\n    # and fall back to arm.\r\n    # See https://github.com/rust-lang/rustup.rs/issues/587.\r\n    if [ \"$_ostype\" = \"unknown-linux-gnueabihf\" ] && [ \"$_cputype\" = armv7 ]; then\r\n        if ensure grep '^Features' /proc/cpuinfo | grep -q -v neon; then\r\n            # At least one processor does not have NEON.\r\n            _cputype=arm\r\n        fi\r\n    fi\r\n\r\n    _arch=\"${_cputype}-${_ostype}\"\r\n\r\n    RETVAL=\"$_arch\"\r\n}\r\n\r\nsay() {\r\n    printf 'rustup: %s\\n' \"$1\"\r\n}\r\n\r\nerr() {\r\n    say \"$1\" >&2\r\n    exit 1\r\n}\r\n\r\nneed_cmd() {\r\n    if ! check_cmd \"$1\"; then\r\n        err \"need '$1' (command not found)\"\r\n    fi\r\n}\r\n\r\ncheck_cmd() {\r\n    command -v \"$1\" > /dev/null 2>&1\r\n}\r\n\r\nassert_nz() {\r\n    if [ -z \"$1\" ]; then err \"assert_nz $2\"; fi\r\n}\r\n\r\n# Run a command that should never fail. If the command fails execution\r\n# will immediately terminate with an error showing the failing\r\n# command.\r\nensure() {\r\n    if ! \"$@\"; then err \"command failed: $*\"; fi\r\n}\r\n\r\n# This is just for indicating that commands' results are being\r\n# intentionally ignored. Usually, because it's being executed\r\n# as part of error handling.\r\nignore() {\r\n    \"$@\"\r\n}\r\n\r\n# This wraps curl or wget. Try curl first, if not installed,\r\n# use wget instead.\r\ndownloader() {\r\n    local _dld\r\n    local _ciphersuites\r\n    local _err\r\n    local _status\r\n    local _retry\r\n    if check_cmd curl; then\r\n        _dld=curl\r\n    elif check_cmd wget; then\r\n        _dld=wget\r\n    else\r\n        _dld='curl or wget' # to be used in error message of need_cmd\r\n    fi\r\n\r\n    if [ \"$1\" = --check ]; then\r\n        need_cmd \"$_dld\"\r\n    elif [ \"$_dld\" = curl ]; then\r\n        check_curl_for_retry_support\r\n        _retry=\"$RETVAL\"\r\n        get_ciphersuites_for_curl\r\n        _ciphersuites=\"$RETVAL\"\r\n        if [ -n \"$_ciphersuites\" ]; then\r\n            _err=$(curl $_retry --proto '=https' --tlsv1.2 --ciphers \"$_ciphersuites\" --silent --show-error --fail --location \"$1\" --output \"$2\" 2>&1)\r\n            _status=$?\r\n        else\r\n            echo \"Warning: Not enforcing strong cipher suites for TLS, this is potentially less secure\"\r\n            if ! check_help_for \"$3\" curl --proto --tlsv1.2; then\r\n                echo \"Warning: Not enforcing TLS v1.2, this is potentially less secure\"\r\n                _err=$(curl $_retry --silent --show-error --fail --location \"$1\" --output \"$2\" 2>&1)\r\n                _status=$?\r\n            else\r\n                _err=$(curl $_retry --proto '=https' --tlsv1.2 --silent --show-error --fail --location \"$1\" --output \"$2\" 2>&1)\r\n                _status=$?\r\n            fi\r\n        fi\r\n        if [ -n \"$_err\" ]; then\r\n            echo \"$_err\" >&2\r\n            if echo \"$_err\" | grep -q 404$; then\r\n                err \"installer for platform '$3' not found, this may be unsupported\"\r\n            fi\r\n        fi\r\n        return $_status\r\n    elif [ \"$_dld\" = wget ]; then\r\n        if [ \"$(wget -V 2>&1|head -2|tail -1|cut -f1 -d\" \")\" = \"BusyBox\" ]; then\r\n            echo \"Warning: using the BusyBox version of wget.  Not enforcing strong cipher suites for TLS or TLS v1.2, this is potentially less secure\"\r\n            _err=$(wget \"$1\" -O \"$2\" 2>&1)\r\n            _status=$?\r\n        else\r\n            get_ciphersuites_for_wget\r\n            _ciphersuites=\"$RETVAL\"\r\n            if [ -n \"$_ciphersuites\" ]; then\r\n                _err=$(wget --https-only --secure-protocol=TLSv1_2 --ciphers \"$_ciphersuites\" \"$1\" -O \"$2\" 2>&1)\r\n                _status=$?\r\n            else\r\n                echo \"Warning: Not enforcing strong cipher suites for TLS, this is potentially less secure\"\r\n                if ! check_help_for \"$3\" wget --https-only --secure-protocol; then\r\n                    echo \"Warning: Not enforcing TLS v1.2, this is potentially less secure\"\r\n                    _err=$(wget \"$1\" -O \"$2\" 2>&1)\r\n                    _status=$?\r\n                else\r\n                    _err=$(wget --https-only --secure-protocol=TLSv1_2 \"$1\" -O \"$2\" 2>&1)\r\n                    _status=$?\r\n                fi\r\n            fi\r\n        fi\r\n        if [ -n \"$_err\" ]; then\r\n            echo \"$_err\" >&2\r\n            if echo \"$_err\" | grep -q ' 404 Not Found$'; then\r\n                err \"installer for platform '$3' not found, this may be unsupported\"\r\n            fi\r\n        fi\r\n        return $_status\r\n    else\r\n        err \"Unknown downloader\"   # should not reach here\r\n    fi\r\n}\r\n\r\ncheck_help_for() {\r\n    local _arch\r\n    local _cmd\r\n    local _arg\r\n    _arch=\"$1\"\r\n    shift\r\n    _cmd=\"$1\"\r\n    shift\r\n\r\n    local _category\r\n    if \"$_cmd\" --help | grep -q 'For all options use the manual or \"--help all\".'; then\r\n      _category=\"all\"\r\n    else\r\n      _category=\"\"\r\n    fi\r\n\r\n    case \"$_arch\" in\r\n\r\n        *darwin*)\r\n        if check_cmd sw_vers; then\r\n            case $(sw_vers -productVersion) in\r\n                10.*)\r\n                    # If we're running on macOS, older than 10.13, then we always\r\n                    # fail to find these options to force fallback\r\n                    if [ \"$(sw_vers -productVersion | cut -d. -f2)\" -lt 13 ]; then\r\n                        # Older than 10.13\r\n                        echo \"Warning: Detected macOS platform older than 10.13\"\r\n                        return 1\r\n                    fi\r\n                    ;;\r\n                11.*)\r\n                    # We assume Big Sur will be OK for now\r\n                    ;;\r\n                *)\r\n                    # Unknown product version, warn and continue\r\n                    echo \"Warning: Detected unknown macOS major version: $(sw_vers -productVersion)\"\r\n                    echo \"Warning TLS capabilities detection may fail\"\r\n                    ;;\r\n            esac\r\n        fi\r\n        ;;\r\n\r\n    esac\r\n\r\n    for _arg in \"$@\"; do\r\n        if ! \"$_cmd\" --help $_category | grep -q -- \"$_arg\"; then\r\n            return 1\r\n        fi\r\n    done\r\n\r\n    true # not strictly needed\r\n}\r\n\r\n# Check if curl supports the --retry flag, then pass it to the curl invocation.\r\ncheck_curl_for_retry_support() {\r\n  local _retry_supported=\"\"\r\n  # \"unspecified\" is for arch, allows for possibility old OS using macports, homebrew, etc.\r\n  if check_help_for \"notspecified\" \"curl\" \"--retry\"; then\r\n    _retry_supported=\"--retry 3\"\r\n  fi\r\n\r\n  RETVAL=\"$_retry_supported\"\r\n\r\n}\r\n\r\n# Return cipher suite string specified by user, otherwise return strong TLS 1.2-1.3 cipher suites\r\n# if support by local tools is detected. Detection currently supports these curl backends:\r\n# GnuTLS and OpenSSL (possibly also LibreSSL and BoringSSL). Return value can be empty.\r\nget_ciphersuites_for_curl() {\r\n    if [ -n \"${RUSTUP_TLS_CIPHERSUITES-}\" ]; then\r\n        # user specified custom cipher suites, assume they know what they're doing\r\n        RETVAL=\"$RUSTUP_TLS_CIPHERSUITES\"\r\n        return\r\n    fi\r\n\r\n    local _openssl_syntax=\"no\"\r\n    local _gnutls_syntax=\"no\"\r\n    local _backend_supported=\"yes\"\r\n    if curl -V | grep -q ' OpenSSL/'; then\r\n        _openssl_syntax=\"yes\"\r\n    elif curl -V | grep -iq ' LibreSSL/'; then\r\n        _openssl_syntax=\"yes\"\r\n    elif curl -V | grep -iq ' BoringSSL/'; then\r\n        _openssl_syntax=\"yes\"\r\n    elif curl -V | grep -iq ' GnuTLS/'; then\r\n        _gnutls_syntax=\"yes\"\r\n    else\r\n        _backend_supported=\"no\"\r\n    fi\r\n\r\n    local _args_supported=\"no\"\r\n    if [ \"$_backend_supported\" = \"yes\" ]; then\r\n        # \"unspecified\" is for arch, allows for possibility old OS using macports, homebrew, etc.\r\n        if check_help_for \"notspecified\" \"curl\" \"--tlsv1.2\" \"--ciphers\" \"--proto\"; then\r\n            _args_supported=\"yes\"\r\n        fi\r\n    fi\r\n\r\n    local _cs=\"\"\r\n    if [ \"$_args_supported\" = \"yes\" ]; then\r\n        if [ \"$_openssl_syntax\" = \"yes\" ]; then\r\n            _cs=$(get_strong_ciphersuites_for \"openssl\")\r\n        elif [ \"$_gnutls_syntax\" = \"yes\" ]; then\r\n            _cs=$(get_strong_ciphersuites_for \"gnutls\")\r\n        fi\r\n    fi\r\n\r\n    RETVAL=\"$_cs\"\r\n}\r\n\r\n# Return cipher suite string specified by user, otherwise return strong TLS 1.2-1.3 cipher suites\r\n# if support by local tools is detected. Detection currently supports these wget backends:\r\n# GnuTLS and OpenSSL (possibly also LibreSSL and BoringSSL). Return value can be empty.\r\nget_ciphersuites_for_wget() {\r\n    if [ -n \"${RUSTUP_TLS_CIPHERSUITES-}\" ]; then\r\n        # user specified custom cipher suites, assume they know what they're doing\r\n        RETVAL=\"$RUSTUP_TLS_CIPHERSUITES\"\r\n        return\r\n    fi\r\n\r\n    local _cs=\"\"\r\n    if wget -V | grep -q '\\-DHAVE_LIBSSL'; then\r\n        # \"unspecified\" is for arch, allows for possibility old OS using macports, homebrew, etc.\r\n        if check_help_for \"notspecified\" \"wget\" \"TLSv1_2\" \"--ciphers\" \"--https-only\" \"--secure-protocol\"; then\r\n            _cs=$(get_strong_ciphersuites_for \"openssl\")\r\n        fi\r\n    elif wget -V | grep -q '\\-DHAVE_LIBGNUTLS'; then\r\n        # \"unspecified\" is for arch, allows for possibility old OS using macports, homebrew, etc.\r\n        if check_help_for \"notspecified\" \"wget\" \"TLSv1_2\" \"--ciphers\" \"--https-only\" \"--secure-protocol\"; then\r\n            _cs=$(get_strong_ciphersuites_for \"gnutls\")\r\n        fi\r\n    fi\r\n\r\n    RETVAL=\"$_cs\"\r\n}\r\n\r\n# Return strong TLS 1.2-1.3 cipher suites in OpenSSL or GnuTLS syntax. TLS 1.2\r\n# excludes non-ECDHE and non-AEAD cipher suites. DHE is excluded due to bad\r\n# DH params often found on servers (see RFC 7919). Sequence matches or is\r\n# similar to Firefox 68 ESR with weak cipher suites disabled via about:config.\r\n# $1 must be openssl or gnutls.\r\nget_strong_ciphersuites_for() {\r\n    if [ \"$1\" = \"openssl\" ]; then\r\n        # OpenSSL is forgiving of unknown values, no problems with TLS 1.3 values on versions that don't support it yet.\r\n        echo \"TLS_AES_128_GCM_SHA256:TLS_CHACHA20_POLY1305_SHA256:TLS_AES_256_GCM_SHA384:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384\"\r\n    elif [ \"$1\" = \"gnutls\" ]; then\r\n        # GnuTLS isn't forgiving of unknown values, so this may require a GnuTLS version that supports TLS 1.3 even if wget doesn't.\r\n        # Begin with SECURE128 (and higher) then remove/add to build cipher suites. Produces same 9 cipher suites as OpenSSL but in slightly different order.\r\n        echo \"SECURE128:-VERS-SSL3.0:-VERS-TLS1.0:-VERS-TLS1.1:-VERS-DTLS-ALL:-CIPHER-ALL:-MAC-ALL:-KX-ALL:+AEAD:+ECDHE-ECDSA:+ECDHE-RSA:+AES-128-GCM:+CHACHA20-POLY1305:+AES-256-GCM\"\r\n    fi\r\n}\r\n\r\nmain \"$@\" || exit 1\r\ncurl: (6) Could not resolve host: |\r\ncurl: (6) Could not resolve host: sh", "stdout_lines": ["#!/bin/sh", "# shellcheck shell=dash", "", "# This is just a little script that can be downloaded from the internet to", "# install rustup. It just does platform detection, downloads the installer", "# and runs it.", "", "# It runs on Unix shells like {a,ba,da,k,z}sh. It uses the common `local`", "# extension. Note: Most shells limit `local` to 1 var per line, contra bash.", "", "if [ \"$KSH_VERSION\" = 'Version JM 93t+ 2010-03-05' ]; then", "    # The version of ksh93 that ships with many illumos systems does not", "    # support the \"local\" extension.  Print a message rather than fail in", "    # subtle ways later on:", "    echo 'rustup does not work with this ksh93 version; please try bash!' >&2", "    exit 1", "fi", "", "", "set -u", "", "# If RUSTUP_UPDATE_ROOT is unset or empty, default it.", "RUSTUP_UPDATE_ROOT=\"${RUSTUP_UPDATE_ROOT:-https://static.rust-lang.org/rustup}\"", "", "#XXX: If you change anything here, please make the same changes in setup_mode.rs", "usage() {", "    cat 1>&2 <<EOF", "rustup-init 1.25.1 (48d233f65 2022-07-12)", "The installer for rustup", "", "USAGE:", "    rustup-init [FLAGS] [OPTIONS]", "", "FLAGS:", "    -v, --verbose           Enable verbose output", "    -q, --quiet             Disable progress output", "    -y                      Disable confirmation prompt.", "        --no-modify-path    Don't configure the PATH environment variable", "    -h, --help              Prints help information", "    -V, --version           Prints version information", "", "OPTIONS:", "        --default-host <default-host>              Choose a default host triple", "        --default-toolchain <default-toolchain>    Choose a default toolchain to install", "        --default-toolchain none                   Do not install any toolchains", "        --profile [minimal|default|complete]       Choose a profile", "    -c, --component <components>...                Component name to also install", "    -t, --target <targets>...                      Target name to also install", "EOF", "}", "", "main() {", "    downloader --check", "    need_cmd uname", "    need_cmd mktemp", "    need_cmd chmod", "    need_cmd mkdir", "    need_cmd rm", "    need_cmd rmdir", "", "    get_architecture || return 1", "    local _arch=\"$RETVAL\"", "    assert_nz \"$_arch\" \"arch\"", "", "    local _ext=\"\"", "    case \"$_arch\" in", "        *windows*)", "            _ext=\".exe\"", "            ;;", "    esac", "", "    local _url=\"${RUSTUP_UPDATE_ROOT}/dist/${_arch}/rustup-init${_ext}\"", "", "    local _dir", "    _dir=\"$(ensure mktemp -d)\"", "    local _file=\"${_dir}/rustup-init${_ext}\"", "", "    local _ansi_escapes_are_valid=false", "    if [ -t 2 ]; then", "        if [ \"${TERM+set}\" = 'set' ]; then", "            case \"$TERM\" in", "                xterm*|rxvt*|urxvt*|linux*|vt*)", "                    _ansi_escapes_are_valid=true", "                ;;", "            esac", "        fi", "    fi", "", "    # check if we have to use /dev/tty to prompt the user", "    local need_tty=yes", "    for arg in \"$@\"; do", "        case \"$arg\" in", "            --help)", "                usage", "                exit 0", "                ;;", "            *)", "                OPTIND=1", "                if [ \"${arg%%--*}\" = \"\" ]; then", "                    # Long option (other than --help);", "                    # don't attempt to interpret it.", "                    continue", "                fi", "                while getopts :hy sub_arg \"$arg\"; do", "                    case \"$sub_arg\" in", "                        h)", "                            usage", "                            exit 0", "                            ;;", "                        y)", "                            # user wants to skip the prompt --", "                            # we don't need /dev/tty", "                            need_tty=no", "                            ;;", "                        *)", "                            ;;", "                        esac", "                done", "                ;;", "        esac", "    done", "", "    if $_ansi_escapes_are_valid; then", "        printf \"\\33[1minfo:\\33[0m downloading installer\\n\" 1>&2", "    else", "        printf '%s\\n' 'info: downloading installer' 1>&2", "    fi", "", "    ensure mkdir -p \"$_dir\"", "    ensure downloader \"$_url\" \"$_file\" \"$_arch\"", "    ensure chmod u+x \"$_file\"", "    if [ ! -x \"$_file\" ]; then", "        printf '%s\\n' \"Cannot execute $_file (likely because of mounting /tmp as noexec).\" 1>&2", "        printf '%s\\n' \"Please copy the file to a location where you can execute binaries and run ./rustup-init${_ext}.\" 1>&2", "        exit 1", "    fi", "", "    if [ \"$need_tty\" = \"yes\" ] && [ ! -t 0 ]; then", "        # The installer is going to want to ask for confirmation by", "        # reading stdin.  This script was piped into `sh` though and", "        # doesn't have stdin to pass to its children. Instead we're going", "        # to explicitly connect /dev/tty to the installer's stdin.", "        if [ ! -t 1 ]; then", "            err \"Unable to run interactively. Run with -y to accept defaults, --help for additional options\"", "        fi", "", "        ignore \"$_file\" \"$@\" < /dev/tty", "    else", "        ignore \"$_file\" \"$@\"", "    fi", "", "    local _retval=$?", "", "    ignore rm \"$_file\"", "    ignore rmdir \"$_dir\"", "", "    return \"$_retval\"", "}", "", "check_proc() {", "    # Check for /proc by looking for the /proc/self/exe link", "    # This is only run on Linux", "    if ! test -L /proc/self/exe ; then", "        err \"fatal: Unable to find /proc/self/exe.  Is /proc mounted?  Installation cannot proceed without /proc.\"", "    fi", "}", "", "get_bitness() {", "    need_cmd head", "    # Architecture detection without dependencies beyond coreutils.", "    # ELF files start out \"\\x7fELF\", and the following byte is", "    #   0x01 for 32-bit and", "    #   0x02 for 64-bit.", "    # The printf builtin on some shells like dash only supports octal", "    # escape sequences, so we use those.", "    local _current_exe_head", "    _current_exe_head=$(head -c 5 /proc/self/exe )", "    if [ \"$_current_exe_head\" = \"$(printf '\\177ELF\\001')\" ]; then", "        echo 32", "    elif [ \"$_current_exe_head\" = \"$(printf '\\177ELF\\002')\" ]; then", "        echo 64", "    else", "        err \"unknown platform bitness\"", "    fi", "}", "", "is_host_amd64_elf() {", "    need_cmd head", "    need_cmd tail", "    # ELF e_machine detection without dependencies beyond coreutils.", "    # Two-byte field at offset 0x12 indicates the CPU,", "    # but we're interested in it being 0x3E to indicate amd64, or not that.", "    local _current_exe_machine", "    _current_exe_machine=$(head -c 19 /proc/self/exe | tail -c 1)", "    [ \"$_current_exe_machine\" = \"$(printf '\\076')\" ]", "}", "", "get_endianness() {", "    local cputype=$1", "    local suffix_eb=$2", "    local suffix_el=$3", "", "    # detect endianness without od/hexdump, like get_bitness() does.", "    need_cmd head", "    need_cmd tail", "", "    local _current_exe_endianness", "    _current_exe_endianness=\"$(head -c 6 /proc/self/exe | tail -c 1)\"", "    if [ \"$_current_exe_endianness\" = \"$(printf '\\001')\" ]; then", "        echo \"${cputype}${suffix_el}\"", "    elif [ \"$_current_exe_endianness\" = \"$(printf '\\002')\" ]; then", "        echo \"${cputype}${suffix_eb}\"", "    else", "        err \"unknown platform endianness\"", "    fi", "}", "", "get_architecture() {", "    local _ostype _cputype _bitness _arch _clibtype", "    _ostype=\"$(uname -s)\"", "    _cputype=\"$(uname -m)\"", "    _clibtype=\"gnu\"", "", "    if [ \"$_ostype\" = Linux ]; then", "        if [ \"$(uname -o)\" = Android ]; then", "            _ostype=Android", "        fi", "        if ldd --version 2>&1 | grep -q 'musl'; then", "            _clibtype=\"musl\"", "        fi", "    fi", "", "    if [ \"$_ostype\" = Darwin ] && [ \"$_cputype\" = i386 ]; then", "        # Darwin `uname -m` lies", "        if sysctl hw.optional.x86_64 | grep -q ': 1'; then", "            _cputype=x86_64", "        fi", "    fi", "", "    if [ \"$_ostype\" = SunOS ]; then", "        # Both Solaris and illumos presently announce as \"SunOS\" in \"uname -s\"", "        # so use \"uname -o\" to disambiguate.  We use the full path to the", "        # system uname in case the user has coreutils uname first in PATH,", "        # which has historically sometimes printed the wrong value here.", "        if [ \"$(/usr/bin/uname -o)\" = illumos ]; then", "            _ostype=illumos", "        fi", "", "        # illumos systems have multi-arch userlands, and \"uname -m\" reports the", "        # machine hardware name; e.g., \"i86pc\" on both 32- and 64-bit x86", "        # systems.  Check for the native (widest) instruction set on the", "        # running kernel:", "        if [ \"$_cputype\" = i86pc ]; then", "            _cputype=\"$(isainfo -n)\"", "        fi", "    fi", "", "    case \"$_ostype\" in", "", "        Android)", "            _ostype=linux-android", "            ;;", "", "        Linux)", "            check_proc", "            _ostype=unknown-linux-$_clibtype", "            _bitness=$(get_bitness)", "            ;;", "", "        FreeBSD)", "            _ostype=unknown-freebsd", "            ;;", "", "        NetBSD)", "            _ostype=unknown-netbsd", "            ;;", "", "        DragonFly)", "            _ostype=unknown-dragonfly", "            ;;", "", "        Darwin)", "            _ostype=apple-darwin", "            ;;", "", "        illumos)", "            _ostype=unknown-illumos", "            ;;", "", "        MINGW* | MSYS* | CYGWIN* | Windows_NT)", "            _ostype=pc-windows-gnu", "            ;;", "", "        *)", "            err \"unrecognized OS type: $_ostype\"", "            ;;", "", "    esac", "", "    case \"$_cputype\" in", "", "        i386 | i486 | i686 | i786 | x86)", "            _cputype=i686", "            ;;", "", "        xscale | arm)", "            _cputype=arm", "            if [ \"$_ostype\" = \"linux-android\" ]; then", "                _ostype=linux-androideabi", "            fi", "            ;;", "", "        armv6l)", "            _cputype=arm", "            if [ \"$_ostype\" = \"linux-android\" ]; then", "                _ostype=linux-androideabi", "            else", "                _ostype=\"${_ostype}eabihf\"", "            fi", "            ;;", "", "        armv7l | armv8l)", "            _cputype=armv7", "            if [ \"$_ostype\" = \"linux-android\" ]; then", "                _ostype=linux-androideabi", "            else", "                _ostype=\"${_ostype}eabihf\"", "            fi", "            ;;", "", "        aarch64 | arm64)", "            _cputype=aarch64", "            ;;", "", "        x86_64 | x86-64 | x64 | amd64)", "            _cputype=x86_64", "            ;;", "", "        mips)", "            _cputype=$(get_endianness mips '' el)", "            ;;", "", "        mips64)", "            if [ \"$_bitness\" -eq 64 ]; then", "                # only n64 ABI is supported for now", "                _ostype=\"${_ostype}abi64\"", "                _cputype=$(get_endianness mips64 '' el)", "            fi", "            ;;", "", "        ppc)", "            _cputype=powerpc", "            ;;", "", "        ppc64)", "            _cputype=powerpc64", "            ;;", "", "        ppc64le)", "            _cputype=powerpc64le", "            ;;", "", "        s390x)", "            _cputype=s390x", "            ;;", "        riscv64)", "            _cputype=riscv64gc", "            ;;", "        *)", "            err \"unknown CPU type: $_cputype\"", "", "    esac", "", "    # Detect 64-bit linux with 32-bit userland", "    if [ \"${_ostype}\" = unknown-linux-gnu ] && [ \"${_bitness}\" -eq 32 ]; then", "        case $_cputype in", "            x86_64)", "                if [ -n \"${RUSTUP_CPUTYPE:-}\" ]; then", "                    _cputype=\"$RUSTUP_CPUTYPE\"", "                else {", "                    # 32-bit executable for amd64 = x32", "                    if is_host_amd64_elf; then {", "                         echo \"This host is running an x32 userland; as it stands, x32 support is poor,\" 1>&2", "                         echo \"and there isn't a native toolchain -- you will have to install\" 1>&2", "                         echo \"multiarch compatibility with i686 and/or amd64, then select one\" 1>&2", "                         echo \"by re-running this script with the RUSTUP_CPUTYPE environment variable\" 1>&2", "                         echo \"set to i686 or x86_64, respectively.\" 1>&2", "                         echo 1>&2", "                         echo \"You will be able to add an x32 target after installation by running\" 1>&2", "                         echo \"  rustup target add x86_64-unknown-linux-gnux32\" 1>&2", "                         exit 1", "                    }; else", "                        _cputype=i686", "                    fi", "                }; fi", "                ;;", "            mips64)", "                _cputype=$(get_endianness mips '' el)", "                ;;", "            powerpc64)", "                _cputype=powerpc", "                ;;", "            aarch64)", "                _cputype=armv7", "                if [ \"$_ostype\" = \"linux-android\" ]; then", "                    _ostype=linux-androideabi", "                else", "                    _ostype=\"${_ostype}eabihf\"", "                fi", "                ;;", "            riscv64gc)", "                err \"riscv64 with 32-bit userland unsupported\"", "                ;;", "        esac", "    fi", "", "    # Detect armv7 but without the CPU features Rust needs in that build,", "    # and fall back to arm.", "    # See https://github.com/rust-lang/rustup.rs/issues/587.", "    if [ \"$_ostype\" = \"unknown-linux-gnueabihf\" ] && [ \"$_cputype\" = armv7 ]; then", "        if ensure grep '^Features' /proc/cpuinfo | grep -q -v neon; then", "            # At least one processor does not have NEON.", "            _cputype=arm", "        fi", "    fi", "", "    _arch=\"${_cputype}-${_ostype}\"", "", "    RETVAL=\"$_arch\"", "}", "", "say() {", "    printf 'rustup: %s\\n' \"$1\"", "}", "", "err() {", "    say \"$1\" >&2", "    exit 1", "}", "", "need_cmd() {", "    if ! check_cmd \"$1\"; then", "        err \"need '$1' (command not found)\"", "    fi", "}", "", "check_cmd() {", "    command -v \"$1\" > /dev/null 2>&1", "}", "", "assert_nz() {", "    if [ -z \"$1\" ]; then err \"assert_nz $2\"; fi", "}", "", "# Run a command that should never fail. If the command fails execution", "# will immediately terminate with an error showing the failing", "# command.", "ensure() {", "    if ! \"$@\"; then err \"command failed: $*\"; fi", "}", "", "# This is just for indicating that commands' results are being", "# intentionally ignored. Usually, because it's being executed", "# as part of error handling.", "ignore() {", "    \"$@\"", "}", "", "# This wraps curl or wget. Try curl first, if not installed,", "# use wget instead.", "downloader() {", "    local _dld", "    local _ciphersuites", "    local _err", "    local _status", "    local _retry", "    if check_cmd curl; then", "        _dld=curl", "    elif check_cmd wget; then", "        _dld=wget", "    else", "        _dld='curl or wget' # to be used in error message of need_cmd", "    fi", "", "    if [ \"$1\" = --check ]; then", "        need_cmd \"$_dld\"", "    elif [ \"$_dld\" = curl ]; then", "        check_curl_for_retry_support", "        _retry=\"$RETVAL\"", "        get_ciphersuites_for_curl", "        _ciphersuites=\"$RETVAL\"", "        if [ -n \"$_ciphersuites\" ]; then", "            _err=$(curl $_retry --proto '=https' --tlsv1.2 --ciphers \"$_ciphersuites\" --silent --show-error --fail --location \"$1\" --output \"$2\" 2>&1)", "            _status=$?", "        else", "            echo \"Warning: Not enforcing strong cipher suites for TLS, this is potentially less secure\"", "            if ! check_help_for \"$3\" curl --proto --tlsv1.2; then", "                echo \"Warning: Not enforcing TLS v1.2, this is potentially less secure\"", "                _err=$(curl $_retry --silent --show-error --fail --location \"$1\" --output \"$2\" 2>&1)", "                _status=$?", "            else", "                _err=$(curl $_retry --proto '=https' --tlsv1.2 --silent --show-error --fail --location \"$1\" --output \"$2\" 2>&1)", "                _status=$?", "            fi", "        fi", "        if [ -n \"$_err\" ]; then", "            echo \"$_err\" >&2", "            if echo \"$_err\" | grep -q 404$; then", "                err \"installer for platform '$3' not found, this may be unsupported\"", "            fi", "        fi", "        return $_status", "    elif [ \"$_dld\" = wget ]; then", "        if [ \"$(wget -V 2>&1|head -2|tail -1|cut -f1 -d\" \")\" = \"BusyBox\" ]; then", "            echo \"Warning: using the BusyBox version of wget.  Not enforcing strong cipher suites for TLS or TLS v1.2, this is potentially less secure\"", "            _err=$(wget \"$1\" -O \"$2\" 2>&1)", "            _status=$?", "        else", "            get_ciphersuites_for_wget", "            _ciphersuites=\"$RETVAL\"", "            if [ -n \"$_ciphersuites\" ]; then", "                _err=$(wget --https-only --secure-protocol=TLSv1_2 --ciphers \"$_ciphersuites\" \"$1\" -O \"$2\" 2>&1)", "                _status=$?", "            else", "                echo \"Warning: Not enforcing strong cipher suites for TLS, this is potentially less secure\"", "                if ! check_help_for \"$3\" wget --https-only --secure-protocol; then", "                    echo \"Warning: Not enforcing TLS v1.2, this is potentially less secure\"", "                    _err=$(wget \"$1\" -O \"$2\" 2>&1)", "                    _status=$?", "                else", "                    _err=$(wget --https-only --secure-protocol=TLSv1_2 \"$1\" -O \"$2\" 2>&1)", "                    _status=$?", "                fi", "            fi", "        fi", "        if [ -n \"$_err\" ]; then", "            echo \"$_err\" >&2", "            if echo \"$_err\" | grep -q ' 404 Not Found$'; then", "                err \"installer for platform '$3' not found, this may be unsupported\"", "            fi", "        fi", "        return $_status", "    else", "        err \"Unknown downloader\"   # should not reach here", "    fi", "}", "", "check_help_for() {", "    local _arch", "    local _cmd", "    local _arg", "    _arch=\"$1\"", "    shift", "    _cmd=\"$1\"", "    shift", "", "    local _category", "    if \"$_cmd\" --help | grep -q 'For all options use the manual or \"--help all\".'; then", "      _category=\"all\"", "    else", "      _category=\"\"", "    fi", "", "    case \"$_arch\" in", "", "        *darwin*)", "        if check_cmd sw_vers; then", "            case $(sw_vers -productVersion) in", "                10.*)", "                    # If we're running on macOS, older than 10.13, then we always", "                    # fail to find these options to force fallback", "                    if [ \"$(sw_vers -productVersion | cut -d. -f2)\" -lt 13 ]; then", "                        # Older than 10.13", "                        echo \"Warning: Detected macOS platform older than 10.13\"", "                        return 1", "                    fi", "                    ;;", "                11.*)", "                    # We assume Big Sur will be OK for now", "                    ;;", "                *)", "                    # Unknown product version, warn and continue", "                    echo \"Warning: Detected unknown macOS major version: $(sw_vers -productVersion)\"", "                    echo \"Warning TLS capabilities detection may fail\"", "                    ;;", "            esac", "        fi", "        ;;", "", "    esac", "", "    for _arg in \"$@\"; do", "        if ! \"$_cmd\" --help $_category | grep -q -- \"$_arg\"; then", "            return 1", "        fi", "    done", "", "    true # not strictly needed", "}", "", "# Check if curl supports the --retry flag, then pass it to the curl invocation.", "check_curl_for_retry_support() {", "  local _retry_supported=\"\"", "  # \"unspecified\" is for arch, allows for possibility old OS using macports, homebrew, etc.", "  if check_help_for \"notspecified\" \"curl\" \"--retry\"; then", "    _retry_supported=\"--retry 3\"", "  fi", "", "  RETVAL=\"$_retry_supported\"", "", "}", "", "# Return cipher suite string specified by user, otherwise return strong TLS 1.2-1.3 cipher suites", "# if support by local tools is detected. Detection currently supports these curl backends:", "# GnuTLS and OpenSSL (possibly also LibreSSL and BoringSSL). Return value can be empty.", "get_ciphersuites_for_curl() {", "    if [ -n \"${RUSTUP_TLS_CIPHERSUITES-}\" ]; then", "        # user specified custom cipher suites, assume they know what they're doing", "        RETVAL=\"$RUSTUP_TLS_CIPHERSUITES\"", "        return", "    fi", "", "    local _openssl_syntax=\"no\"", "    local _gnutls_syntax=\"no\"", "    local _backend_supported=\"yes\"", "    if curl -V | grep -q ' OpenSSL/'; then", "        _openssl_syntax=\"yes\"", "    elif curl -V | grep -iq ' LibreSSL/'; then", "        _openssl_syntax=\"yes\"", "    elif curl -V | grep -iq ' BoringSSL/'; then", "        _openssl_syntax=\"yes\"", "    elif curl -V | grep -iq ' GnuTLS/'; then", "        _gnutls_syntax=\"yes\"", "    else", "        _backend_supported=\"no\"", "    fi", "", "    local _args_supported=\"no\"", "    if [ \"$_backend_supported\" = \"yes\" ]; then", "        # \"unspecified\" is for arch, allows for possibility old OS using macports, homebrew, etc.", "        if check_help_for \"notspecified\" \"curl\" \"--tlsv1.2\" \"--ciphers\" \"--proto\"; then", "            _args_supported=\"yes\"", "        fi", "    fi", "", "    local _cs=\"\"", "    if [ \"$_args_supported\" = \"yes\" ]; then", "        if [ \"$_openssl_syntax\" = \"yes\" ]; then", "            _cs=$(get_strong_ciphersuites_for \"openssl\")", "        elif [ \"$_gnutls_syntax\" = \"yes\" ]; then", "            _cs=$(get_strong_ciphersuites_for \"gnutls\")", "        fi", "    fi", "", "    RETVAL=\"$_cs\"", "}", "", "# Return cipher suite string specified by user, otherwise return strong TLS 1.2-1.3 cipher suites", "# if support by local tools is detected. Detection currently supports these wget backends:", "# GnuTLS and OpenSSL (possibly also LibreSSL and BoringSSL). Return value can be empty.", "get_ciphersuites_for_wget() {", "    if [ -n \"${RUSTUP_TLS_CIPHERSUITES-}\" ]; then", "        # user specified custom cipher suites, assume they know what they're doing", "        RETVAL=\"$RUSTUP_TLS_CIPHERSUITES\"", "        return", "    fi", "", "    local _cs=\"\"", "    if wget -V | grep -q '\\-DHAVE_LIBSSL'; then", "        # \"unspecified\" is for arch, allows for possibility old OS using macports, homebrew, etc.", "        if check_help_for \"notspecified\" \"wget\" \"TLSv1_2\" \"--ciphers\" \"--https-only\" \"--secure-protocol\"; then", "            _cs=$(get_strong_ciphersuites_for \"openssl\")", "        fi", "    elif wget -V | grep -q '\\-DHAVE_LIBGNUTLS'; then", "        # \"unspecified\" is for arch, allows for possibility old OS using macports, homebrew, etc.", "        if check_help_for \"notspecified\" \"wget\" \"TLSv1_2\" \"--ciphers\" \"--https-only\" \"--secure-protocol\"; then", "            _cs=$(get_strong_ciphersuites_for \"gnutls\")", "        fi", "    fi", "", "    RETVAL=\"$_cs\"", "}", "", "# Return strong TLS 1.2-1.3 cipher suites in OpenSSL or GnuTLS syntax. TLS 1.2", "# excludes non-ECDHE and non-AEAD cipher suites. DHE is excluded due to bad", "# DH params often found on servers (see RFC 7919). Sequence matches or is", "# similar to Firefox 68 ESR with weak cipher suites disabled via about:config.", "# $1 must be openssl or gnutls.", "get_strong_ciphersuites_for() {", "    if [ \"$1\" = \"openssl\" ]; then", "        # OpenSSL is forgiving of unknown values, no problems with TLS 1.3 values on versions that don't support it yet.", "        echo \"TLS_AES_128_GCM_SHA256:TLS_CHACHA20_POLY1305_SHA256:TLS_AES_256_GCM_SHA384:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384\"", "    elif [ \"$1\" = \"gnutls\" ]; then", "        # GnuTLS isn't forgiving of unknown values, so this may require a GnuTLS version that supports TLS 1.3 even if wget doesn't.", "        # Begin with SECURE128 (and higher) then remove/add to build cipher suites. Produces same 9 cipher suites as OpenSSL but in slightly different order.", "        echo \"SECURE128:-VERS-SSL3.0:-VERS-TLS1.0:-VERS-TLS1.1:-VERS-DTLS-ALL:-CIPHER-ALL:-MAC-ALL:-KX-ALL:+AEAD:+ECDHE-ECDSA:+ECDHE-RSA:+AES-128-GCM:+CHACHA20-POLY1305:+AES-256-GCM\"", "    fi", "}", "", "main \"$@\" || exit 1", "curl: (6) Could not resolve host: |", "curl: (6) Could not resolve host: sh"]}
2022-12-30 00:05:06,444 p=88373 u=kal n=ansible | PLAY RECAP *******************************************************************************************************************************************
2022-12-30 00:05:06,445 p=88373 u=kal n=ansible | krpz                       : ok=3    changed=0    unreachable=0    failed=1    skipped=0    rescued=0    ignored=0   
2022-12-30 00:05:12,125 p=88599 u=kal n=ansible | Using /home/kal/MyApplications/dotfiles/playbooks/ansible.cfg as config file
2022-12-30 00:05:12,197 p=88599 u=kal n=ansible | PLAY [localhost] *************************************************************************************************************************************
2022-12-30 00:05:12,203 p=88599 u=kal n=ansible | TASK [Gathering Facts] *******************************************************************************************************************************
2022-12-30 00:05:13,296 p=88599 u=kal n=ansible | ok: [krpz]
2022-12-30 00:05:13,317 p=88599 u=kal n=ansible | TASK [install pexpect] *******************************************************************************************************************************
2022-12-30 00:05:13,750 p=88599 u=kal n=ansible | ok: [krpz] => {"changed": false, "cmd": ["/usr/bin/python2", "-m", "pip.__main__", "install", "pexpect"], "name": ["pexpect"], "requirements": null, "state": "present", "stderr": "DEPRECATION: Python 2.7 reached the end of its life on January 1st, 2020. Please upgrade your Python as Python 2.7 is no longer maintained. pip 21.0 will drop support for Python 2.7 in January 2021. More details about Python 2 support in pip can be found at https://pip.pypa.io/en/latest/development/release-process/#python-2-support pip 21.0 will remove support for this functionality.\n", "stderr_lines": ["DEPRECATION: Python 2.7 reached the end of its life on January 1st, 2020. Please upgrade your Python as Python 2.7 is no longer maintained. pip 21.0 will drop support for Python 2.7 in January 2021. More details about Python 2 support in pip can be found at https://pip.pypa.io/en/latest/development/release-process/#python-2-support pip 21.0 will remove support for this functionality."], "stdout": "Requirement already satisfied: pexpect in /usr/local/lib/python2.7/dist-packages (4.8.0)\nRequirement already satisfied: ptyprocess>=0.5 in /usr/local/lib/python2.7/dist-packages (from pexpect) (0.7.0)\n", "stdout_lines": ["Requirement already satisfied: pexpect in /usr/local/lib/python2.7/dist-packages (4.8.0)", "Requirement already satisfied: ptyprocess>=0.5 in /usr/local/lib/python2.7/dist-packages (from pexpect) (0.7.0)"], "version": null, "virtualenv": null}
2022-12-30 00:05:13,758 p=88599 u=kal n=ansible | TASK [install setuptools] ****************************************************************************************************************************
2022-12-30 00:05:14,105 p=88599 u=kal n=ansible | ok: [krpz] => {"changed": false, "cmd": ["/usr/bin/python2", "-m", "pip.__main__", "install", "setuptools"], "name": ["setuptools"], "requirements": null, "state": "present", "stderr": "DEPRECATION: Python 2.7 reached the end of its life on January 1st, 2020. Please upgrade your Python as Python 2.7 is no longer maintained. pip 21.0 will drop support for Python 2.7 in January 2021. More details about Python 2 support in pip can be found at https://pip.pypa.io/en/latest/development/release-process/#python-2-support pip 21.0 will remove support for this functionality.\n", "stderr_lines": ["DEPRECATION: Python 2.7 reached the end of its life on January 1st, 2020. Please upgrade your Python as Python 2.7 is no longer maintained. pip 21.0 will drop support for Python 2.7 in January 2021. More details about Python 2 support in pip can be found at https://pip.pypa.io/en/latest/development/release-process/#python-2-support pip 21.0 will remove support for this functionality."], "stdout": "Requirement already satisfied: setuptools in /usr/lib/python2.7/dist-packages (44.1.1)\n", "stdout_lines": ["Requirement already satisfied: setuptools in /usr/lib/python2.7/dist-packages (44.1.1)"], "version": null, "virtualenv": null}
2022-12-30 00:05:14,113 p=88599 u=kal n=ansible | TASK [Install Rust] **********************************************************************************************************************************
2022-12-30 00:05:14,628 p=88599 u=kal n=ansible | fatal: [krpz]: FAILED! => {"changed": true, "cmd": "curl https://sh.rustup.rs | sh", "delta": "0:00:00.273735", "end": "2022-12-30 00:05:14.552807", "msg": "non-zero return code", "rc": 6, "start": "2022-12-30 00:05:14.279072", "stdout": "#!/bin/sh\r\n# shellcheck shell=dash\r\n\r\n# This is just a little script that can be downloaded from the internet to\r\n# install rustup. It just does platform detection, downloads the installer\r\n# and runs it.\r\n\r\n# It runs on Unix shells like {a,ba,da,k,z}sh. It uses the common `local`\r\n# extension. Note: Most shells limit `local` to 1 var per line, contra bash.\r\n\r\nif [ \"$KSH_VERSION\" = 'Version JM 93t+ 2010-03-05' ]; then\r\n    # The version of ksh93 that ships with many illumos systems does not\r\n    # support the \"local\" extension.  Print a message rather than fail in\r\n    # subtle ways later on:\r\n    echo 'rustup does not work with this ksh93 version; please try bash!' >&2\r\n    exit 1\r\nfi\r\n\r\n\r\nset -u\r\n\r\n# If RUSTUP_UPDATE_ROOT is unset or empty, default it.\r\nRUSTUP_UPDATE_ROOT=\"${RUSTUP_UPDATE_ROOT:-https://static.rust-lang.org/rustup}\"\r\n\r\n#XXX: If you change anything here, please make the same changes in setup_mode.rs\r\nusage() {\r\n    cat 1>&2 <<EOF\r\nrustup-init 1.25.1 (48d233f65 2022-07-12)\r\nThe installer for rustup\r\n\r\nUSAGE:\r\n    rustup-init [FLAGS] [OPTIONS]\r\n\r\nFLAGS:\r\n    -v, --verbose           Enable verbose output\r\n    -q, --quiet             Disable progress output\r\n    -y                      Disable confirmation prompt.\r\n        --no-modify-path    Don't configure the PATH environment variable\r\n    -h, --help              Prints help information\r\n    -V, --version           Prints version information\r\n\r\nOPTIONS:\r\n        --default-host <default-host>              Choose a default host triple\r\n        --default-toolchain <default-toolchain>    Choose a default toolchain to install\r\n        --default-toolchain none                   Do not install any toolchains\r\n        --profile [minimal|default|complete]       Choose a profile\r\n    -c, --component <components>...                Component name to also install\r\n    -t, --target <targets>...                      Target name to also install\r\nEOF\r\n}\r\n\r\nmain() {\r\n    downloader --check\r\n    need_cmd uname\r\n    need_cmd mktemp\r\n    need_cmd chmod\r\n    need_cmd mkdir\r\n    need_cmd rm\r\n    need_cmd rmdir\r\n\r\n    get_architecture || return 1\r\n    local _arch=\"$RETVAL\"\r\n    assert_nz \"$_arch\" \"arch\"\r\n\r\n    local _ext=\"\"\r\n    case \"$_arch\" in\r\n        *windows*)\r\n            _ext=\".exe\"\r\n            ;;\r\n    esac\r\n\r\n    local _url=\"${RUSTUP_UPDATE_ROOT}/dist/${_arch}/rustup-init${_ext}\"\r\n\r\n    local _dir\r\n    _dir=\"$(ensure mktemp -d)\"\r\n    local _file=\"${_dir}/rustup-init${_ext}\"\r\n\r\n    local _ansi_escapes_are_valid=false\r\n    if [ -t 2 ]; then\r\n        if [ \"${TERM+set}\" = 'set' ]; then\r\n            case \"$TERM\" in\r\n                xterm*|rxvt*|urxvt*|linux*|vt*)\r\n                    _ansi_escapes_are_valid=true\r\n                ;;\r\n            esac\r\n        fi\r\n    fi\r\n\r\n    # check if we have to use /dev/tty to prompt the user\r\n    local need_tty=yes\r\n    for arg in \"$@\"; do\r\n        case \"$arg\" in\r\n            --help)\r\n                usage\r\n                exit 0\r\n                ;;\r\n            *)\r\n                OPTIND=1\r\n                if [ \"${arg%%--*}\" = \"\" ]; then\r\n                    # Long option (other than --help);\r\n                    # don't attempt to interpret it.\r\n                    continue\r\n                fi\r\n                while getopts :hy sub_arg \"$arg\"; do\r\n                    case \"$sub_arg\" in\r\n                        h)\r\n                            usage\r\n                            exit 0\r\n                            ;;\r\n                        y)\r\n                            # user wants to skip the prompt --\r\n                            # we don't need /dev/tty\r\n                            need_tty=no\r\n                            ;;\r\n                        *)\r\n                            ;;\r\n                        esac\r\n                done\r\n                ;;\r\n        esac\r\n    done\r\n\r\n    if $_ansi_escapes_are_valid; then\r\n        printf \"\\33[1minfo:\\33[0m downloading installer\\n\" 1>&2\r\n    else\r\n        printf '%s\\n' 'info: downloading installer' 1>&2\r\n    fi\r\n\r\n    ensure mkdir -p \"$_dir\"\r\n    ensure downloader \"$_url\" \"$_file\" \"$_arch\"\r\n    ensure chmod u+x \"$_file\"\r\n    if [ ! -x \"$_file\" ]; then\r\n        printf '%s\\n' \"Cannot execute $_file (likely because of mounting /tmp as noexec).\" 1>&2\r\n        printf '%s\\n' \"Please copy the file to a location where you can execute binaries and run ./rustup-init${_ext}.\" 1>&2\r\n        exit 1\r\n    fi\r\n\r\n    if [ \"$need_tty\" = \"yes\" ] && [ ! -t 0 ]; then\r\n        # The installer is going to want to ask for confirmation by\r\n        # reading stdin.  This script was piped into `sh` though and\r\n        # doesn't have stdin to pass to its children. Instead we're going\r\n        # to explicitly connect /dev/tty to the installer's stdin.\r\n        if [ ! -t 1 ]; then\r\n            err \"Unable to run interactively. Run with -y to accept defaults, --help for additional options\"\r\n        fi\r\n\r\n        ignore \"$_file\" \"$@\" < /dev/tty\r\n    else\r\n        ignore \"$_file\" \"$@\"\r\n    fi\r\n\r\n    local _retval=$?\r\n\r\n    ignore rm \"$_file\"\r\n    ignore rmdir \"$_dir\"\r\n\r\n    return \"$_retval\"\r\n}\r\n\r\ncheck_proc() {\r\n    # Check for /proc by looking for the /proc/self/exe link\r\n    # This is only run on Linux\r\n    if ! test -L /proc/self/exe ; then\r\n        err \"fatal: Unable to find /proc/self/exe.  Is /proc mounted?  Installation cannot proceed without /proc.\"\r\n    fi\r\n}\r\n\r\nget_bitness() {\r\n    need_cmd head\r\n    # Architecture detection without dependencies beyond coreutils.\r\n    # ELF files start out \"\\x7fELF\", and the following byte is\r\n    #   0x01 for 32-bit and\r\n    #   0x02 for 64-bit.\r\n    # The printf builtin on some shells like dash only supports octal\r\n    # escape sequences, so we use those.\r\n    local _current_exe_head\r\n    _current_exe_head=$(head -c 5 /proc/self/exe )\r\n    if [ \"$_current_exe_head\" = \"$(printf '\\177ELF\\001')\" ]; then\r\n        echo 32\r\n    elif [ \"$_current_exe_head\" = \"$(printf '\\177ELF\\002')\" ]; then\r\n        echo 64\r\n    else\r\n        err \"unknown platform bitness\"\r\n    fi\r\n}\r\n\r\nis_host_amd64_elf() {\r\n    need_cmd head\r\n    need_cmd tail\r\n    # ELF e_machine detection without dependencies beyond coreutils.\r\n    # Two-byte field at offset 0x12 indicates the CPU,\r\n    # but we're interested in it being 0x3E to indicate amd64, or not that.\r\n    local _current_exe_machine\r\n    _current_exe_machine=$(head -c 19 /proc/self/exe | tail -c 1)\r\n    [ \"$_current_exe_machine\" = \"$(printf '\\076')\" ]\r\n}\r\n\r\nget_endianness() {\r\n    local cputype=$1\r\n    local suffix_eb=$2\r\n    local suffix_el=$3\r\n\r\n    # detect endianness without od/hexdump, like get_bitness() does.\r\n    need_cmd head\r\n    need_cmd tail\r\n\r\n    local _current_exe_endianness\r\n    _current_exe_endianness=\"$(head -c 6 /proc/self/exe | tail -c 1)\"\r\n    if [ \"$_current_exe_endianness\" = \"$(printf '\\001')\" ]; then\r\n        echo \"${cputype}${suffix_el}\"\r\n    elif [ \"$_current_exe_endianness\" = \"$(printf '\\002')\" ]; then\r\n        echo \"${cputype}${suffix_eb}\"\r\n    else\r\n        err \"unknown platform endianness\"\r\n    fi\r\n}\r\n\r\nget_architecture() {\r\n    local _ostype _cputype _bitness _arch _clibtype\r\n    _ostype=\"$(uname -s)\"\r\n    _cputype=\"$(uname -m)\"\r\n    _clibtype=\"gnu\"\r\n\r\n    if [ \"$_ostype\" = Linux ]; then\r\n        if [ \"$(uname -o)\" = Android ]; then\r\n            _ostype=Android\r\n        fi\r\n        if ldd --version 2>&1 | grep -q 'musl'; then\r\n            _clibtype=\"musl\"\r\n        fi\r\n    fi\r\n\r\n    if [ \"$_ostype\" = Darwin ] && [ \"$_cputype\" = i386 ]; then\r\n        # Darwin `uname -m` lies\r\n        if sysctl hw.optional.x86_64 | grep -q ': 1'; then\r\n            _cputype=x86_64\r\n        fi\r\n    fi\r\n\r\n    if [ \"$_ostype\" = SunOS ]; then\r\n        # Both Solaris and illumos presently announce as \"SunOS\" in \"uname -s\"\r\n        # so use \"uname -o\" to disambiguate.  We use the full path to the\r\n        # system uname in case the user has coreutils uname first in PATH,\r\n        # which has historically sometimes printed the wrong value here.\r\n        if [ \"$(/usr/bin/uname -o)\" = illumos ]; then\r\n            _ostype=illumos\r\n        fi\r\n\r\n        # illumos systems have multi-arch userlands, and \"uname -m\" reports the\r\n        # machine hardware name; e.g., \"i86pc\" on both 32- and 64-bit x86\r\n        # systems.  Check for the native (widest) instruction set on the\r\n        # running kernel:\r\n        if [ \"$_cputype\" = i86pc ]; then\r\n            _cputype=\"$(isainfo -n)\"\r\n        fi\r\n    fi\r\n\r\n    case \"$_ostype\" in\r\n\r\n        Android)\r\n            _ostype=linux-android\r\n            ;;\r\n\r\n        Linux)\r\n            check_proc\r\n            _ostype=unknown-linux-$_clibtype\r\n            _bitness=$(get_bitness)\r\n            ;;\r\n\r\n        FreeBSD)\r\n            _ostype=unknown-freebsd\r\n            ;;\r\n\r\n        NetBSD)\r\n            _ostype=unknown-netbsd\r\n            ;;\r\n\r\n        DragonFly)\r\n            _ostype=unknown-dragonfly\r\n            ;;\r\n\r\n        Darwin)\r\n            _ostype=apple-darwin\r\n            ;;\r\n\r\n        illumos)\r\n            _ostype=unknown-illumos\r\n            ;;\r\n\r\n        MINGW* | MSYS* | CYGWIN* | Windows_NT)\r\n            _ostype=pc-windows-gnu\r\n            ;;\r\n\r\n        *)\r\n            err \"unrecognized OS type: $_ostype\"\r\n            ;;\r\n\r\n    esac\r\n\r\n    case \"$_cputype\" in\r\n\r\n        i386 | i486 | i686 | i786 | x86)\r\n            _cputype=i686\r\n            ;;\r\n\r\n        xscale | arm)\r\n            _cputype=arm\r\n            if [ \"$_ostype\" = \"linux-android\" ]; then\r\n                _ostype=linux-androideabi\r\n            fi\r\n            ;;\r\n\r\n        armv6l)\r\n            _cputype=arm\r\n            if [ \"$_ostype\" = \"linux-android\" ]; then\r\n                _ostype=linux-androideabi\r\n            else\r\n                _ostype=\"${_ostype}eabihf\"\r\n            fi\r\n            ;;\r\n\r\n        armv7l | armv8l)\r\n            _cputype=armv7\r\n            if [ \"$_ostype\" = \"linux-android\" ]; then\r\n                _ostype=linux-androideabi\r\n            else\r\n                _ostype=\"${_ostype}eabihf\"\r\n            fi\r\n            ;;\r\n\r\n        aarch64 | arm64)\r\n            _cputype=aarch64\r\n            ;;\r\n\r\n        x86_64 | x86-64 | x64 | amd64)\r\n            _cputype=x86_64\r\n            ;;\r\n\r\n        mips)\r\n            _cputype=$(get_endianness mips '' el)\r\n            ;;\r\n\r\n        mips64)\r\n            if [ \"$_bitness\" -eq 64 ]; then\r\n                # only n64 ABI is supported for now\r\n                _ostype=\"${_ostype}abi64\"\r\n                _cputype=$(get_endianness mips64 '' el)\r\n            fi\r\n            ;;\r\n\r\n        ppc)\r\n            _cputype=powerpc\r\n            ;;\r\n\r\n        ppc64)\r\n            _cputype=powerpc64\r\n            ;;\r\n\r\n        ppc64le)\r\n            _cputype=powerpc64le\r\n            ;;\r\n\r\n        s390x)\r\n            _cputype=s390x\r\n            ;;\r\n        riscv64)\r\n            _cputype=riscv64gc\r\n            ;;\r\n        *)\r\n            err \"unknown CPU type: $_cputype\"\r\n\r\n    esac\r\n\r\n    # Detect 64-bit linux with 32-bit userland\r\n    if [ \"${_ostype}\" = unknown-linux-gnu ] && [ \"${_bitness}\" -eq 32 ]; then\r\n        case $_cputype in\r\n            x86_64)\r\n                if [ -n \"${RUSTUP_CPUTYPE:-}\" ]; then\r\n                    _cputype=\"$RUSTUP_CPUTYPE\"\r\n                else {\r\n                    # 32-bit executable for amd64 = x32\r\n                    if is_host_amd64_elf; then {\r\n                         echo \"This host is running an x32 userland; as it stands, x32 support is poor,\" 1>&2\r\n                         echo \"and there isn't a native toolchain -- you will have to install\" 1>&2\r\n                         echo \"multiarch compatibility with i686 and/or amd64, then select one\" 1>&2\r\n                         echo \"by re-running this script with the RUSTUP_CPUTYPE environment variable\" 1>&2\r\n                         echo \"set to i686 or x86_64, respectively.\" 1>&2\r\n                         echo 1>&2\r\n                         echo \"You will be able to add an x32 target after installation by running\" 1>&2\r\n                         echo \"  rustup target add x86_64-unknown-linux-gnux32\" 1>&2\r\n                         exit 1\r\n                    }; else\r\n                        _cputype=i686\r\n                    fi\r\n                }; fi\r\n                ;;\r\n            mips64)\r\n                _cputype=$(get_endianness mips '' el)\r\n                ;;\r\n            powerpc64)\r\n                _cputype=powerpc\r\n                ;;\r\n            aarch64)\r\n                _cputype=armv7\r\n                if [ \"$_ostype\" = \"linux-android\" ]; then\r\n                    _ostype=linux-androideabi\r\n                else\r\n                    _ostype=\"${_ostype}eabihf\"\r\n                fi\r\n                ;;\r\n            riscv64gc)\r\n                err \"riscv64 with 32-bit userland unsupported\"\r\n                ;;\r\n        esac\r\n    fi\r\n\r\n    # Detect armv7 but without the CPU features Rust needs in that build,\r\n    # and fall back to arm.\r\n    # See https://github.com/rust-lang/rustup.rs/issues/587.\r\n    if [ \"$_ostype\" = \"unknown-linux-gnueabihf\" ] && [ \"$_cputype\" = armv7 ]; then\r\n        if ensure grep '^Features' /proc/cpuinfo | grep -q -v neon; then\r\n            # At least one processor does not have NEON.\r\n            _cputype=arm\r\n        fi\r\n    fi\r\n\r\n    _arch=\"${_cputype}-${_ostype}\"\r\n\r\n    RETVAL=\"$_arch\"\r\n}\r\n\r\nsay() {\r\n    printf 'rustup: %s\\n' \"$1\"\r\n}\r\n\r\nerr() {\r\n    say \"$1\" >&2\r\n    exit 1\r\n}\r\n\r\nneed_cmd() {\r\n    if ! check_cmd \"$1\"; then\r\n        err \"need '$1' (command not found)\"\r\n    fi\r\n}\r\n\r\ncheck_cmd() {\r\n    command -v \"$1\" > /dev/null 2>&1\r\n}\r\n\r\nassert_nz() {\r\n    if [ -z \"$1\" ]; then err \"assert_nz $2\"; fi\r\n}\r\n\r\n# Run a command that should never fail. If the command fails execution\r\n# will immediately terminate with an error showing the failing\r\n# command.\r\nensure() {\r\n    if ! \"$@\"; then err \"command failed: $*\"; fi\r\n}\r\n\r\n# This is just for indicating that commands' results are being\r\n# intentionally ignored. Usually, because it's being executed\r\n# as part of error handling.\r\nignore() {\r\n    \"$@\"\r\n}\r\n\r\n# This wraps curl or wget. Try curl first, if not installed,\r\n# use wget instead.\r\ndownloader() {\r\n    local _dld\r\n    local _ciphersuites\r\n    local _err\r\n    local _status\r\n    local _retry\r\n    if check_cmd curl; then\r\n        _dld=curl\r\n    elif check_cmd wget; then\r\n        _dld=wget\r\n    else\r\n        _dld='curl or wget' # to be used in error message of need_cmd\r\n    fi\r\n\r\n    if [ \"$1\" = --check ]; then\r\n        need_cmd \"$_dld\"\r\n    elif [ \"$_dld\" = curl ]; then\r\n        check_curl_for_retry_support\r\n        _retry=\"$RETVAL\"\r\n        get_ciphersuites_for_curl\r\n        _ciphersuites=\"$RETVAL\"\r\n        if [ -n \"$_ciphersuites\" ]; then\r\n            _err=$(curl $_retry --proto '=https' --tlsv1.2 --ciphers \"$_ciphersuites\" --silent --show-error --fail --location \"$1\" --output \"$2\" 2>&1)\r\n            _status=$?\r\n        else\r\n            echo \"Warning: Not enforcing strong cipher suites for TLS, this is potentially less secure\"\r\n            if ! check_help_for \"$3\" curl --proto --tlsv1.2; then\r\n                echo \"Warning: Not enforcing TLS v1.2, this is potentially less secure\"\r\n                _err=$(curl $_retry --silent --show-error --fail --location \"$1\" --output \"$2\" 2>&1)\r\n                _status=$?\r\n            else\r\n                _err=$(curl $_retry --proto '=https' --tlsv1.2 --silent --show-error --fail --location \"$1\" --output \"$2\" 2>&1)\r\n                _status=$?\r\n            fi\r\n        fi\r\n        if [ -n \"$_err\" ]; then\r\n            echo \"$_err\" >&2\r\n            if echo \"$_err\" | grep -q 404$; then\r\n                err \"installer for platform '$3' not found, this may be unsupported\"\r\n            fi\r\n        fi\r\n        return $_status\r\n    elif [ \"$_dld\" = wget ]; then\r\n        if [ \"$(wget -V 2>&1|head -2|tail -1|cut -f1 -d\" \")\" = \"BusyBox\" ]; then\r\n            echo \"Warning: using the BusyBox version of wget.  Not enforcing strong cipher suites for TLS or TLS v1.2, this is potentially less secure\"\r\n            _err=$(wget \"$1\" -O \"$2\" 2>&1)\r\n            _status=$?\r\n        else\r\n            get_ciphersuites_for_wget\r\n            _ciphersuites=\"$RETVAL\"\r\n            if [ -n \"$_ciphersuites\" ]; then\r\n                _err=$(wget --https-only --secure-protocol=TLSv1_2 --ciphers \"$_ciphersuites\" \"$1\" -O \"$2\" 2>&1)\r\n                _status=$?\r\n            else\r\n                echo \"Warning: Not enforcing strong cipher suites for TLS, this is potentially less secure\"\r\n                if ! check_help_for \"$3\" wget --https-only --secure-protocol; then\r\n                    echo \"Warning: Not enforcing TLS v1.2, this is potentially less secure\"\r\n                    _err=$(wget \"$1\" -O \"$2\" 2>&1)\r\n                    _status=$?\r\n                else\r\n                    _err=$(wget --https-only --secure-protocol=TLSv1_2 \"$1\" -O \"$2\" 2>&1)\r\n                    _status=$?\r\n                fi\r\n            fi\r\n        fi\r\n        if [ -n \"$_err\" ]; then\r\n            echo \"$_err\" >&2\r\n            if echo \"$_err\" | grep -q ' 404 Not Found$'; then\r\n                err \"installer for platform '$3' not found, this may be unsupported\"\r\n            fi\r\n        fi\r\n        return $_status\r\n    else\r\n        err \"Unknown downloader\"   # should not reach here\r\n    fi\r\n}\r\n\r\ncheck_help_for() {\r\n    local _arch\r\n    local _cmd\r\n    local _arg\r\n    _arch=\"$1\"\r\n    shift\r\n    _cmd=\"$1\"\r\n    shift\r\n\r\n    local _category\r\n    if \"$_cmd\" --help | grep -q 'For all options use the manual or \"--help all\".'; then\r\n      _category=\"all\"\r\n    else\r\n      _category=\"\"\r\n    fi\r\n\r\n    case \"$_arch\" in\r\n\r\n        *darwin*)\r\n        if check_cmd sw_vers; then\r\n            case $(sw_vers -productVersion) in\r\n                10.*)\r\n                    # If we're running on macOS, older than 10.13, then we always\r\n                    # fail to find these options to force fallback\r\n                    if [ \"$(sw_vers -productVersion | cut -d. -f2)\" -lt 13 ]; then\r\n                        # Older than 10.13\r\n                        echo \"Warning: Detected macOS platform older than 10.13\"\r\n                        return 1\r\n                    fi\r\n                    ;;\r\n                11.*)\r\n                    # We assume Big Sur will be OK for now\r\n                    ;;\r\n                *)\r\n                    # Unknown product version, warn and continue\r\n                    echo \"Warning: Detected unknown macOS major version: $(sw_vers -productVersion)\"\r\n                    echo \"Warning TLS capabilities detection may fail\"\r\n                    ;;\r\n            esac\r\n        fi\r\n        ;;\r\n\r\n    esac\r\n\r\n    for _arg in \"$@\"; do\r\n        if ! \"$_cmd\" --help $_category | grep -q -- \"$_arg\"; then\r\n            return 1\r\n        fi\r\n    done\r\n\r\n    true # not strictly needed\r\n}\r\n\r\n# Check if curl supports the --retry flag, then pass it to the curl invocation.\r\ncheck_curl_for_retry_support() {\r\n  local _retry_supported=\"\"\r\n  # \"unspecified\" is for arch, allows for possibility old OS using macports, homebrew, etc.\r\n  if check_help_for \"notspecified\" \"curl\" \"--retry\"; then\r\n    _retry_supported=\"--retry 3\"\r\n  fi\r\n\r\n  RETVAL=\"$_retry_supported\"\r\n\r\n}\r\n\r\n# Return cipher suite string specified by user, otherwise return strong TLS 1.2-1.3 cipher suites\r\n# if support by local tools is detected. Detection currently supports these curl backends:\r\n# GnuTLS and OpenSSL (possibly also LibreSSL and BoringSSL). Return value can be empty.\r\nget_ciphersuites_for_curl() {\r\n    if [ -n \"${RUSTUP_TLS_CIPHERSUITES-}\" ]; then\r\n        # user specified custom cipher suites, assume they know what they're doing\r\n        RETVAL=\"$RUSTUP_TLS_CIPHERSUITES\"\r\n        return\r\n    fi\r\n\r\n    local _openssl_syntax=\"no\"\r\n    local _gnutls_syntax=\"no\"\r\n    local _backend_supported=\"yes\"\r\n    if curl -V | grep -q ' OpenSSL/'; then\r\n        _openssl_syntax=\"yes\"\r\n    elif curl -V | grep -iq ' LibreSSL/'; then\r\n        _openssl_syntax=\"yes\"\r\n    elif curl -V | grep -iq ' BoringSSL/'; then\r\n        _openssl_syntax=\"yes\"\r\n    elif curl -V | grep -iq ' GnuTLS/'; then\r\n        _gnutls_syntax=\"yes\"\r\n    else\r\n        _backend_supported=\"no\"\r\n    fi\r\n\r\n    local _args_supported=\"no\"\r\n    if [ \"$_backend_supported\" = \"yes\" ]; then\r\n        # \"unspecified\" is for arch, allows for possibility old OS using macports, homebrew, etc.\r\n        if check_help_for \"notspecified\" \"curl\" \"--tlsv1.2\" \"--ciphers\" \"--proto\"; then\r\n            _args_supported=\"yes\"\r\n        fi\r\n    fi\r\n\r\n    local _cs=\"\"\r\n    if [ \"$_args_supported\" = \"yes\" ]; then\r\n        if [ \"$_openssl_syntax\" = \"yes\" ]; then\r\n            _cs=$(get_strong_ciphersuites_for \"openssl\")\r\n        elif [ \"$_gnutls_syntax\" = \"yes\" ]; then\r\n            _cs=$(get_strong_ciphersuites_for \"gnutls\")\r\n        fi\r\n    fi\r\n\r\n    RETVAL=\"$_cs\"\r\n}\r\n\r\n# Return cipher suite string specified by user, otherwise return strong TLS 1.2-1.3 cipher suites\r\n# if support by local tools is detected. Detection currently supports these wget backends:\r\n# GnuTLS and OpenSSL (possibly also LibreSSL and BoringSSL). Return value can be empty.\r\nget_ciphersuites_for_wget() {\r\n    if [ -n \"${RUSTUP_TLS_CIPHERSUITES-}\" ]; then\r\n        # user specified custom cipher suites, assume they know what they're doing\r\n        RETVAL=\"$RUSTUP_TLS_CIPHERSUITES\"\r\n        return\r\n    fi\r\n\r\n    local _cs=\"\"\r\n    if wget -V | grep -q '\\-DHAVE_LIBSSL'; then\r\n        # \"unspecified\" is for arch, allows for possibility old OS using macports, homebrew, etc.\r\n        if check_help_for \"notspecified\" \"wget\" \"TLSv1_2\" \"--ciphers\" \"--https-only\" \"--secure-protocol\"; then\r\n            _cs=$(get_strong_ciphersuites_for \"openssl\")\r\n        fi\r\n    elif wget -V | grep -q '\\-DHAVE_LIBGNUTLS'; then\r\n        # \"unspecified\" is for arch, allows for possibility old OS using macports, homebrew, etc.\r\n        if check_help_for \"notspecified\" \"wget\" \"TLSv1_2\" \"--ciphers\" \"--https-only\" \"--secure-protocol\"; then\r\n            _cs=$(get_strong_ciphersuites_for \"gnutls\")\r\n        fi\r\n    fi\r\n\r\n    RETVAL=\"$_cs\"\r\n}\r\n\r\n# Return strong TLS 1.2-1.3 cipher suites in OpenSSL or GnuTLS syntax. TLS 1.2\r\n# excludes non-ECDHE and non-AEAD cipher suites. DHE is excluded due to bad\r\n# DH params often found on servers (see RFC 7919). Sequence matches or is\r\n# similar to Firefox 68 ESR with weak cipher suites disabled via about:config.\r\n# $1 must be openssl or gnutls.\r\nget_strong_ciphersuites_for() {\r\n    if [ \"$1\" = \"openssl\" ]; then\r\n        # OpenSSL is forgiving of unknown values, no problems with TLS 1.3 values on versions that don't support it yet.\r\n        echo \"TLS_AES_128_GCM_SHA256:TLS_CHACHA20_POLY1305_SHA256:TLS_AES_256_GCM_SHA384:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384\"\r\n    elif [ \"$1\" = \"gnutls\" ]; then\r\n        # GnuTLS isn't forgiving of unknown values, so this may require a GnuTLS version that supports TLS 1.3 even if wget doesn't.\r\n        # Begin with SECURE128 (and higher) then remove/add to build cipher suites. Produces same 9 cipher suites as OpenSSL but in slightly different order.\r\n        echo \"SECURE128:-VERS-SSL3.0:-VERS-TLS1.0:-VERS-TLS1.1:-VERS-DTLS-ALL:-CIPHER-ALL:-MAC-ALL:-KX-ALL:+AEAD:+ECDHE-ECDSA:+ECDHE-RSA:+AES-128-GCM:+CHACHA20-POLY1305:+AES-256-GCM\"\r\n    fi\r\n}\r\n\r\nmain \"$@\" || exit 1\r\ncurl: (6) Could not resolve host: |\r\ncurl: (6) Could not resolve host: sh", "stdout_lines": ["#!/bin/sh", "# shellcheck shell=dash", "", "# This is just a little script that can be downloaded from the internet to", "# install rustup. It just does platform detection, downloads the installer", "# and runs it.", "", "# It runs on Unix shells like {a,ba,da,k,z}sh. It uses the common `local`", "# extension. Note: Most shells limit `local` to 1 var per line, contra bash.", "", "if [ \"$KSH_VERSION\" = 'Version JM 93t+ 2010-03-05' ]; then", "    # The version of ksh93 that ships with many illumos systems does not", "    # support the \"local\" extension.  Print a message rather than fail in", "    # subtle ways later on:", "    echo 'rustup does not work with this ksh93 version; please try bash!' >&2", "    exit 1", "fi", "", "", "set -u", "", "# If RUSTUP_UPDATE_ROOT is unset or empty, default it.", "RUSTUP_UPDATE_ROOT=\"${RUSTUP_UPDATE_ROOT:-https://static.rust-lang.org/rustup}\"", "", "#XXX: If you change anything here, please make the same changes in setup_mode.rs", "usage() {", "    cat 1>&2 <<EOF", "rustup-init 1.25.1 (48d233f65 2022-07-12)", "The installer for rustup", "", "USAGE:", "    rustup-init [FLAGS] [OPTIONS]", "", "FLAGS:", "    -v, --verbose           Enable verbose output", "    -q, --quiet             Disable progress output", "    -y                      Disable confirmation prompt.", "        --no-modify-path    Don't configure the PATH environment variable", "    -h, --help              Prints help information", "    -V, --version           Prints version information", "", "OPTIONS:", "        --default-host <default-host>              Choose a default host triple", "        --default-toolchain <default-toolchain>    Choose a default toolchain to install", "        --default-toolchain none                   Do not install any toolchains", "        --profile [minimal|default|complete]       Choose a profile", "    -c, --component <components>...                Component name to also install", "    -t, --target <targets>...                      Target name to also install", "EOF", "}", "", "main() {", "    downloader --check", "    need_cmd uname", "    need_cmd mktemp", "    need_cmd chmod", "    need_cmd mkdir", "    need_cmd rm", "    need_cmd rmdir", "", "    get_architecture || return 1", "    local _arch=\"$RETVAL\"", "    assert_nz \"$_arch\" \"arch\"", "", "    local _ext=\"\"", "    case \"$_arch\" in", "        *windows*)", "            _ext=\".exe\"", "            ;;", "    esac", "", "    local _url=\"${RUSTUP_UPDATE_ROOT}/dist/${_arch}/rustup-init${_ext}\"", "", "    local _dir", "    _dir=\"$(ensure mktemp -d)\"", "    local _file=\"${_dir}/rustup-init${_ext}\"", "", "    local _ansi_escapes_are_valid=false", "    if [ -t 2 ]; then", "        if [ \"${TERM+set}\" = 'set' ]; then", "            case \"$TERM\" in", "                xterm*|rxvt*|urxvt*|linux*|vt*)", "                    _ansi_escapes_are_valid=true", "                ;;", "            esac", "        fi", "    fi", "", "    # check if we have to use /dev/tty to prompt the user", "    local need_tty=yes", "    for arg in \"$@\"; do", "        case \"$arg\" in", "            --help)", "                usage", "                exit 0", "                ;;", "            *)", "                OPTIND=1", "                if [ \"${arg%%--*}\" = \"\" ]; then", "                    # Long option (other than --help);", "                    # don't attempt to interpret it.", "                    continue", "                fi", "                while getopts :hy sub_arg \"$arg\"; do", "                    case \"$sub_arg\" in", "                        h)", "                            usage", "                            exit 0", "                            ;;", "                        y)", "                            # user wants to skip the prompt --", "                            # we don't need /dev/tty", "                            need_tty=no", "                            ;;", "                        *)", "                            ;;", "                        esac", "                done", "                ;;", "        esac", "    done", "", "    if $_ansi_escapes_are_valid; then", "        printf \"\\33[1minfo:\\33[0m downloading installer\\n\" 1>&2", "    else", "        printf '%s\\n' 'info: downloading installer' 1>&2", "    fi", "", "    ensure mkdir -p \"$_dir\"", "    ensure downloader \"$_url\" \"$_file\" \"$_arch\"", "    ensure chmod u+x \"$_file\"", "    if [ ! -x \"$_file\" ]; then", "        printf '%s\\n' \"Cannot execute $_file (likely because of mounting /tmp as noexec).\" 1>&2", "        printf '%s\\n' \"Please copy the file to a location where you can execute binaries and run ./rustup-init${_ext}.\" 1>&2", "        exit 1", "    fi", "", "    if [ \"$need_tty\" = \"yes\" ] && [ ! -t 0 ]; then", "        # The installer is going to want to ask for confirmation by", "        # reading stdin.  This script was piped into `sh` though and", "        # doesn't have stdin to pass to its children. Instead we're going", "        # to explicitly connect /dev/tty to the installer's stdin.", "        if [ ! -t 1 ]; then", "            err \"Unable to run interactively. Run with -y to accept defaults, --help for additional options\"", "        fi", "", "        ignore \"$_file\" \"$@\" < /dev/tty", "    else", "        ignore \"$_file\" \"$@\"", "    fi", "", "    local _retval=$?", "", "    ignore rm \"$_file\"", "    ignore rmdir \"$_dir\"", "", "    return \"$_retval\"", "}", "", "check_proc() {", "    # Check for /proc by looking for the /proc/self/exe link", "    # This is only run on Linux", "    if ! test -L /proc/self/exe ; then", "        err \"fatal: Unable to find /proc/self/exe.  Is /proc mounted?  Installation cannot proceed without /proc.\"", "    fi", "}", "", "get_bitness() {", "    need_cmd head", "    # Architecture detection without dependencies beyond coreutils.", "    # ELF files start out \"\\x7fELF\", and the following byte is", "    #   0x01 for 32-bit and", "    #   0x02 for 64-bit.", "    # The printf builtin on some shells like dash only supports octal", "    # escape sequences, so we use those.", "    local _current_exe_head", "    _current_exe_head=$(head -c 5 /proc/self/exe )", "    if [ \"$_current_exe_head\" = \"$(printf '\\177ELF\\001')\" ]; then", "        echo 32", "    elif [ \"$_current_exe_head\" = \"$(printf '\\177ELF\\002')\" ]; then", "        echo 64", "    else", "        err \"unknown platform bitness\"", "    fi", "}", "", "is_host_amd64_elf() {", "    need_cmd head", "    need_cmd tail", "    # ELF e_machine detection without dependencies beyond coreutils.", "    # Two-byte field at offset 0x12 indicates the CPU,", "    # but we're interested in it being 0x3E to indicate amd64, or not that.", "    local _current_exe_machine", "    _current_exe_machine=$(head -c 19 /proc/self/exe | tail -c 1)", "    [ \"$_current_exe_machine\" = \"$(printf '\\076')\" ]", "}", "", "get_endianness() {", "    local cputype=$1", "    local suffix_eb=$2", "    local suffix_el=$3", "", "    # detect endianness without od/hexdump, like get_bitness() does.", "    need_cmd head", "    need_cmd tail", "", "    local _current_exe_endianness", "    _current_exe_endianness=\"$(head -c 6 /proc/self/exe | tail -c 1)\"", "    if [ \"$_current_exe_endianness\" = \"$(printf '\\001')\" ]; then", "        echo \"${cputype}${suffix_el}\"", "    elif [ \"$_current_exe_endianness\" = \"$(printf '\\002')\" ]; then", "        echo \"${cputype}${suffix_eb}\"", "    else", "        err \"unknown platform endianness\"", "    fi", "}", "", "get_architecture() {", "    local _ostype _cputype _bitness _arch _clibtype", "    _ostype=\"$(uname -s)\"", "    _cputype=\"$(uname -m)\"", "    _clibtype=\"gnu\"", "", "    if [ \"$_ostype\" = Linux ]; then", "        if [ \"$(uname -o)\" = Android ]; then", "            _ostype=Android", "        fi", "        if ldd --version 2>&1 | grep -q 'musl'; then", "            _clibtype=\"musl\"", "        fi", "    fi", "", "    if [ \"$_ostype\" = Darwin ] && [ \"$_cputype\" = i386 ]; then", "        # Darwin `uname -m` lies", "        if sysctl hw.optional.x86_64 | grep -q ': 1'; then", "            _cputype=x86_64", "        fi", "    fi", "", "    if [ \"$_ostype\" = SunOS ]; then", "        # Both Solaris and illumos presently announce as \"SunOS\" in \"uname -s\"", "        # so use \"uname -o\" to disambiguate.  We use the full path to the", "        # system uname in case the user has coreutils uname first in PATH,", "        # which has historically sometimes printed the wrong value here.", "        if [ \"$(/usr/bin/uname -o)\" = illumos ]; then", "            _ostype=illumos", "        fi", "", "        # illumos systems have multi-arch userlands, and \"uname -m\" reports the", "        # machine hardware name; e.g., \"i86pc\" on both 32- and 64-bit x86", "        # systems.  Check for the native (widest) instruction set on the", "        # running kernel:", "        if [ \"$_cputype\" = i86pc ]; then", "            _cputype=\"$(isainfo -n)\"", "        fi", "    fi", "", "    case \"$_ostype\" in", "", "        Android)", "            _ostype=linux-android", "            ;;", "", "        Linux)", "            check_proc", "            _ostype=unknown-linux-$_clibtype", "            _bitness=$(get_bitness)", "            ;;", "", "        FreeBSD)", "            _ostype=unknown-freebsd", "            ;;", "", "        NetBSD)", "            _ostype=unknown-netbsd", "            ;;", "", "        DragonFly)", "            _ostype=unknown-dragonfly", "            ;;", "", "        Darwin)", "            _ostype=apple-darwin", "            ;;", "", "        illumos)", "            _ostype=unknown-illumos", "            ;;", "", "        MINGW* | MSYS* | CYGWIN* | Windows_NT)", "            _ostype=pc-windows-gnu", "            ;;", "", "        *)", "            err \"unrecognized OS type: $_ostype\"", "            ;;", "", "    esac", "", "    case \"$_cputype\" in", "", "        i386 | i486 | i686 | i786 | x86)", "            _cputype=i686", "            ;;", "", "        xscale | arm)", "            _cputype=arm", "            if [ \"$_ostype\" = \"linux-android\" ]; then", "                _ostype=linux-androideabi", "            fi", "            ;;", "", "        armv6l)", "            _cputype=arm", "            if [ \"$_ostype\" = \"linux-android\" ]; then", "                _ostype=linux-androideabi", "            else", "                _ostype=\"${_ostype}eabihf\"", "            fi", "            ;;", "", "        armv7l | armv8l)", "            _cputype=armv7", "            if [ \"$_ostype\" = \"linux-android\" ]; then", "                _ostype=linux-androideabi", "            else", "                _ostype=\"${_ostype}eabihf\"", "            fi", "            ;;", "", "        aarch64 | arm64)", "            _cputype=aarch64", "            ;;", "", "        x86_64 | x86-64 | x64 | amd64)", "            _cputype=x86_64", "            ;;", "", "        mips)", "            _cputype=$(get_endianness mips '' el)", "            ;;", "", "        mips64)", "            if [ \"$_bitness\" -eq 64 ]; then", "                # only n64 ABI is supported for now", "                _ostype=\"${_ostype}abi64\"", "                _cputype=$(get_endianness mips64 '' el)", "            fi", "            ;;", "", "        ppc)", "            _cputype=powerpc", "            ;;", "", "        ppc64)", "            _cputype=powerpc64", "            ;;", "", "        ppc64le)", "            _cputype=powerpc64le", "            ;;", "", "        s390x)", "            _cputype=s390x", "            ;;", "        riscv64)", "            _cputype=riscv64gc", "            ;;", "        *)", "            err \"unknown CPU type: $_cputype\"", "", "    esac", "", "    # Detect 64-bit linux with 32-bit userland", "    if [ \"${_ostype}\" = unknown-linux-gnu ] && [ \"${_bitness}\" -eq 32 ]; then", "        case $_cputype in", "            x86_64)", "                if [ -n \"${RUSTUP_CPUTYPE:-}\" ]; then", "                    _cputype=\"$RUSTUP_CPUTYPE\"", "                else {", "                    # 32-bit executable for amd64 = x32", "                    if is_host_amd64_elf; then {", "                         echo \"This host is running an x32 userland; as it stands, x32 support is poor,\" 1>&2", "                         echo \"and there isn't a native toolchain -- you will have to install\" 1>&2", "                         echo \"multiarch compatibility with i686 and/or amd64, then select one\" 1>&2", "                         echo \"by re-running this script with the RUSTUP_CPUTYPE environment variable\" 1>&2", "                         echo \"set to i686 or x86_64, respectively.\" 1>&2", "                         echo 1>&2", "                         echo \"You will be able to add an x32 target after installation by running\" 1>&2", "                         echo \"  rustup target add x86_64-unknown-linux-gnux32\" 1>&2", "                         exit 1", "                    }; else", "                        _cputype=i686", "                    fi", "                }; fi", "                ;;", "            mips64)", "                _cputype=$(get_endianness mips '' el)", "                ;;", "            powerpc64)", "                _cputype=powerpc", "                ;;", "            aarch64)", "                _cputype=armv7", "                if [ \"$_ostype\" = \"linux-android\" ]; then", "                    _ostype=linux-androideabi", "                else", "                    _ostype=\"${_ostype}eabihf\"", "                fi", "                ;;", "            riscv64gc)", "                err \"riscv64 with 32-bit userland unsupported\"", "                ;;", "        esac", "    fi", "", "    # Detect armv7 but without the CPU features Rust needs in that build,", "    # and fall back to arm.", "    # See https://github.com/rust-lang/rustup.rs/issues/587.", "    if [ \"$_ostype\" = \"unknown-linux-gnueabihf\" ] && [ \"$_cputype\" = armv7 ]; then", "        if ensure grep '^Features' /proc/cpuinfo | grep -q -v neon; then", "            # At least one processor does not have NEON.", "            _cputype=arm", "        fi", "    fi", "", "    _arch=\"${_cputype}-${_ostype}\"", "", "    RETVAL=\"$_arch\"", "}", "", "say() {", "    printf 'rustup: %s\\n' \"$1\"", "}", "", "err() {", "    say \"$1\" >&2", "    exit 1", "}", "", "need_cmd() {", "    if ! check_cmd \"$1\"; then", "        err \"need '$1' (command not found)\"", "    fi", "}", "", "check_cmd() {", "    command -v \"$1\" > /dev/null 2>&1", "}", "", "assert_nz() {", "    if [ -z \"$1\" ]; then err \"assert_nz $2\"; fi", "}", "", "# Run a command that should never fail. If the command fails execution", "# will immediately terminate with an error showing the failing", "# command.", "ensure() {", "    if ! \"$@\"; then err \"command failed: $*\"; fi", "}", "", "# This is just for indicating that commands' results are being", "# intentionally ignored. Usually, because it's being executed", "# as part of error handling.", "ignore() {", "    \"$@\"", "}", "", "# This wraps curl or wget. Try curl first, if not installed,", "# use wget instead.", "downloader() {", "    local _dld", "    local _ciphersuites", "    local _err", "    local _status", "    local _retry", "    if check_cmd curl; then", "        _dld=curl", "    elif check_cmd wget; then", "        _dld=wget", "    else", "        _dld='curl or wget' # to be used in error message of need_cmd", "    fi", "", "    if [ \"$1\" = --check ]; then", "        need_cmd \"$_dld\"", "    elif [ \"$_dld\" = curl ]; then", "        check_curl_for_retry_support", "        _retry=\"$RETVAL\"", "        get_ciphersuites_for_curl", "        _ciphersuites=\"$RETVAL\"", "        if [ -n \"$_ciphersuites\" ]; then", "            _err=$(curl $_retry --proto '=https' --tlsv1.2 --ciphers \"$_ciphersuites\" --silent --show-error --fail --location \"$1\" --output \"$2\" 2>&1)", "            _status=$?", "        else", "            echo \"Warning: Not enforcing strong cipher suites for TLS, this is potentially less secure\"", "            if ! check_help_for \"$3\" curl --proto --tlsv1.2; then", "                echo \"Warning: Not enforcing TLS v1.2, this is potentially less secure\"", "                _err=$(curl $_retry --silent --show-error --fail --location \"$1\" --output \"$2\" 2>&1)", "                _status=$?", "            else", "                _err=$(curl $_retry --proto '=https' --tlsv1.2 --silent --show-error --fail --location \"$1\" --output \"$2\" 2>&1)", "                _status=$?", "            fi", "        fi", "        if [ -n \"$_err\" ]; then", "            echo \"$_err\" >&2", "            if echo \"$_err\" | grep -q 404$; then", "                err \"installer for platform '$3' not found, this may be unsupported\"", "            fi", "        fi", "        return $_status", "    elif [ \"$_dld\" = wget ]; then", "        if [ \"$(wget -V 2>&1|head -2|tail -1|cut -f1 -d\" \")\" = \"BusyBox\" ]; then", "            echo \"Warning: using the BusyBox version of wget.  Not enforcing strong cipher suites for TLS or TLS v1.2, this is potentially less secure\"", "            _err=$(wget \"$1\" -O \"$2\" 2>&1)", "            _status=$?", "        else", "            get_ciphersuites_for_wget", "            _ciphersuites=\"$RETVAL\"", "            if [ -n \"$_ciphersuites\" ]; then", "                _err=$(wget --https-only --secure-protocol=TLSv1_2 --ciphers \"$_ciphersuites\" \"$1\" -O \"$2\" 2>&1)", "                _status=$?", "            else", "                echo \"Warning: Not enforcing strong cipher suites for TLS, this is potentially less secure\"", "                if ! check_help_for \"$3\" wget --https-only --secure-protocol; then", "                    echo \"Warning: Not enforcing TLS v1.2, this is potentially less secure\"", "                    _err=$(wget \"$1\" -O \"$2\" 2>&1)", "                    _status=$?", "                else", "                    _err=$(wget --https-only --secure-protocol=TLSv1_2 \"$1\" -O \"$2\" 2>&1)", "                    _status=$?", "                fi", "            fi", "        fi", "        if [ -n \"$_err\" ]; then", "            echo \"$_err\" >&2", "            if echo \"$_err\" | grep -q ' 404 Not Found$'; then", "                err \"installer for platform '$3' not found, this may be unsupported\"", "            fi", "        fi", "        return $_status", "    else", "        err \"Unknown downloader\"   # should not reach here", "    fi", "}", "", "check_help_for() {", "    local _arch", "    local _cmd", "    local _arg", "    _arch=\"$1\"", "    shift", "    _cmd=\"$1\"", "    shift", "", "    local _category", "    if \"$_cmd\" --help | grep -q 'For all options use the manual or \"--help all\".'; then", "      _category=\"all\"", "    else", "      _category=\"\"", "    fi", "", "    case \"$_arch\" in", "", "        *darwin*)", "        if check_cmd sw_vers; then", "            case $(sw_vers -productVersion) in", "                10.*)", "                    # If we're running on macOS, older than 10.13, then we always", "                    # fail to find these options to force fallback", "                    if [ \"$(sw_vers -productVersion | cut -d. -f2)\" -lt 13 ]; then", "                        # Older than 10.13", "                        echo \"Warning: Detected macOS platform older than 10.13\"", "                        return 1", "                    fi", "                    ;;", "                11.*)", "                    # We assume Big Sur will be OK for now", "                    ;;", "                *)", "                    # Unknown product version, warn and continue", "                    echo \"Warning: Detected unknown macOS major version: $(sw_vers -productVersion)\"", "                    echo \"Warning TLS capabilities detection may fail\"", "                    ;;", "            esac", "        fi", "        ;;", "", "    esac", "", "    for _arg in \"$@\"; do", "        if ! \"$_cmd\" --help $_category | grep -q -- \"$_arg\"; then", "            return 1", "        fi", "    done", "", "    true # not strictly needed", "}", "", "# Check if curl supports the --retry flag, then pass it to the curl invocation.", "check_curl_for_retry_support() {", "  local _retry_supported=\"\"", "  # \"unspecified\" is for arch, allows for possibility old OS using macports, homebrew, etc.", "  if check_help_for \"notspecified\" \"curl\" \"--retry\"; then", "    _retry_supported=\"--retry 3\"", "  fi", "", "  RETVAL=\"$_retry_supported\"", "", "}", "", "# Return cipher suite string specified by user, otherwise return strong TLS 1.2-1.3 cipher suites", "# if support by local tools is detected. Detection currently supports these curl backends:", "# GnuTLS and OpenSSL (possibly also LibreSSL and BoringSSL). Return value can be empty.", "get_ciphersuites_for_curl() {", "    if [ -n \"${RUSTUP_TLS_CIPHERSUITES-}\" ]; then", "        # user specified custom cipher suites, assume they know what they're doing", "        RETVAL=\"$RUSTUP_TLS_CIPHERSUITES\"", "        return", "    fi", "", "    local _openssl_syntax=\"no\"", "    local _gnutls_syntax=\"no\"", "    local _backend_supported=\"yes\"", "    if curl -V | grep -q ' OpenSSL/'; then", "        _openssl_syntax=\"yes\"", "    elif curl -V | grep -iq ' LibreSSL/'; then", "        _openssl_syntax=\"yes\"", "    elif curl -V | grep -iq ' BoringSSL/'; then", "        _openssl_syntax=\"yes\"", "    elif curl -V | grep -iq ' GnuTLS/'; then", "        _gnutls_syntax=\"yes\"", "    else", "        _backend_supported=\"no\"", "    fi", "", "    local _args_supported=\"no\"", "    if [ \"$_backend_supported\" = \"yes\" ]; then", "        # \"unspecified\" is for arch, allows for possibility old OS using macports, homebrew, etc.", "        if check_help_for \"notspecified\" \"curl\" \"--tlsv1.2\" \"--ciphers\" \"--proto\"; then", "            _args_supported=\"yes\"", "        fi", "    fi", "", "    local _cs=\"\"", "    if [ \"$_args_supported\" = \"yes\" ]; then", "        if [ \"$_openssl_syntax\" = \"yes\" ]; then", "            _cs=$(get_strong_ciphersuites_for \"openssl\")", "        elif [ \"$_gnutls_syntax\" = \"yes\" ]; then", "            _cs=$(get_strong_ciphersuites_for \"gnutls\")", "        fi", "    fi", "", "    RETVAL=\"$_cs\"", "}", "", "# Return cipher suite string specified by user, otherwise return strong TLS 1.2-1.3 cipher suites", "# if support by local tools is detected. Detection currently supports these wget backends:", "# GnuTLS and OpenSSL (possibly also LibreSSL and BoringSSL). Return value can be empty.", "get_ciphersuites_for_wget() {", "    if [ -n \"${RUSTUP_TLS_CIPHERSUITES-}\" ]; then", "        # user specified custom cipher suites, assume they know what they're doing", "        RETVAL=\"$RUSTUP_TLS_CIPHERSUITES\"", "        return", "    fi", "", "    local _cs=\"\"", "    if wget -V | grep -q '\\-DHAVE_LIBSSL'; then", "        # \"unspecified\" is for arch, allows for possibility old OS using macports, homebrew, etc.", "        if check_help_for \"notspecified\" \"wget\" \"TLSv1_2\" \"--ciphers\" \"--https-only\" \"--secure-protocol\"; then", "            _cs=$(get_strong_ciphersuites_for \"openssl\")", "        fi", "    elif wget -V | grep -q '\\-DHAVE_LIBGNUTLS'; then", "        # \"unspecified\" is for arch, allows for possibility old OS using macports, homebrew, etc.", "        if check_help_for \"notspecified\" \"wget\" \"TLSv1_2\" \"--ciphers\" \"--https-only\" \"--secure-protocol\"; then", "            _cs=$(get_strong_ciphersuites_for \"gnutls\")", "        fi", "    fi", "", "    RETVAL=\"$_cs\"", "}", "", "# Return strong TLS 1.2-1.3 cipher suites in OpenSSL or GnuTLS syntax. TLS 1.2", "# excludes non-ECDHE and non-AEAD cipher suites. DHE is excluded due to bad", "# DH params often found on servers (see RFC 7919). Sequence matches or is", "# similar to Firefox 68 ESR with weak cipher suites disabled via about:config.", "# $1 must be openssl or gnutls.", "get_strong_ciphersuites_for() {", "    if [ \"$1\" = \"openssl\" ]; then", "        # OpenSSL is forgiving of unknown values, no problems with TLS 1.3 values on versions that don't support it yet.", "        echo \"TLS_AES_128_GCM_SHA256:TLS_CHACHA20_POLY1305_SHA256:TLS_AES_256_GCM_SHA384:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384\"", "    elif [ \"$1\" = \"gnutls\" ]; then", "        # GnuTLS isn't forgiving of unknown values, so this may require a GnuTLS version that supports TLS 1.3 even if wget doesn't.", "        # Begin with SECURE128 (and higher) then remove/add to build cipher suites. Produces same 9 cipher suites as OpenSSL but in slightly different order.", "        echo \"SECURE128:-VERS-SSL3.0:-VERS-TLS1.0:-VERS-TLS1.1:-VERS-DTLS-ALL:-CIPHER-ALL:-MAC-ALL:-KX-ALL:+AEAD:+ECDHE-ECDSA:+ECDHE-RSA:+AES-128-GCM:+CHACHA20-POLY1305:+AES-256-GCM\"", "    fi", "}", "", "main \"$@\" || exit 1", "curl: (6) Could not resolve host: |", "curl: (6) Could not resolve host: sh"]}
2022-12-30 00:05:14,629 p=88599 u=kal n=ansible | PLAY RECAP *******************************************************************************************************************************************
2022-12-30 00:05:14,629 p=88599 u=kal n=ansible | krpz                       : ok=3    changed=0    unreachable=0    failed=1    skipped=0    rescued=0    ignored=0   
2022-12-30 00:06:43,234 p=88949 u=kal n=ansible | Using /home/kal/MyApplications/dotfiles/playbooks/ansible.cfg as config file
2022-12-30 00:06:43,304 p=88949 u=kal n=ansible | PLAY [localhost] *************************************************************************************************************************************
2022-12-30 00:06:43,311 p=88949 u=kal n=ansible | TASK [Gathering Facts] *******************************************************************************************************************************
2022-12-30 00:06:47,293 p=88949 u=kal n=ansible | ok: [krpz]
2022-12-30 00:06:47,314 p=88949 u=kal n=ansible | TASK [install pexpect] *******************************************************************************************************************************
2022-12-30 00:06:47,741 p=88949 u=kal n=ansible | ok: [krpz] => {"changed": false, "cmd": ["/usr/bin/python2", "-m", "pip.__main__", "install", "pexpect"], "name": ["pexpect"], "requirements": null, "state": "present", "stderr": "DEPRECATION: Python 2.7 reached the end of its life on January 1st, 2020. Please upgrade your Python as Python 2.7 is no longer maintained. pip 21.0 will drop support for Python 2.7 in January 2021. More details about Python 2 support in pip can be found at https://pip.pypa.io/en/latest/development/release-process/#python-2-support pip 21.0 will remove support for this functionality.\n", "stderr_lines": ["DEPRECATION: Python 2.7 reached the end of its life on January 1st, 2020. Please upgrade your Python as Python 2.7 is no longer maintained. pip 21.0 will drop support for Python 2.7 in January 2021. More details about Python 2 support in pip can be found at https://pip.pypa.io/en/latest/development/release-process/#python-2-support pip 21.0 will remove support for this functionality."], "stdout": "Requirement already satisfied: pexpect in /usr/local/lib/python2.7/dist-packages (4.8.0)\nRequirement already satisfied: ptyprocess>=0.5 in /usr/local/lib/python2.7/dist-packages (from pexpect) (0.7.0)\n", "stdout_lines": ["Requirement already satisfied: pexpect in /usr/local/lib/python2.7/dist-packages (4.8.0)", "Requirement already satisfied: ptyprocess>=0.5 in /usr/local/lib/python2.7/dist-packages (from pexpect) (0.7.0)"], "version": null, "virtualenv": null}
2022-12-30 00:06:47,749 p=88949 u=kal n=ansible | TASK [install setuptools] ****************************************************************************************************************************
2022-12-30 00:06:48,096 p=88949 u=kal n=ansible | ok: [krpz] => {"changed": false, "cmd": ["/usr/bin/python2", "-m", "pip.__main__", "install", "setuptools"], "name": ["setuptools"], "requirements": null, "state": "present", "stderr": "DEPRECATION: Python 2.7 reached the end of its life on January 1st, 2020. Please upgrade your Python as Python 2.7 is no longer maintained. pip 21.0 will drop support for Python 2.7 in January 2021. More details about Python 2 support in pip can be found at https://pip.pypa.io/en/latest/development/release-process/#python-2-support pip 21.0 will remove support for this functionality.\n", "stderr_lines": ["DEPRECATION: Python 2.7 reached the end of its life on January 1st, 2020. Please upgrade your Python as Python 2.7 is no longer maintained. pip 21.0 will drop support for Python 2.7 in January 2021. More details about Python 2 support in pip can be found at https://pip.pypa.io/en/latest/development/release-process/#python-2-support pip 21.0 will remove support for this functionality."], "stdout": "Requirement already satisfied: setuptools in /usr/lib/python2.7/dist-packages (44.1.1)\n", "stdout_lines": ["Requirement already satisfied: setuptools in /usr/lib/python2.7/dist-packages (44.1.1)"], "version": null, "virtualenv": null}
2022-12-30 00:06:48,104 p=88949 u=kal n=ansible | TASK [Install Rust] **********************************************************************************************************************************
2022-12-30 00:06:48,393 p=88949 u=kal n=ansible | An exception occurred during task execution. To see the full traceback, use -vvv. The error was: sre_constants.error: unbalanced parenthesis
2022-12-30 00:06:48,393 p=88949 u=kal n=ansible | fatal: [krpz]: FAILED! => {"changed": false, "module_stderr": "Traceback (most recent call last):\n  File \"/home/kal/.ansible/tmp/ansible-tmp-1672376808.1139097-89138-96597447394722/AnsiballZ_expect.py\", line 107, in <module>\n    _ansiballz_main()\n  File \"/home/kal/.ansible/tmp/ansible-tmp-1672376808.1139097-89138-96597447394722/AnsiballZ_expect.py\", line 99, in _ansiballz_main\n    invoke_module(zipped_mod, temp_path, ANSIBALLZ_PARAMS)\n  File \"/home/kal/.ansible/tmp/ansible-tmp-1672376808.1139097-89138-96597447394722/AnsiballZ_expect.py\", line 48, in invoke_module\n    run_name='__main__', alter_sys=True)\n  File \"/usr/lib/python2.7/runpy.py\", line 188, in run_module\n    fname, loader, pkg_name)\n  File \"/usr/lib/python2.7/runpy.py\", line 82, in _run_module_code\n    mod_name, mod_fname, mod_loader, pkg_name)\n  File \"/usr/lib/python2.7/runpy.py\", line 72, in _run_code\n    exec code in run_globals\n  File \"/tmp/ansible_expect_payload_mO8OVL/ansible_expect_payload.zip/ansible/modules/expect.py\", line 258, in <module>\n  File \"/tmp/ansible_expect_payload_mO8OVL/ansible_expect_payload.zip/ansible/modules/expect.py\", line 212, in main\n  File \"/usr/local/lib/python2.7/dist-packages/pexpect/run.py\", line 115, in run\n    index = child.expect(patterns)\n  File \"/usr/local/lib/python2.7/dist-packages/pexpect/spawnbase.py\", line 342, in expect\n    compiled_pattern_list = self.compile_pattern_list(pattern)\n  File \"/usr/local/lib/python2.7/dist-packages/pexpect/spawnbase.py\", line 232, in compile_pattern_list\n    compiled_pattern_list.append(re.compile(p, compile_flags))\n  File \"/usr/lib/python2.7/re.py\", line 194, in compile\n    return _compile(pattern, flags)\n  File \"/usr/lib/python2.7/re.py\", line 251, in _compile\n    raise error, v # invalid expression\nsre_constants.error: unbalanced parenthesis\n", "module_stdout": "", "msg": "MODULE FAILURE\nSee stdout/stderr for the exact error", "rc": 1}
2022-12-30 00:06:48,394 p=88949 u=kal n=ansible | PLAY RECAP *******************************************************************************************************************************************
2022-12-30 00:06:48,394 p=88949 u=kal n=ansible | krpz                       : ok=3    changed=0    unreachable=0    failed=1    skipped=0    rescued=0    ignored=0   
2022-12-30 00:07:17,086 p=89189 u=kal n=ansible | Using /home/kal/MyApplications/dotfiles/playbooks/ansible.cfg as config file
2022-12-30 00:07:17,157 p=89189 u=kal n=ansible | PLAY [localhost] *************************************************************************************************************************************
2022-12-30 00:07:17,164 p=89189 u=kal n=ansible | TASK [Gathering Facts] *******************************************************************************************************************************
2022-12-30 00:07:21,168 p=89189 u=kal n=ansible | ok: [krpz]
2022-12-30 00:07:21,191 p=89189 u=kal n=ansible | TASK [install pexpect] *******************************************************************************************************************************
2022-12-30 00:07:21,620 p=89189 u=kal n=ansible | ok: [krpz] => {"changed": false, "cmd": ["/usr/bin/python2", "-m", "pip.__main__", "install", "pexpect"], "name": ["pexpect"], "requirements": null, "state": "present", "stderr": "DEPRECATION: Python 2.7 reached the end of its life on January 1st, 2020. Please upgrade your Python as Python 2.7 is no longer maintained. pip 21.0 will drop support for Python 2.7 in January 2021. More details about Python 2 support in pip can be found at https://pip.pypa.io/en/latest/development/release-process/#python-2-support pip 21.0 will remove support for this functionality.\n", "stderr_lines": ["DEPRECATION: Python 2.7 reached the end of its life on January 1st, 2020. Please upgrade your Python as Python 2.7 is no longer maintained. pip 21.0 will drop support for Python 2.7 in January 2021. More details about Python 2 support in pip can be found at https://pip.pypa.io/en/latest/development/release-process/#python-2-support pip 21.0 will remove support for this functionality."], "stdout": "Requirement already satisfied: pexpect in /usr/local/lib/python2.7/dist-packages (4.8.0)\nRequirement already satisfied: ptyprocess>=0.5 in /usr/local/lib/python2.7/dist-packages (from pexpect) (0.7.0)\n", "stdout_lines": ["Requirement already satisfied: pexpect in /usr/local/lib/python2.7/dist-packages (4.8.0)", "Requirement already satisfied: ptyprocess>=0.5 in /usr/local/lib/python2.7/dist-packages (from pexpect) (0.7.0)"], "version": null, "virtualenv": null}
2022-12-30 00:07:21,628 p=89189 u=kal n=ansible | TASK [install setuptools] ****************************************************************************************************************************
2022-12-30 00:07:21,973 p=89189 u=kal n=ansible | ok: [krpz] => {"changed": false, "cmd": ["/usr/bin/python2", "-m", "pip.__main__", "install", "setuptools"], "name": ["setuptools"], "requirements": null, "state": "present", "stderr": "DEPRECATION: Python 2.7 reached the end of its life on January 1st, 2020. Please upgrade your Python as Python 2.7 is no longer maintained. pip 21.0 will drop support for Python 2.7 in January 2021. More details about Python 2 support in pip can be found at https://pip.pypa.io/en/latest/development/release-process/#python-2-support pip 21.0 will remove support for this functionality.\n", "stderr_lines": ["DEPRECATION: Python 2.7 reached the end of its life on January 1st, 2020. Please upgrade your Python as Python 2.7 is no longer maintained. pip 21.0 will drop support for Python 2.7 in January 2021. More details about Python 2 support in pip can be found at https://pip.pypa.io/en/latest/development/release-process/#python-2-support pip 21.0 will remove support for this functionality."], "stdout": "Requirement already satisfied: setuptools in /usr/lib/python2.7/dist-packages (44.1.1)\n", "stdout_lines": ["Requirement already satisfied: setuptools in /usr/lib/python2.7/dist-packages (44.1.1)"], "version": null, "virtualenv": null}
2022-12-30 00:07:21,981 p=89189 u=kal n=ansible | TASK [Install Rust] **********************************************************************************************************************************
2022-12-30 00:07:22,284 p=89189 u=kal n=ansible | An exception occurred during task execution. To see the full traceback, use -vvv. The error was: sre_constants.error: unbalanced parenthesis
2022-12-30 00:07:22,285 p=89189 u=kal n=ansible | fatal: [krpz]: FAILED! => {"changed": false, "module_stderr": "Traceback (most recent call last):\n  File \"/home/kal/.ansible/tmp/ansible-tmp-1672376841.9926398-89377-34021955390333/AnsiballZ_expect.py\", line 107, in <module>\n    _ansiballz_main()\n  File \"/home/kal/.ansible/tmp/ansible-tmp-1672376841.9926398-89377-34021955390333/AnsiballZ_expect.py\", line 99, in _ansiballz_main\n    invoke_module(zipped_mod, temp_path, ANSIBALLZ_PARAMS)\n  File \"/home/kal/.ansible/tmp/ansible-tmp-1672376841.9926398-89377-34021955390333/AnsiballZ_expect.py\", line 48, in invoke_module\n    run_name='__main__', alter_sys=True)\n  File \"/usr/lib/python2.7/runpy.py\", line 188, in run_module\n    fname, loader, pkg_name)\n  File \"/usr/lib/python2.7/runpy.py\", line 82, in _run_module_code\n    mod_name, mod_fname, mod_loader, pkg_name)\n  File \"/usr/lib/python2.7/runpy.py\", line 72, in _run_code\n    exec code in run_globals\n  File \"/tmp/ansible_expect_payload_sQarGj/ansible_expect_payload.zip/ansible/modules/expect.py\", line 258, in <module>\n  File \"/tmp/ansible_expect_payload_sQarGj/ansible_expect_payload.zip/ansible/modules/expect.py\", line 212, in main\n  File \"/usr/local/lib/python2.7/dist-packages/pexpect/run.py\", line 115, in run\n    index = child.expect(patterns)\n  File \"/usr/local/lib/python2.7/dist-packages/pexpect/spawnbase.py\", line 342, in expect\n    compiled_pattern_list = self.compile_pattern_list(pattern)\n  File \"/usr/local/lib/python2.7/dist-packages/pexpect/spawnbase.py\", line 232, in compile_pattern_list\n    compiled_pattern_list.append(re.compile(p, compile_flags))\n  File \"/usr/lib/python2.7/re.py\", line 194, in compile\n    return _compile(pattern, flags)\n  File \"/usr/lib/python2.7/re.py\", line 251, in _compile\n    raise error, v # invalid expression\nsre_constants.error: unbalanced parenthesis\n", "module_stdout": "", "msg": "MODULE FAILURE\nSee stdout/stderr for the exact error", "rc": 1}
2022-12-30 00:07:22,287 p=89189 u=kal n=ansible | PLAY RECAP *******************************************************************************************************************************************
2022-12-30 00:07:22,287 p=89189 u=kal n=ansible | krpz                       : ok=3    changed=0    unreachable=0    failed=1    skipped=0    rescued=0    ignored=0   
2022-12-30 00:07:58,163 p=89478 u=kal n=ansible | Using /home/kal/MyApplications/dotfiles/playbooks/ansible.cfg as config file
2022-12-30 00:07:58,234 p=89478 u=kal n=ansible | PLAY [localhost] *************************************************************************************************************************************
2022-12-30 00:07:58,240 p=89478 u=kal n=ansible | TASK [Gathering Facts] *******************************************************************************************************************************
2022-12-30 00:08:02,182 p=89478 u=kal n=ansible | ok: [krpz]
2022-12-30 00:08:02,203 p=89478 u=kal n=ansible | TASK [install pexpect] *******************************************************************************************************************************
2022-12-30 00:08:02,632 p=89478 u=kal n=ansible | ok: [krpz] => {"changed": false, "cmd": ["/usr/bin/python2", "-m", "pip.__main__", "install", "pexpect"], "name": ["pexpect"], "requirements": null, "state": "present", "stderr": "DEPRECATION: Python 2.7 reached the end of its life on January 1st, 2020. Please upgrade your Python as Python 2.7 is no longer maintained. pip 21.0 will drop support for Python 2.7 in January 2021. More details about Python 2 support in pip can be found at https://pip.pypa.io/en/latest/development/release-process/#python-2-support pip 21.0 will remove support for this functionality.\n", "stderr_lines": ["DEPRECATION: Python 2.7 reached the end of its life on January 1st, 2020. Please upgrade your Python as Python 2.7 is no longer maintained. pip 21.0 will drop support for Python 2.7 in January 2021. More details about Python 2 support in pip can be found at https://pip.pypa.io/en/latest/development/release-process/#python-2-support pip 21.0 will remove support for this functionality."], "stdout": "Requirement already satisfied: pexpect in /usr/local/lib/python2.7/dist-packages (4.8.0)\nRequirement already satisfied: ptyprocess>=0.5 in /usr/local/lib/python2.7/dist-packages (from pexpect) (0.7.0)\n", "stdout_lines": ["Requirement already satisfied: pexpect in /usr/local/lib/python2.7/dist-packages (4.8.0)", "Requirement already satisfied: ptyprocess>=0.5 in /usr/local/lib/python2.7/dist-packages (from pexpect) (0.7.0)"], "version": null, "virtualenv": null}
2022-12-30 00:08:02,640 p=89478 u=kal n=ansible | TASK [install setuptools] ****************************************************************************************************************************
2022-12-30 00:08:02,988 p=89478 u=kal n=ansible | ok: [krpz] => {"changed": false, "cmd": ["/usr/bin/python2", "-m", "pip.__main__", "install", "setuptools"], "name": ["setuptools"], "requirements": null, "state": "present", "stderr": "DEPRECATION: Python 2.7 reached the end of its life on January 1st, 2020. Please upgrade your Python as Python 2.7 is no longer maintained. pip 21.0 will drop support for Python 2.7 in January 2021. More details about Python 2 support in pip can be found at https://pip.pypa.io/en/latest/development/release-process/#python-2-support pip 21.0 will remove support for this functionality.\n", "stderr_lines": ["DEPRECATION: Python 2.7 reached the end of its life on January 1st, 2020. Please upgrade your Python as Python 2.7 is no longer maintained. pip 21.0 will drop support for Python 2.7 in January 2021. More details about Python 2 support in pip can be found at https://pip.pypa.io/en/latest/development/release-process/#python-2-support pip 21.0 will remove support for this functionality."], "stdout": "Requirement already satisfied: setuptools in /usr/lib/python2.7/dist-packages (44.1.1)\n", "stdout_lines": ["Requirement already satisfied: setuptools in /usr/lib/python2.7/dist-packages (44.1.1)"], "version": null, "virtualenv": null}
2022-12-30 00:08:02,996 p=89478 u=kal n=ansible | TASK [Install Rust] **********************************************************************************************************************************
2022-12-30 00:08:04,175 p=89478 u=kal n=ansible | fatal: [krpz]: FAILED! => {"changed": true, "cmd": "curl https://sh.rustup.rs | sh", "delta": "0:00:00.960257", "end": "2022-12-30 00:08:04.117688", "msg": "non-zero return code", "rc": 6, "start": "2022-12-30 00:08:03.157431", "stdout": "#!/bin/sh\r\n# shellcheck shell=dash\r\n\r\n# This is just a little script that can be downloaded from the internet to\r\n# install rustup. It just does platform detection, downloads the installer\r\n# and runs it.\r\n\r\n# It runs on Unix shells like {a,ba,da,k,z}sh. It uses the common `local`\r\n# extension. Note: Most shells limit `local` to 1 var per line, contra bash.\r\n\r\nif [ \"$KSH_VERSION\" = 'Version JM 93t+ 2010-03-05' ]; then\r\n    # The version of ksh93 that ships with many illumos systems does not\r\n    # support the \"local\" extension.  Print a message rather than fail in\r\n    # subtle ways later on:\r\n    echo 'rustup does not work with this ksh93 version; please try bash!' >&2\r\n    exit 1\r\nfi\r\n\r\n\r\nset -u\r\n\r\n# If RUSTUP_UPDATE_ROOT is unset or empty, default it.\r\nRUSTUP_UPDATE_ROOT=\"${RUSTUP_UPDATE_ROOT:-https://static.rust-lang.org/rustup}\"\r\n\r\n#XXX: If you change anything here, please make the same changes in setup_mode.rs\r\nusage() {\r\n    cat 1>&2 <<EOF\r\nrustup-init 1.25.1 (48d233f65 2022-07-12)\r\nThe installer for rustup\r\n\r\nUSAGE:\r\n    rustup-init [FLAGS] [OPTIONS]\r\n\r\nFLAGS:\r\n    -v, --verbose           Enable verbose output\r\n    -q, --quiet             Disable progress output\r\n    -y                      Disable confirmation prompt.\r\n        --no-modify-path    Don't configure the PATH environment variable\r\n    -h, --help              Prints help information\r\n    -V, --version           Prints version information\r\n\r\nOPTIONS:\r\n        --default-host <default-host>              Choose a default host triple\r\n        --default-toolchain <default-toolchain>    Choose a default toolchain to install\r\n        --default-toolchain none                   Do not install any toolchains\r\n        --profile [minimal|default|complete]       Choose a profile\r\n    -c, --component <components>...                Component name to also install\r\n    -t, --target <targets>...                      Target name to also install\r\nEOF\r\n}\r\n\r\nmain() {\r\n    downloader --check\r\n    need_cmd uname\r\n    need_cmd mktemp\r\n    need_cmd chmod\r\n    need_cmd mkdir\r\n    need_cmd rm\r\n    need_cmd rmdir\r\n\r\n    get_architecture || return 1\r\n    local _arch=\"$RETVAL\"\r\n    assert_nz \"$_arch\" \"arch\"\r\n\r\n    local _ext=\"\"\r\n    case \"$_arch\" in\r\n        *windows*)\r\n            _ext=\".exe\"\r\n            ;;\r\n    esac\r\n\r\n    local _url=\"${RUSTUP_UPDATE_ROOT}/dist/${_arch}/rustup-init${_ext}\"\r\n\r\n    local _dir\r\n    _dir=\"$(ensure mktemp -d)\"\r\n    local _file=\"${_dir}/rustup-init${_ext}\"\r\n\r\n    local _ansi_escapes_are_valid=false\r\n    if [ -t 2 ]; then\r\n        if [ \"${TERM+set}\" = 'set' ]; then\r\n            case \"$TERM\" in\r\n                xterm*|rxvt*|urxvt*|linux*|vt*)\r\n                    _ansi_escapes_are_valid=true\r\n                ;;\r\n            esac\r\n        fi\r\n    fi\r\n\r\n    # check if we have to use /dev/tty to prompt the user\r\n    local need_tty=yes\r\n    for arg in \"$@\"; do\r\n        case \"$arg\" in\r\n            --help)\r\n                usage\r\n                exit 0\r\n                ;;\r\n            *)\r\n                OPTIND=1\r\n                if [ \"${arg%%--*}\" = \"\" ]; then\r\n                    # Long option (other than --help);\r\n                    # don't attempt to interpret it.\r\n                    continue\r\n                fi\r\n                while getopts :hy sub_arg \"$arg\"; do\r\n                    case \"$sub_arg\" in\r\n                        h)\r\n                            usage\r\n                            exit 0\r\n                            ;;\r\n                        y)\r\n                            # user wants to skip the prompt --\r\n                            # we don't need /dev/tty\r\n                            need_tty=no\r\n                            ;;\r\n                        *)\r\n                            ;;\r\n                        esac\r\n                done\r\n                ;;\r\n        esac\r\n    done\r\n\r\n    if $_ansi_escapes_are_valid; then\r\n        printf \"\\33[1minfo:\\33[0m downloading installer\\n\" 1>&2\r\n    else\r\n        printf '%s\\n' 'info: downloading installer' 1>&2\r\n    fi\r\n\r\n    ensure mkdir -p \"$_dir\"\r\n    ensure downloader \"$_url\" \"$_file\" \"$_arch\"\r\n    ensure chmod u+x \"$_file\"\r\n    if [ ! -x \"$_file\" ]; then\r\n        printf '%s\\n' \"Cannot execute $_file (likely because of mounting /tmp as noexec).\" 1>&2\r\n        printf '%s\\n' \"Please copy the file to a location where you can execute binaries and run ./rustup-init${_ext}.\" 1>&2\r\n        exit 1\r\n    fi\r\n\r\n    if [ \"$need_tty\" = \"yes\" ] && [ ! -t 0 ]; then\r\n        # The installer is going to want to ask for confirmation by\r\n        # reading stdin.  This script was piped into `sh` though and\r\n        # doesn't have stdin to pass to its children. Instead we're going\r\n        # to explicitly connect /dev/tty to the installer's stdin.\r\n        if [ ! -t 1 ]; then\r\n            err \"Unable to run interactively. Run with -y to accept defaults, --help for additional options\"\r\n        fi\r\n\r\n        ignore \"$_file\" \"$@\" < /dev/tty\r\n    else\r\n        ignore \"$_file\" \"$@\"\r\n    fi\r\n\r\n    local _retval=$?\r\n\r\n    ignore rm \"$_file\"\r\n    ignore rmdir \"$_dir\"\r\n\r\n    return \"$_retval\"\r\n}\r\n\r\ncheck_proc() {\r\n    # Check for /proc by looking for the /proc/self/exe link\r\n    # This is only run on Linux\r\n    if ! test -L /proc/self/exe ; then\r\n        err \"fatal: Unable to find /proc/self/exe.  Is /proc mounted?  Installation cannot proceed without /proc.\"\r\n    fi\r\n}\r\n\r\nget_bitness() {\r\n    need_cmd head\r\n    # Architecture detection without dependencies beyond coreutils.\r\n    # ELF files start out \"\\x7fELF\", and the following byte is\r\n    #   0x01 for 32-bit and\r\n    #   0x02 for 64-bit.\r\n    # The printf builtin on some shells like dash only supports octal\r\n    # escape sequences, so we use those.\r\n    local _current_exe_head\r\n    _current_exe_head=$(head -c 5 /proc/self/exe )\r\n    if [ \"$_current_exe_head\" = \"$(printf '\\177ELF\\001')\" ]; then\r\n        echo 32\r\n    elif [ \"$_current_exe_head\" = \"$(printf '\\177ELF\\002')\" ]; then\r\n        echo 64\r\n    else\r\n        err \"unknown platform bitness\"\r\n    fi\r\n}\r\n\r\nis_host_amd64_elf() {\r\n    need_cmd head\r\n    need_cmd tail\r\n    # ELF e_machine detection without dependencies beyond coreutils.\r\n    # Two-byte field at offset 0x12 indicates the CPU,\r\n    # but we're interested in it being 0x3E to indicate amd64, or not that.\r\n    local _current_exe_machine\r\n    _current_exe_machine=$(head -c 19 /proc/self/exe | tail -c 1)\r\n    [ \"$_current_exe_machine\" = \"$(printf '\\076')\" ]\r\n}\r\n\r\nget_endianness() {\r\n    local cputype=$1\r\n    local suffix_eb=$2\r\n    local suffix_el=$3\r\n\r\n    # detect endianness without od/hexdump, like get_bitness() does.\r\n    need_cmd head\r\n    need_cmd tail\r\n\r\n    local _current_exe_endianness\r\n    _current_exe_endianness=\"$(head -c 6 /proc/self/exe | tail -c 1)\"\r\n    if [ \"$_current_exe_endianness\" = \"$(printf '\\001')\" ]; then\r\n        echo \"${cputype}${suffix_el}\"\r\n    elif [ \"$_current_exe_endianness\" = \"$(printf '\\002')\" ]; then\r\n        echo \"${cputype}${suffix_eb}\"\r\n    else\r\n        err \"unknown platform endianness\"\r\n    fi\r\n}\r\n\r\nget_architecture() {\r\n    local _ostype _cputype _bitness _arch _clibtype\r\n    _ostype=\"$(uname -s)\"\r\n    _cputype=\"$(uname -m)\"\r\n    _clibtype=\"gnu\"\r\n\r\n    if [ \"$_ostype\" = Linux ]; then\r\n        if [ \"$(uname -o)\" = Android ]; then\r\n            _ostype=Android\r\n        fi\r\n        if ldd --version 2>&1 | grep -q 'musl'; then\r\n            _clibtype=\"musl\"\r\n        fi\r\n    fi\r\n\r\n    if [ \"$_ostype\" = Darwin ] && [ \"$_cputype\" = i386 ]; then\r\n        # Darwin `uname -m` lies\r\n        if sysctl hw.optional.x86_64 | grep -q ': 1'; then\r\n            _cputype=x86_64\r\n        fi\r\n    fi\r\n\r\n    if [ \"$_ostype\" = SunOS ]; then\r\n        # Both Solaris and illumos presently announce as \"SunOS\" in \"uname -s\"\r\n        # so use \"uname -o\" to disambiguate.  We use the full path to the\r\n        # system uname in case the user has coreutils uname first in PATH,\r\n        # which has historically sometimes printed the wrong value here.\r\n        if [ \"$(/usr/bin/uname -o)\" = illumos ]; then\r\n            _ostype=illumos\r\n        fi\r\n\r\n        # illumos systems have multi-arch userlands, and \"uname -m\" reports the\r\n        # machine hardware name; e.g., \"i86pc\" on both 32- and 64-bit x86\r\n        # systems.  Check for the native (widest) instruction set on the\r\n        # running kernel:\r\n        if [ \"$_cputype\" = i86pc ]; then\r\n            _cputype=\"$(isainfo -n)\"\r\n        fi\r\n    fi\r\n\r\n    case \"$_ostype\" in\r\n\r\n        Android)\r\n            _ostype=linux-android\r\n            ;;\r\n\r\n        Linux)\r\n            check_proc\r\n            _ostype=unknown-linux-$_clibtype\r\n            _bitness=$(get_bitness)\r\n            ;;\r\n\r\n        FreeBSD)\r\n            _ostype=unknown-freebsd\r\n            ;;\r\n\r\n        NetBSD)\r\n            _ostype=unknown-netbsd\r\n            ;;\r\n\r\n        DragonFly)\r\n            _ostype=unknown-dragonfly\r\n            ;;\r\n\r\n        Darwin)\r\n            _ostype=apple-darwin\r\n            ;;\r\n\r\n        illumos)\r\n            _ostype=unknown-illumos\r\n            ;;\r\n\r\n        MINGW* | MSYS* | CYGWIN* | Windows_NT)\r\n            _ostype=pc-windows-gnu\r\n            ;;\r\n\r\n        *)\r\n            err \"unrecognized OS type: $_ostype\"\r\n            ;;\r\n\r\n    esac\r\n\r\n    case \"$_cputype\" in\r\n\r\n        i386 | i486 | i686 | i786 | x86)\r\n            _cputype=i686\r\n            ;;\r\n\r\n        xscale | arm)\r\n            _cputype=arm\r\n            if [ \"$_ostype\" = \"linux-android\" ]; then\r\n                _ostype=linux-androideabi\r\n            fi\r\n            ;;\r\n\r\n        armv6l)\r\n            _cputype=arm\r\n            if [ \"$_ostype\" = \"linux-android\" ]; then\r\n                _ostype=linux-androideabi\r\n            else\r\n                _ostype=\"${_ostype}eabihf\"\r\n            fi\r\n            ;;\r\n\r\n        armv7l | armv8l)\r\n            _cputype=armv7\r\n            if [ \"$_ostype\" = \"linux-android\" ]; then\r\n                _ostype=linux-androideabi\r\n            else\r\n                _ostype=\"${_ostype}eabihf\"\r\n            fi\r\n            ;;\r\n\r\n        aarch64 | arm64)\r\n            _cputype=aarch64\r\n            ;;\r\n\r\n        x86_64 | x86-64 | x64 | amd64)\r\n            _cputype=x86_64\r\n            ;;\r\n\r\n        mips)\r\n            _cputype=$(get_endianness mips '' el)\r\n            ;;\r\n\r\n        mips64)\r\n            if [ \"$_bitness\" -eq 64 ]; then\r\n                # only n64 ABI is supported for now\r\n                _ostype=\"${_ostype}abi64\"\r\n                _cputype=$(get_endianness mips64 '' el)\r\n            fi\r\n            ;;\r\n\r\n        ppc)\r\n            _cputype=powerpc\r\n            ;;\r\n\r\n        ppc64)\r\n            _cputype=powerpc64\r\n            ;;\r\n\r\n        ppc64le)\r\n            _cputype=powerpc64le\r\n            ;;\r\n\r\n        s390x)\r\n            _cputype=s390x\r\n            ;;\r\n        riscv64)\r\n            _cputype=riscv64gc\r\n            ;;\r\n        *)\r\n            err \"unknown CPU type: $_cputype\"\r\n\r\n    esac\r\n\r\n    # Detect 64-bit linux with 32-bit userland\r\n    if [ \"${_ostype}\" = unknown-linux-gnu ] && [ \"${_bitness}\" -eq 32 ]; then\r\n        case $_cputype in\r\n            x86_64)\r\n                if [ -n \"${RUSTUP_CPUTYPE:-}\" ]; then\r\n                    _cputype=\"$RUSTUP_CPUTYPE\"\r\n                else {\r\n                    # 32-bit executable for amd64 = x32\r\n                    if is_host_amd64_elf; then {\r\n                         echo \"This host is running an x32 userland; as it stands, x32 support is poor,\" 1>&2\r\n                         echo \"and there isn't a native toolchain -- you will have to install\" 1>&2\r\n                         echo \"multiarch compatibility with i686 and/or amd64, then select one\" 1>&2\r\n                         echo \"by re-running this script with the RUSTUP_CPUTYPE environment variable\" 1>&2\r\n                         echo \"set to i686 or x86_64, respectively.\" 1>&2\r\n                         echo 1>&2\r\n                         echo \"You will be able to add an x32 target after installation by running\" 1>&2\r\n                         echo \"  rustup target add x86_64-unknown-linux-gnux32\" 1>&2\r\n                         exit 1\r\n                    }; else\r\n                        _cputype=i686\r\n                    fi\r\n                }; fi\r\n                ;;\r\n            mips64)\r\n                _cputype=$(get_endianness mips '' el)\r\n                ;;\r\n            powerpc64)\r\n                _cputype=powerpc\r\n                ;;\r\n            aarch64)\r\n                _cputype=armv7\r\n                if [ \"$_ostype\" = \"linux-android\" ]; then\r\n                    _ostype=linux-androideabi\r\n                else\r\n                    _ostype=\"${_ostype}eabihf\"\r\n                fi\r\n                ;;\r\n            riscv64gc)\r\n                err \"riscv64 with 32-bit userland unsupported\"\r\n                ;;\r\n        esac\r\n    fi\r\n\r\n    # Detect armv7 but without the CPU features Rust needs in that build,\r\n    # and fall back to arm.\r\n    # See https://github.com/rust-lang/rustup.rs/issues/587.\r\n    if [ \"$_ostype\" = \"unknown-linux-gnueabihf\" ] && [ \"$_cputype\" = armv7 ]; then\r\n        if ensure grep '^Features' /proc/cpuinfo | grep -q -v neon; then\r\n            # At least one processor does not have NEON.\r\n            _cputype=arm\r\n        fi\r\n    fi\r\n\r\n    _arch=\"${_cputype}-${_ostype}\"\r\n\r\n    RETVAL=\"$_arch\"\r\n}\r\n\r\nsay() {\r\n    printf 'rustup: %s\\n' \"$1\"\r\n}\r\n\r\nerr() {\r\n    say \"$1\" >&2\r\n    exit 1\r\n}\r\n\r\nneed_cmd() {\r\n    if ! check_cmd \"$1\"; then\r\n        err \"need '$1' (command not found)\"\r\n    fi\r\n}\r\n\r\ncheck_cmd() {\r\n    command -v \"$1\" > /dev/null 2>&1\r\n}\r\n\r\nassert_nz() {\r\n    if [ -z \"$1\" ]; then err \"assert_nz $2\"; fi\r\n}\r\n\r\n# Run a command that should never fail. If the command fails execution\r\n# will immediately terminate with an error showing the failing\r\n# command.\r\nensure() {\r\n    if ! \"$@\"; then err \"command failed: $*\"; fi\r\n}\r\n\r\n# This is just for indicating that commands' results are being\r\n# intentionally ignored. Usually, because it's being executed\r\n# as part of error handling.\r\nignore() {\r\n    \"$@\"\r\n}\r\n\r\n# This wraps curl or wget. Try curl first, if not installed,\r\n# use wget instead.\r\ndownloader() {\r\n    local _dld\r\n    local _ciphersuites\r\n    local _err\r\n    local _status\r\n    local _retry\r\n    if check_cmd curl; then\r\n        _dld=curl\r\n    elif check_cmd wget; then\r\n        _dld=wget\r\n    else\r\n        _dld='curl or wget' # to be used in error message of need_cmd\r\n    fi\r\n\r\n    if [ \"$1\" = --check ]; then\r\n        need_cmd \"$_dld\"\r\n    elif [ \"$_dld\" = curl ]; then\r\n        check_curl_for_retry_support\r\n        _retry=\"$RETVAL\"\r\n        get_ciphersuites_for_curl\r\n        _ciphersuites=\"$RETVAL\"\r\n        if [ -n \"$_ciphersuites\" ]; then\r\n            _err=$(curl $_retry --proto '=https' --tlsv1.2 --ciphers \"$_ciphersuites\" --silent --show-error --fail --location \"$1\" --output \"$2\" 2>&1)\r\n            _status=$?\r\n        else\r\n            echo \"Warning: Not enforcing strong cipher suites for TLS, this is potentially less secure\"\r\n            if ! check_help_for \"$3\" curl --proto --tlsv1.2; then\r\n                echo \"Warning: Not enforcing TLS v1.2, this is potentially less secure\"\r\n                _err=$(curl $_retry --silent --show-error --fail --location \"$1\" --output \"$2\" 2>&1)\r\n                _status=$?\r\n            else\r\n                _err=$(curl $_retry --proto '=https' --tlsv1.2 --silent --show-error --fail --location \"$1\" --output \"$2\" 2>&1)\r\n                _status=$?\r\n            fi\r\n        fi\r\n        if [ -n \"$_err\" ]; then\r\n            echo \"$_err\" >&2\r\n            if echo \"$_err\" | grep -q 404$; then\r\n                err \"installer for platform '$3' not found, this may be unsupported\"\r\n            fi\r\n        fi\r\n        return $_status\r\n    elif [ \"$_dld\" = wget ]; then\r\n        if [ \"$(wget -V 2>&1|head -2|tail -1|cut -f1 -d\" \")\" = \"BusyBox\" ]; then\r\n            echo \"Warning: using the BusyBox version of wget.  Not enforcing strong cipher suites for TLS or TLS v1.2, this is potentially less secure\"\r\n            _err=$(wget \"$1\" -O \"$2\" 2>&1)\r\n            _status=$?\r\n        else\r\n            get_ciphersuites_for_wget\r\n            _ciphersuites=\"$RETVAL\"\r\n            if [ -n \"$_ciphersuites\" ]; then\r\n                _err=$(wget --https-only --secure-protocol=TLSv1_2 --ciphers \"$_ciphersuites\" \"$1\" -O \"$2\" 2>&1)\r\n                _status=$?\r\n            else\r\n                echo \"Warning: Not enforcing strong cipher suites for TLS, this is potentially less secure\"\r\n                if ! check_help_for \"$3\" wget --https-only --secure-protocol; then\r\n                    echo \"Warning: Not enforcing TLS v1.2, this is potentially less secure\"\r\n                    _err=$(wget \"$1\" -O \"$2\" 2>&1)\r\n                    _status=$?\r\n                else\r\n                    _err=$(wget --https-only --secure-protocol=TLSv1_2 \"$1\" -O \"$2\" 2>&1)\r\n                    _status=$?\r\n                fi\r\n            fi\r\n        fi\r\n        if [ -n \"$_err\" ]; then\r\n            echo \"$_err\" >&2\r\n            if echo \"$_err\" | grep -q ' 404 Not Found$'; then\r\n                err \"installer for platform '$3' not found, this may be unsupported\"\r\n            fi\r\n        fi\r\n        return $_status\r\n    else\r\n        err \"Unknown downloader\"   # should not reach here\r\n    fi\r\n}\r\n\r\ncheck_help_for() {\r\n    local _arch\r\n    local _cmd\r\n    local _arg\r\n    _arch=\"$1\"\r\n    shift\r\n    _cmd=\"$1\"\r\n    shift\r\n\r\n    local _category\r\n    if \"$_cmd\" --help | grep -q 'For all options use the manual or \"--help all\".'; then\r\n      _category=\"all\"\r\n    else\r\n      _category=\"\"\r\n    fi\r\n\r\n    case \"$_arch\" in\r\n\r\n        *darwin*)\r\n        if check_cmd sw_vers; then\r\n            case $(sw_vers -productVersion) in\r\n                10.*)\r\n                    # If we're running on macOS, older than 10.13, then we always\r\n                    # fail to find these options to force fallback\r\n                    if [ \"$(sw_vers -productVersion | cut -d. -f2)\" -lt 13 ]; then\r\n                        # Older than 10.13\r\n                        echo \"Warning: Detected macOS platform older than 10.13\"\r\n                        return 1\r\n                    fi\r\n                    ;;\r\n                11.*)\r\n                    # We assume Big Sur will be OK for now\r\n                    ;;\r\n                *)\r\n                    # Unknown product version, warn and continue\r\n                    echo \"Warning: Detected unknown macOS major version: $(sw_vers -productVersion)\"\r\n                    echo \"Warning TLS capabilities detection may fail\"\r\n                    ;;\r\n            esac\r\n        fi\r\n        ;;\r\n\r\n    esac\r\n\r\n    for _arg in \"$@\"; do\r\n        if ! \"$_cmd\" --help $_category | grep -q -- \"$_arg\"; then\r\n            return 1\r\n        fi\r\n    done\r\n\r\n    true # not strictly needed\r\n}\r\n\r\n# Check if curl supports the --retry flag, then pass it to the curl invocation.\r\ncheck_curl_for_retry_support() {\r\n  local _retry_supported=\"\"\r\n  # \"unspecified\" is for arch, allows for possibility old OS using macports, homebrew, etc.\r\n  if check_help_for \"notspecified\" \"curl\" \"--retry\"; then\r\n    _retry_supported=\"--retry 3\"\r\n  fi\r\n\r\n  RETVAL=\"$_retry_supported\"\r\n\r\n}\r\n\r\n# Return cipher suite string specified by user, otherwise return strong TLS 1.2-1.3 cipher suites\r\n# if support by local tools is detected. Detection currently supports these curl backends:\r\n# GnuTLS and OpenSSL (possibly also LibreSSL and BoringSSL). Return value can be empty.\r\nget_ciphersuites_for_curl() {\r\n    if [ -n \"${RUSTUP_TLS_CIPHERSUITES-}\" ]; then\r\n        # user specified custom cipher suites, assume they know what they're doing\r\n        RETVAL=\"$RUSTUP_TLS_CIPHERSUITES\"\r\n        return\r\n    fi\r\n\r\n    local _openssl_syntax=\"no\"\r\n    local _gnutls_syntax=\"no\"\r\n    local _backend_supported=\"yes\"\r\n    if curl -V | grep -q ' OpenSSL/'; then\r\n        _openssl_syntax=\"yes\"\r\n    elif curl -V | grep -iq ' LibreSSL/'; then\r\n        _openssl_syntax=\"yes\"\r\n    elif curl -V | grep -iq ' BoringSSL/'; then\r\n        _openssl_syntax=\"yes\"\r\n    elif curl -V | grep -iq ' GnuTLS/'; then\r\n        _gnutls_syntax=\"yes\"\r\n    else\r\n        _backend_supported=\"no\"\r\n    fi\r\n\r\n    local _args_supported=\"no\"\r\n    if [ \"$_backend_supported\" = \"yes\" ]; then\r\n        # \"unspecified\" is for arch, allows for possibility old OS using macports, homebrew, etc.\r\n        if check_help_for \"notspecified\" \"curl\" \"--tlsv1.2\" \"--ciphers\" \"--proto\"; then\r\n            _args_supported=\"yes\"\r\n        fi\r\n    fi\r\n\r\n    local _cs=\"\"\r\n    if [ \"$_args_supported\" = \"yes\" ]; then\r\n        if [ \"$_openssl_syntax\" = \"yes\" ]; then\r\n            _cs=$(get_strong_ciphersuites_for \"openssl\")\r\n        elif [ \"$_gnutls_syntax\" = \"yes\" ]; then\r\n            _cs=$(get_strong_ciphersuites_for \"gnutls\")\r\n        fi\r\n    fi\r\n\r\n    RETVAL=\"$_cs\"\r\n}\r\n\r\n# Return cipher suite string specified by user, otherwise return strong TLS 1.2-1.3 cipher suites\r\n# if support by local tools is detected. Detection currently supports these wget backends:\r\n# GnuTLS and OpenSSL (possibly also LibreSSL and BoringSSL). Return value can be empty.\r\nget_ciphersuites_for_wget() {\r\n    if [ -n \"${RUSTUP_TLS_CIPHERSUITES-}\" ]; then\r\n        # user specified custom cipher suites, assume they know what they're doing\r\n        RETVAL=\"$RUSTUP_TLS_CIPHERSUITES\"\r\n        return\r\n    fi\r\n\r\n    local _cs=\"\"\r\n    if wget -V | grep -q '\\-DHAVE_LIBSSL'; then\r\n        # \"unspecified\" is for arch, allows for possibility old OS using macports, homebrew, etc.\r\n        if check_help_for \"notspecified\" \"wget\" \"TLSv1_2\" \"--ciphers\" \"--https-only\" \"--secure-protocol\"; then\r\n            _cs=$(get_strong_ciphersuites_for \"openssl\")\r\n        fi\r\n    elif wget -V | grep -q '\\-DHAVE_LIBGNUTLS'; then\r\n        # \"unspecified\" is for arch, allows for possibility old OS using macports, homebrew, etc.\r\n        if check_help_for \"notspecified\" \"wget\" \"TLSv1_2\" \"--ciphers\" \"--https-only\" \"--secure-protocol\"; then\r\n            _cs=$(get_strong_ciphersuites_for \"gnutls\")\r\n        fi\r\n    fi\r\n\r\n    RETVAL=\"$_cs\"\r\n}\r\n\r\n# Return strong TLS 1.2-1.3 cipher suites in OpenSSL or GnuTLS syntax. TLS 1.2\r\n# excludes non-ECDHE and non-AEAD cipher suites. DHE is excluded due to bad\r\n# DH params often found on servers (see RFC 7919). Sequence matches or is\r\n# similar to Firefox 68 ESR with weak cipher suites disabled via about:config.\r\n# $1 must be openssl or gnutls.\r\nget_strong_ciphersuites_for() {\r\n    if [ \"$1\" = \"openssl\" ]; then\r\n        # OpenSSL is forgiving of unknown values, no problems with TLS 1.3 values on versions that don't support it yet.\r\n        echo \"TLS_AES_128_GCM_SHA256:TLS_CHACHA20_POLY1305_SHA256:TLS_AES_256_GCM_SHA384:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384\"\r\n    elif [ \"$1\" = \"gnutls\" ]; then\r\n        # GnuTLS isn't forgiving of unknown values, so this may require a GnuTLS version that supports TLS 1.3 even if wget doesn't.\r\n        # Begin with SECURE128 (and higher) then remove/add to build cipher suites. Produces same 9 cipher suites as OpenSSL but in slightly different order.\r\n        echo \"SECURE128:-VERS-SSL3.0:-VERS-TLS1.0:-VERS-TLS1.1:-VERS-DTLS-ALL:-CIPHER-ALL:-MAC-ALL:-KX-ALL:+AEAD:+ECDHE-ECDSA:+ECDHE-RSA:+AES-128-GCM:+CHACHA20-POLY1305:+AES-256-GCM\"\r\n    fi\r\n}\r\n\r\nmain \"$@\" || exit 1\r\ncurl: (6) Could not resolve host: |\r\ncurl: (6) Could not resolve host: sh", "stdout_lines": ["#!/bin/sh", "# shellcheck shell=dash", "", "# This is just a little script that can be downloaded from the internet to", "# install rustup. It just does platform detection, downloads the installer", "# and runs it.", "", "# It runs on Unix shells like {a,ba,da,k,z}sh. It uses the common `local`", "# extension. Note: Most shells limit `local` to 1 var per line, contra bash.", "", "if [ \"$KSH_VERSION\" = 'Version JM 93t+ 2010-03-05' ]; then", "    # The version of ksh93 that ships with many illumos systems does not", "    # support the \"local\" extension.  Print a message rather than fail in", "    # subtle ways later on:", "    echo 'rustup does not work with this ksh93 version; please try bash!' >&2", "    exit 1", "fi", "", "", "set -u", "", "# If RUSTUP_UPDATE_ROOT is unset or empty, default it.", "RUSTUP_UPDATE_ROOT=\"${RUSTUP_UPDATE_ROOT:-https://static.rust-lang.org/rustup}\"", "", "#XXX: If you change anything here, please make the same changes in setup_mode.rs", "usage() {", "    cat 1>&2 <<EOF", "rustup-init 1.25.1 (48d233f65 2022-07-12)", "The installer for rustup", "", "USAGE:", "    rustup-init [FLAGS] [OPTIONS]", "", "FLAGS:", "    -v, --verbose           Enable verbose output", "    -q, --quiet             Disable progress output", "    -y                      Disable confirmation prompt.", "        --no-modify-path    Don't configure the PATH environment variable", "    -h, --help              Prints help information", "    -V, --version           Prints version information", "", "OPTIONS:", "        --default-host <default-host>              Choose a default host triple", "        --default-toolchain <default-toolchain>    Choose a default toolchain to install", "        --default-toolchain none                   Do not install any toolchains", "        --profile [minimal|default|complete]       Choose a profile", "    -c, --component <components>...                Component name to also install", "    -t, --target <targets>...                      Target name to also install", "EOF", "}", "", "main() {", "    downloader --check", "    need_cmd uname", "    need_cmd mktemp", "    need_cmd chmod", "    need_cmd mkdir", "    need_cmd rm", "    need_cmd rmdir", "", "    get_architecture || return 1", "    local _arch=\"$RETVAL\"", "    assert_nz \"$_arch\" \"arch\"", "", "    local _ext=\"\"", "    case \"$_arch\" in", "        *windows*)", "            _ext=\".exe\"", "            ;;", "    esac", "", "    local _url=\"${RUSTUP_UPDATE_ROOT}/dist/${_arch}/rustup-init${_ext}\"", "", "    local _dir", "    _dir=\"$(ensure mktemp -d)\"", "    local _file=\"${_dir}/rustup-init${_ext}\"", "", "    local _ansi_escapes_are_valid=false", "    if [ -t 2 ]; then", "        if [ \"${TERM+set}\" = 'set' ]; then", "            case \"$TERM\" in", "                xterm*|rxvt*|urxvt*|linux*|vt*)", "                    _ansi_escapes_are_valid=true", "                ;;", "            esac", "        fi", "    fi", "", "    # check if we have to use /dev/tty to prompt the user", "    local need_tty=yes", "    for arg in \"$@\"; do", "        case \"$arg\" in", "            --help)", "                usage", "                exit 0", "                ;;", "            *)", "                OPTIND=1", "                if [ \"${arg%%--*}\" = \"\" ]; then", "                    # Long option (other than --help);", "                    # don't attempt to interpret it.", "                    continue", "                fi", "                while getopts :hy sub_arg \"$arg\"; do", "                    case \"$sub_arg\" in", "                        h)", "                            usage", "                            exit 0", "                            ;;", "                        y)", "                            # user wants to skip the prompt --", "                            # we don't need /dev/tty", "                            need_tty=no", "                            ;;", "                        *)", "                            ;;", "                        esac", "                done", "                ;;", "        esac", "    done", "", "    if $_ansi_escapes_are_valid; then", "        printf \"\\33[1minfo:\\33[0m downloading installer\\n\" 1>&2", "    else", "        printf '%s\\n' 'info: downloading installer' 1>&2", "    fi", "", "    ensure mkdir -p \"$_dir\"", "    ensure downloader \"$_url\" \"$_file\" \"$_arch\"", "    ensure chmod u+x \"$_file\"", "    if [ ! -x \"$_file\" ]; then", "        printf '%s\\n' \"Cannot execute $_file (likely because of mounting /tmp as noexec).\" 1>&2", "        printf '%s\\n' \"Please copy the file to a location where you can execute binaries and run ./rustup-init${_ext}.\" 1>&2", "        exit 1", "    fi", "", "    if [ \"$need_tty\" = \"yes\" ] && [ ! -t 0 ]; then", "        # The installer is going to want to ask for confirmation by", "        # reading stdin.  This script was piped into `sh` though and", "        # doesn't have stdin to pass to its children. Instead we're going", "        # to explicitly connect /dev/tty to the installer's stdin.", "        if [ ! -t 1 ]; then", "            err \"Unable to run interactively. Run with -y to accept defaults, --help for additional options\"", "        fi", "", "        ignore \"$_file\" \"$@\" < /dev/tty", "    else", "        ignore \"$_file\" \"$@\"", "    fi", "", "    local _retval=$?", "", "    ignore rm \"$_file\"", "    ignore rmdir \"$_dir\"", "", "    return \"$_retval\"", "}", "", "check_proc() {", "    # Check for /proc by looking for the /proc/self/exe link", "    # This is only run on Linux", "    if ! test -L /proc/self/exe ; then", "        err \"fatal: Unable to find /proc/self/exe.  Is /proc mounted?  Installation cannot proceed without /proc.\"", "    fi", "}", "", "get_bitness() {", "    need_cmd head", "    # Architecture detection without dependencies beyond coreutils.", "    # ELF files start out \"\\x7fELF\", and the following byte is", "    #   0x01 for 32-bit and", "    #   0x02 for 64-bit.", "    # The printf builtin on some shells like dash only supports octal", "    # escape sequences, so we use those.", "    local _current_exe_head", "    _current_exe_head=$(head -c 5 /proc/self/exe )", "    if [ \"$_current_exe_head\" = \"$(printf '\\177ELF\\001')\" ]; then", "        echo 32", "    elif [ \"$_current_exe_head\" = \"$(printf '\\177ELF\\002')\" ]; then", "        echo 64", "    else", "        err \"unknown platform bitness\"", "    fi", "}", "", "is_host_amd64_elf() {", "    need_cmd head", "    need_cmd tail", "    # ELF e_machine detection without dependencies beyond coreutils.", "    # Two-byte field at offset 0x12 indicates the CPU,", "    # but we're interested in it being 0x3E to indicate amd64, or not that.", "    local _current_exe_machine", "    _current_exe_machine=$(head -c 19 /proc/self/exe | tail -c 1)", "    [ \"$_current_exe_machine\" = \"$(printf '\\076')\" ]", "}", "", "get_endianness() {", "    local cputype=$1", "    local suffix_eb=$2", "    local suffix_el=$3", "", "    # detect endianness without od/hexdump, like get_bitness() does.", "    need_cmd head", "    need_cmd tail", "", "    local _current_exe_endianness", "    _current_exe_endianness=\"$(head -c 6 /proc/self/exe | tail -c 1)\"", "    if [ \"$_current_exe_endianness\" = \"$(printf '\\001')\" ]; then", "        echo \"${cputype}${suffix_el}\"", "    elif [ \"$_current_exe_endianness\" = \"$(printf '\\002')\" ]; then", "        echo \"${cputype}${suffix_eb}\"", "    else", "        err \"unknown platform endianness\"", "    fi", "}", "", "get_architecture() {", "    local _ostype _cputype _bitness _arch _clibtype", "    _ostype=\"$(uname -s)\"", "    _cputype=\"$(uname -m)\"", "    _clibtype=\"gnu\"", "", "    if [ \"$_ostype\" = Linux ]; then", "        if [ \"$(uname -o)\" = Android ]; then", "            _ostype=Android", "        fi", "        if ldd --version 2>&1 | grep -q 'musl'; then", "            _clibtype=\"musl\"", "        fi", "    fi", "", "    if [ \"$_ostype\" = Darwin ] && [ \"$_cputype\" = i386 ]; then", "        # Darwin `uname -m` lies", "        if sysctl hw.optional.x86_64 | grep -q ': 1'; then", "            _cputype=x86_64", "        fi", "    fi", "", "    if [ \"$_ostype\" = SunOS ]; then", "        # Both Solaris and illumos presently announce as \"SunOS\" in \"uname -s\"", "        # so use \"uname -o\" to disambiguate.  We use the full path to the", "        # system uname in case the user has coreutils uname first in PATH,", "        # which has historically sometimes printed the wrong value here.", "        if [ \"$(/usr/bin/uname -o)\" = illumos ]; then", "            _ostype=illumos", "        fi", "", "        # illumos systems have multi-arch userlands, and \"uname -m\" reports the", "        # machine hardware name; e.g., \"i86pc\" on both 32- and 64-bit x86", "        # systems.  Check for the native (widest) instruction set on the", "        # running kernel:", "        if [ \"$_cputype\" = i86pc ]; then", "            _cputype=\"$(isainfo -n)\"", "        fi", "    fi", "", "    case \"$_ostype\" in", "", "        Android)", "            _ostype=linux-android", "            ;;", "", "        Linux)", "            check_proc", "            _ostype=unknown-linux-$_clibtype", "            _bitness=$(get_bitness)", "            ;;", "", "        FreeBSD)", "            _ostype=unknown-freebsd", "            ;;", "", "        NetBSD)", "            _ostype=unknown-netbsd", "            ;;", "", "        DragonFly)", "            _ostype=unknown-dragonfly", "            ;;", "", "        Darwin)", "            _ostype=apple-darwin", "            ;;", "", "        illumos)", "            _ostype=unknown-illumos", "            ;;", "", "        MINGW* | MSYS* | CYGWIN* | Windows_NT)", "            _ostype=pc-windows-gnu", "            ;;", "", "        *)", "            err \"unrecognized OS type: $_ostype\"", "            ;;", "", "    esac", "", "    case \"$_cputype\" in", "", "        i386 | i486 | i686 | i786 | x86)", "            _cputype=i686", "            ;;", "", "        xscale | arm)", "            _cputype=arm", "            if [ \"$_ostype\" = \"linux-android\" ]; then", "                _ostype=linux-androideabi", "            fi", "            ;;", "", "        armv6l)", "            _cputype=arm", "            if [ \"$_ostype\" = \"linux-android\" ]; then", "                _ostype=linux-androideabi", "            else", "                _ostype=\"${_ostype}eabihf\"", "            fi", "            ;;", "", "        armv7l | armv8l)", "            _cputype=armv7", "            if [ \"$_ostype\" = \"linux-android\" ]; then", "                _ostype=linux-androideabi", "            else", "                _ostype=\"${_ostype}eabihf\"", "            fi", "            ;;", "", "        aarch64 | arm64)", "            _cputype=aarch64", "            ;;", "", "        x86_64 | x86-64 | x64 | amd64)", "            _cputype=x86_64", "            ;;", "", "        mips)", "            _cputype=$(get_endianness mips '' el)", "            ;;", "", "        mips64)", "            if [ \"$_bitness\" -eq 64 ]; then", "                # only n64 ABI is supported for now", "                _ostype=\"${_ostype}abi64\"", "                _cputype=$(get_endianness mips64 '' el)", "            fi", "            ;;", "", "        ppc)", "            _cputype=powerpc", "            ;;", "", "        ppc64)", "            _cputype=powerpc64", "            ;;", "", "        ppc64le)", "            _cputype=powerpc64le", "            ;;", "", "        s390x)", "            _cputype=s390x", "            ;;", "        riscv64)", "            _cputype=riscv64gc", "            ;;", "        *)", "            err \"unknown CPU type: $_cputype\"", "", "    esac", "", "    # Detect 64-bit linux with 32-bit userland", "    if [ \"${_ostype}\" = unknown-linux-gnu ] && [ \"${_bitness}\" -eq 32 ]; then", "        case $_cputype in", "            x86_64)", "                if [ -n \"${RUSTUP_CPUTYPE:-}\" ]; then", "                    _cputype=\"$RUSTUP_CPUTYPE\"", "                else {", "                    # 32-bit executable for amd64 = x32", "                    if is_host_amd64_elf; then {", "                         echo \"This host is running an x32 userland; as it stands, x32 support is poor,\" 1>&2", "                         echo \"and there isn't a native toolchain -- you will have to install\" 1>&2", "                         echo \"multiarch compatibility with i686 and/or amd64, then select one\" 1>&2", "                         echo \"by re-running this script with the RUSTUP_CPUTYPE environment variable\" 1>&2", "                         echo \"set to i686 or x86_64, respectively.\" 1>&2", "                         echo 1>&2", "                         echo \"You will be able to add an x32 target after installation by running\" 1>&2", "                         echo \"  rustup target add x86_64-unknown-linux-gnux32\" 1>&2", "                         exit 1", "                    }; else", "                        _cputype=i686", "                    fi", "                }; fi", "                ;;", "            mips64)", "                _cputype=$(get_endianness mips '' el)", "                ;;", "            powerpc64)", "                _cputype=powerpc", "                ;;", "            aarch64)", "                _cputype=armv7", "                if [ \"$_ostype\" = \"linux-android\" ]; then", "                    _ostype=linux-androideabi", "                else", "                    _ostype=\"${_ostype}eabihf\"", "                fi", "                ;;", "            riscv64gc)", "                err \"riscv64 with 32-bit userland unsupported\"", "                ;;", "        esac", "    fi", "", "    # Detect armv7 but without the CPU features Rust needs in that build,", "    # and fall back to arm.", "    # See https://github.com/rust-lang/rustup.rs/issues/587.", "    if [ \"$_ostype\" = \"unknown-linux-gnueabihf\" ] && [ \"$_cputype\" = armv7 ]; then", "        if ensure grep '^Features' /proc/cpuinfo | grep -q -v neon; then", "            # At least one processor does not have NEON.", "            _cputype=arm", "        fi", "    fi", "", "    _arch=\"${_cputype}-${_ostype}\"", "", "    RETVAL=\"$_arch\"", "}", "", "say() {", "    printf 'rustup: %s\\n' \"$1\"", "}", "", "err() {", "    say \"$1\" >&2", "    exit 1", "}", "", "need_cmd() {", "    if ! check_cmd \"$1\"; then", "        err \"need '$1' (command not found)\"", "    fi", "}", "", "check_cmd() {", "    command -v \"$1\" > /dev/null 2>&1", "}", "", "assert_nz() {", "    if [ -z \"$1\" ]; then err \"assert_nz $2\"; fi", "}", "", "# Run a command that should never fail. If the command fails execution", "# will immediately terminate with an error showing the failing", "# command.", "ensure() {", "    if ! \"$@\"; then err \"command failed: $*\"; fi", "}", "", "# This is just for indicating that commands' results are being", "# intentionally ignored. Usually, because it's being executed", "# as part of error handling.", "ignore() {", "    \"$@\"", "}", "", "# This wraps curl or wget. Try curl first, if not installed,", "# use wget instead.", "downloader() {", "    local _dld", "    local _ciphersuites", "    local _err", "    local _status", "    local _retry", "    if check_cmd curl; then", "        _dld=curl", "    elif check_cmd wget; then", "        _dld=wget", "    else", "        _dld='curl or wget' # to be used in error message of need_cmd", "    fi", "", "    if [ \"$1\" = --check ]; then", "        need_cmd \"$_dld\"", "    elif [ \"$_dld\" = curl ]; then", "        check_curl_for_retry_support", "        _retry=\"$RETVAL\"", "        get_ciphersuites_for_curl", "        _ciphersuites=\"$RETVAL\"", "        if [ -n \"$_ciphersuites\" ]; then", "            _err=$(curl $_retry --proto '=https' --tlsv1.2 --ciphers \"$_ciphersuites\" --silent --show-error --fail --location \"$1\" --output \"$2\" 2>&1)", "            _status=$?", "        else", "            echo \"Warning: Not enforcing strong cipher suites for TLS, this is potentially less secure\"", "            if ! check_help_for \"$3\" curl --proto --tlsv1.2; then", "                echo \"Warning: Not enforcing TLS v1.2, this is potentially less secure\"", "                _err=$(curl $_retry --silent --show-error --fail --location \"$1\" --output \"$2\" 2>&1)", "                _status=$?", "            else", "                _err=$(curl $_retry --proto '=https' --tlsv1.2 --silent --show-error --fail --location \"$1\" --output \"$2\" 2>&1)", "                _status=$?", "            fi", "        fi", "        if [ -n \"$_err\" ]; then", "            echo \"$_err\" >&2", "            if echo \"$_err\" | grep -q 404$; then", "                err \"installer for platform '$3' not found, this may be unsupported\"", "            fi", "        fi", "        return $_status", "    elif [ \"$_dld\" = wget ]; then", "        if [ \"$(wget -V 2>&1|head -2|tail -1|cut -f1 -d\" \")\" = \"BusyBox\" ]; then", "            echo \"Warning: using the BusyBox version of wget.  Not enforcing strong cipher suites for TLS or TLS v1.2, this is potentially less secure\"", "            _err=$(wget \"$1\" -O \"$2\" 2>&1)", "            _status=$?", "        else", "            get_ciphersuites_for_wget", "            _ciphersuites=\"$RETVAL\"", "            if [ -n \"$_ciphersuites\" ]; then", "                _err=$(wget --https-only --secure-protocol=TLSv1_2 --ciphers \"$_ciphersuites\" \"$1\" -O \"$2\" 2>&1)", "                _status=$?", "            else", "                echo \"Warning: Not enforcing strong cipher suites for TLS, this is potentially less secure\"", "                if ! check_help_for \"$3\" wget --https-only --secure-protocol; then", "                    echo \"Warning: Not enforcing TLS v1.2, this is potentially less secure\"", "                    _err=$(wget \"$1\" -O \"$2\" 2>&1)", "                    _status=$?", "                else", "                    _err=$(wget --https-only --secure-protocol=TLSv1_2 \"$1\" -O \"$2\" 2>&1)", "                    _status=$?", "                fi", "            fi", "        fi", "        if [ -n \"$_err\" ]; then", "            echo \"$_err\" >&2", "            if echo \"$_err\" | grep -q ' 404 Not Found$'; then", "                err \"installer for platform '$3' not found, this may be unsupported\"", "            fi", "        fi", "        return $_status", "    else", "        err \"Unknown downloader\"   # should not reach here", "    fi", "}", "", "check_help_for() {", "    local _arch", "    local _cmd", "    local _arg", "    _arch=\"$1\"", "    shift", "    _cmd=\"$1\"", "    shift", "", "    local _category", "    if \"$_cmd\" --help | grep -q 'For all options use the manual or \"--help all\".'; then", "      _category=\"all\"", "    else", "      _category=\"\"", "    fi", "", "    case \"$_arch\" in", "", "        *darwin*)", "        if check_cmd sw_vers; then", "            case $(sw_vers -productVersion) in", "                10.*)", "                    # If we're running on macOS, older than 10.13, then we always", "                    # fail to find these options to force fallback", "                    if [ \"$(sw_vers -productVersion | cut -d. -f2)\" -lt 13 ]; then", "                        # Older than 10.13", "                        echo \"Warning: Detected macOS platform older than 10.13\"", "                        return 1", "                    fi", "                    ;;", "                11.*)", "                    # We assume Big Sur will be OK for now", "                    ;;", "                *)", "                    # Unknown product version, warn and continue", "                    echo \"Warning: Detected unknown macOS major version: $(sw_vers -productVersion)\"", "                    echo \"Warning TLS capabilities detection may fail\"", "                    ;;", "            esac", "        fi", "        ;;", "", "    esac", "", "    for _arg in \"$@\"; do", "        if ! \"$_cmd\" --help $_category | grep -q -- \"$_arg\"; then", "            return 1", "        fi", "    done", "", "    true # not strictly needed", "}", "", "# Check if curl supports the --retry flag, then pass it to the curl invocation.", "check_curl_for_retry_support() {", "  local _retry_supported=\"\"", "  # \"unspecified\" is for arch, allows for possibility old OS using macports, homebrew, etc.", "  if check_help_for \"notspecified\" \"curl\" \"--retry\"; then", "    _retry_supported=\"--retry 3\"", "  fi", "", "  RETVAL=\"$_retry_supported\"", "", "}", "", "# Return cipher suite string specified by user, otherwise return strong TLS 1.2-1.3 cipher suites", "# if support by local tools is detected. Detection currently supports these curl backends:", "# GnuTLS and OpenSSL (possibly also LibreSSL and BoringSSL). Return value can be empty.", "get_ciphersuites_for_curl() {", "    if [ -n \"${RUSTUP_TLS_CIPHERSUITES-}\" ]; then", "        # user specified custom cipher suites, assume they know what they're doing", "        RETVAL=\"$RUSTUP_TLS_CIPHERSUITES\"", "        return", "    fi", "", "    local _openssl_syntax=\"no\"", "    local _gnutls_syntax=\"no\"", "    local _backend_supported=\"yes\"", "    if curl -V | grep -q ' OpenSSL/'; then", "        _openssl_syntax=\"yes\"", "    elif curl -V | grep -iq ' LibreSSL/'; then", "        _openssl_syntax=\"yes\"", "    elif curl -V | grep -iq ' BoringSSL/'; then", "        _openssl_syntax=\"yes\"", "    elif curl -V | grep -iq ' GnuTLS/'; then", "        _gnutls_syntax=\"yes\"", "    else", "        _backend_supported=\"no\"", "    fi", "", "    local _args_supported=\"no\"", "    if [ \"$_backend_supported\" = \"yes\" ]; then", "        # \"unspecified\" is for arch, allows for possibility old OS using macports, homebrew, etc.", "        if check_help_for \"notspecified\" \"curl\" \"--tlsv1.2\" \"--ciphers\" \"--proto\"; then", "            _args_supported=\"yes\"", "        fi", "    fi", "", "    local _cs=\"\"", "    if [ \"$_args_supported\" = \"yes\" ]; then", "        if [ \"$_openssl_syntax\" = \"yes\" ]; then", "            _cs=$(get_strong_ciphersuites_for \"openssl\")", "        elif [ \"$_gnutls_syntax\" = \"yes\" ]; then", "            _cs=$(get_strong_ciphersuites_for \"gnutls\")", "        fi", "    fi", "", "    RETVAL=\"$_cs\"", "}", "", "# Return cipher suite string specified by user, otherwise return strong TLS 1.2-1.3 cipher suites", "# if support by local tools is detected. Detection currently supports these wget backends:", "# GnuTLS and OpenSSL (possibly also LibreSSL and BoringSSL). Return value can be empty.", "get_ciphersuites_for_wget() {", "    if [ -n \"${RUSTUP_TLS_CIPHERSUITES-}\" ]; then", "        # user specified custom cipher suites, assume they know what they're doing", "        RETVAL=\"$RUSTUP_TLS_CIPHERSUITES\"", "        return", "    fi", "", "    local _cs=\"\"", "    if wget -V | grep -q '\\-DHAVE_LIBSSL'; then", "        # \"unspecified\" is for arch, allows for possibility old OS using macports, homebrew, etc.", "        if check_help_for \"notspecified\" \"wget\" \"TLSv1_2\" \"--ciphers\" \"--https-only\" \"--secure-protocol\"; then", "            _cs=$(get_strong_ciphersuites_for \"openssl\")", "        fi", "    elif wget -V | grep -q '\\-DHAVE_LIBGNUTLS'; then", "        # \"unspecified\" is for arch, allows for possibility old OS using macports, homebrew, etc.", "        if check_help_for \"notspecified\" \"wget\" \"TLSv1_2\" \"--ciphers\" \"--https-only\" \"--secure-protocol\"; then", "            _cs=$(get_strong_ciphersuites_for \"gnutls\")", "        fi", "    fi", "", "    RETVAL=\"$_cs\"", "}", "", "# Return strong TLS 1.2-1.3 cipher suites in OpenSSL or GnuTLS syntax. TLS 1.2", "# excludes non-ECDHE and non-AEAD cipher suites. DHE is excluded due to bad", "# DH params often found on servers (see RFC 7919). Sequence matches or is", "# similar to Firefox 68 ESR with weak cipher suites disabled via about:config.", "# $1 must be openssl or gnutls.", "get_strong_ciphersuites_for() {", "    if [ \"$1\" = \"openssl\" ]; then", "        # OpenSSL is forgiving of unknown values, no problems with TLS 1.3 values on versions that don't support it yet.", "        echo \"TLS_AES_128_GCM_SHA256:TLS_CHACHA20_POLY1305_SHA256:TLS_AES_256_GCM_SHA384:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384\"", "    elif [ \"$1\" = \"gnutls\" ]; then", "        # GnuTLS isn't forgiving of unknown values, so this may require a GnuTLS version that supports TLS 1.3 even if wget doesn't.", "        # Begin with SECURE128 (and higher) then remove/add to build cipher suites. Produces same 9 cipher suites as OpenSSL but in slightly different order.", "        echo \"SECURE128:-VERS-SSL3.0:-VERS-TLS1.0:-VERS-TLS1.1:-VERS-DTLS-ALL:-CIPHER-ALL:-MAC-ALL:-KX-ALL:+AEAD:+ECDHE-ECDSA:+ECDHE-RSA:+AES-128-GCM:+CHACHA20-POLY1305:+AES-256-GCM\"", "    fi", "}", "", "main \"$@\" || exit 1", "curl: (6) Could not resolve host: |", "curl: (6) Could not resolve host: sh"]}
2022-12-30 00:08:04,178 p=89478 u=kal n=ansible | PLAY RECAP *******************************************************************************************************************************************
2022-12-30 00:08:04,179 p=89478 u=kal n=ansible | krpz                       : ok=3    changed=0    unreachable=0    failed=1    skipped=0    rescued=0    ignored=0   
2022-12-30 00:10:47,182 p=90283 u=kal n=ansible | Using /home/kal/MyApplications/dotfiles/playbooks/ansible.cfg as config file
2022-12-30 00:10:47,253 p=90283 u=kal n=ansible | PLAY [localhost] *************************************************************************************************************************************
2022-12-30 00:10:47,259 p=90283 u=kal n=ansible | TASK [Gathering Facts] *******************************************************************************************************************************
2022-12-30 00:10:51,193 p=90283 u=kal n=ansible | ok: [krpz]
2022-12-30 00:10:51,214 p=90283 u=kal n=ansible | TASK [install pexpect] *******************************************************************************************************************************
2022-12-30 00:10:51,646 p=90283 u=kal n=ansible | ok: [krpz] => {"changed": false, "cmd": ["/usr/bin/python2", "-m", "pip.__main__", "install", "pexpect"], "name": ["pexpect"], "requirements": null, "state": "present", "stderr": "DEPRECATION: Python 2.7 reached the end of its life on January 1st, 2020. Please upgrade your Python as Python 2.7 is no longer maintained. pip 21.0 will drop support for Python 2.7 in January 2021. More details about Python 2 support in pip can be found at https://pip.pypa.io/en/latest/development/release-process/#python-2-support pip 21.0 will remove support for this functionality.\n", "stderr_lines": ["DEPRECATION: Python 2.7 reached the end of its life on January 1st, 2020. Please upgrade your Python as Python 2.7 is no longer maintained. pip 21.0 will drop support for Python 2.7 in January 2021. More details about Python 2 support in pip can be found at https://pip.pypa.io/en/latest/development/release-process/#python-2-support pip 21.0 will remove support for this functionality."], "stdout": "Requirement already satisfied: pexpect in /usr/local/lib/python2.7/dist-packages (4.8.0)\nRequirement already satisfied: ptyprocess>=0.5 in /usr/local/lib/python2.7/dist-packages (from pexpect) (0.7.0)\n", "stdout_lines": ["Requirement already satisfied: pexpect in /usr/local/lib/python2.7/dist-packages (4.8.0)", "Requirement already satisfied: ptyprocess>=0.5 in /usr/local/lib/python2.7/dist-packages (from pexpect) (0.7.0)"], "version": null, "virtualenv": null}
2022-12-30 00:10:51,654 p=90283 u=kal n=ansible | TASK [install setuptools] ****************************************************************************************************************************
2022-12-30 00:10:51,997 p=90283 u=kal n=ansible | ok: [krpz] => {"changed": false, "cmd": ["/usr/bin/python2", "-m", "pip.__main__", "install", "setuptools"], "name": ["setuptools"], "requirements": null, "state": "present", "stderr": "DEPRECATION: Python 2.7 reached the end of its life on January 1st, 2020. Please upgrade your Python as Python 2.7 is no longer maintained. pip 21.0 will drop support for Python 2.7 in January 2021. More details about Python 2 support in pip can be found at https://pip.pypa.io/en/latest/development/release-process/#python-2-support pip 21.0 will remove support for this functionality.\n", "stderr_lines": ["DEPRECATION: Python 2.7 reached the end of its life on January 1st, 2020. Please upgrade your Python as Python 2.7 is no longer maintained. pip 21.0 will drop support for Python 2.7 in January 2021. More details about Python 2 support in pip can be found at https://pip.pypa.io/en/latest/development/release-process/#python-2-support pip 21.0 will remove support for this functionality."], "stdout": "Requirement already satisfied: setuptools in /usr/lib/python2.7/dist-packages (44.1.1)\n", "stdout_lines": ["Requirement already satisfied: setuptools in /usr/lib/python2.7/dist-packages (44.1.1)"], "version": null, "virtualenv": null}
2022-12-30 00:10:52,005 p=90283 u=kal n=ansible | TASK [Install Rust] **********************************************************************************************************************************
2022-12-30 00:10:53,137 p=90283 u=kal n=ansible | fatal: [krpz]: FAILED! => {"changed": true, "cmd": "curl https://sh.rustup.rs | sh", "delta": "0:00:00.898929", "end": "2022-12-30 00:10:53.063171", "msg": "non-zero return code", "rc": 6, "start": "2022-12-30 00:10:52.164242", "stdout": "#!/bin/sh\r\n# shellcheck shell=dash\r\n\r\n# This is just a little script that can be downloaded from the internet to\r\n# install rustup. It just does platform detection, downloads the installer\r\n# and runs it.\r\n\r\n# It runs on Unix shells like {a,ba,da,k,z}sh. It uses the common `local`\r\n# extension. Note: Most shells limit `local` to 1 var per line, contra bash.\r\n\r\nif [ \"$KSH_VERSION\" = 'Version JM 93t+ 2010-03-05' ]; then\r\n    # The version of ksh93 that ships with many illumos systems does not\r\n    # support the \"local\" extension.  Print a message rather than fail in\r\n    # subtle ways later on:\r\n    echo 'rustup does not work with this ksh93 version; please try bash!' >&2\r\n    exit 1\r\nfi\r\n\r\n\r\nset -u\r\n\r\n# If RUSTUP_UPDATE_ROOT is unset or empty, default it.\r\nRUSTUP_UPDATE_ROOT=\"${RUSTUP_UPDATE_ROOT:-https://static.rust-lang.org/rustup}\"\r\n\r\n#XXX: If you change anything here, please make the same changes in setup_mode.rs\r\nusage() {\r\n    cat 1>&2 <<EOF\r\nrustup-init 1.25.1 (48d233f65 2022-07-12)\r\nThe installer for rustup\r\n\r\nUSAGE:\r\n    rustup-init [FLAGS] [OPTIONS]\r\n\r\nFLAGS:\r\n    -v, --verbose           Enable verbose output\r\n    -q, --quiet             Disable progress output\r\n    -y                      Disable confirmation prompt.\r\n        --no-modify-path    Don't configure the PATH environment variable\r\n    -h, --help              Prints help information\r\n    -V, --version           Prints version information\r\n\r\nOPTIONS:\r\n        --default-host <default-host>              Choose a default host triple\r\n        --default-toolchain <default-toolchain>    Choose a default toolchain to install\r\n        --default-toolchain none                   Do not install any toolchains\r\n        --profile [minimal|default|complete]       Choose a profile\r\n    -c, --component <components>...                Component name to also install\r\n    -t, --target <targets>...                      Target name to also install\r\nEOF\r\n}\r\n\r\nmain() {\r\n    downloader --check\r\n    need_cmd uname\r\n    need_cmd mktemp\r\n    need_cmd chmod\r\n    need_cmd mkdir\r\n    need_cmd rm\r\n    need_cmd rmdir\r\n\r\n    get_architecture || return 1\r\n    local _arch=\"$RETVAL\"\r\n    assert_nz \"$_arch\" \"arch\"\r\n\r\n    local _ext=\"\"\r\n    case \"$_arch\" in\r\n        *windows*)\r\n            _ext=\".exe\"\r\n            ;;\r\n    esac\r\n\r\n    local _url=\"${RUSTUP_UPDATE_ROOT}/dist/${_arch}/rustup-init${_ext}\"\r\n\r\n    local _dir\r\n    _dir=\"$(ensure mktemp -d)\"\r\n    local _file=\"${_dir}/rustup-init${_ext}\"\r\n\r\n    local _ansi_escapes_are_valid=false\r\n    if [ -t 2 ]; then\r\n        if [ \"${TERM+set}\" = 'set' ]; then\r\n            case \"$TERM\" in\r\n                xterm*|rxvt*|urxvt*|linux*|vt*)\r\n                    _ansi_escapes_are_valid=true\r\n                ;;\r\n            esac\r\n        fi\r\n    fi\r\n\r\n    # check if we have to use /dev/tty to prompt the user\r\n    local need_tty=yes\r\n    for arg in \"$@\"; do\r\n        case \"$arg\" in\r\n            --help)\r\n                usage\r\n                exit 0\r\n                ;;\r\n            *)\r\n                OPTIND=1\r\n                if [ \"${arg%%--*}\" = \"\" ]; then\r\n                    # Long option (other than --help);\r\n                    # don't attempt to interpret it.\r\n                    continue\r\n                fi\r\n                while getopts :hy sub_arg \"$arg\"; do\r\n                    case \"$sub_arg\" in\r\n                        h)\r\n                            usage\r\n                            exit 0\r\n                            ;;\r\n                        y)\r\n                            # user wants to skip the prompt --\r\n                            # we don't need /dev/tty\r\n                            need_tty=no\r\n                            ;;\r\n                        *)\r\n                            ;;\r\n                        esac\r\n                done\r\n                ;;\r\n        esac\r\n    done\r\n\r\n    if $_ansi_escapes_are_valid; then\r\n        printf \"\\33[1minfo:\\33[0m downloading installer\\n\" 1>&2\r\n    else\r\n        printf '%s\\n' 'info: downloading installer' 1>&2\r\n    fi\r\n\r\n    ensure mkdir -p \"$_dir\"\r\n    ensure downloader \"$_url\" \"$_file\" \"$_arch\"\r\n    ensure chmod u+x \"$_file\"\r\n    if [ ! -x \"$_file\" ]; then\r\n        printf '%s\\n' \"Cannot execute $_file (likely because of mounting /tmp as noexec).\" 1>&2\r\n        printf '%s\\n' \"Please copy the file to a location where you can execute binaries and run ./rustup-init${_ext}.\" 1>&2\r\n        exit 1\r\n    fi\r\n\r\n    if [ \"$need_tty\" = \"yes\" ] && [ ! -t 0 ]; then\r\n        # The installer is going to want to ask for confirmation by\r\n        # reading stdin.  This script was piped into `sh` though and\r\n        # doesn't have stdin to pass to its children. Instead we're going\r\n        # to explicitly connect /dev/tty to the installer's stdin.\r\n        if [ ! -t 1 ]; then\r\n            err \"Unable to run interactively. Run with -y to accept defaults, --help for additional options\"\r\n        fi\r\n\r\n        ignore \"$_file\" \"$@\" < /dev/tty\r\n    else\r\n        ignore \"$_file\" \"$@\"\r\n    fi\r\n\r\n    local _retval=$?\r\n\r\n    ignore rm \"$_file\"\r\n    ignore rmdir \"$_dir\"\r\n\r\n    return \"$_retval\"\r\n}\r\n\r\ncheck_proc() {\r\n    # Check for /proc by looking for the /proc/self/exe link\r\n    # This is only run on Linux\r\n    if ! test -L /proc/self/exe ; then\r\n        err \"fatal: Unable to find /proc/self/exe.  Is /proc mounted?  Installation cannot proceed without /proc.\"\r\n    fi\r\n}\r\n\r\nget_bitness() {\r\n    need_cmd head\r\n    # Architecture detection without dependencies beyond coreutils.\r\n    # ELF files start out \"\\x7fELF\", and the following byte is\r\n    #   0x01 for 32-bit and\r\n    #   0x02 for 64-bit.\r\n    # The printf builtin on some shells like dash only supports octal\r\n    # escape sequences, so we use those.\r\n    local _current_exe_head\r\n    _current_exe_head=$(head -c 5 /proc/self/exe )\r\n    if [ \"$_current_exe_head\" = \"$(printf '\\177ELF\\001')\" ]; then\r\n        echo 32\r\n    elif [ \"$_current_exe_head\" = \"$(printf '\\177ELF\\002')\" ]; then\r\n        echo 64\r\n    else\r\n        err \"unknown platform bitness\"\r\n    fi\r\n}\r\n\r\nis_host_amd64_elf() {\r\n    need_cmd head\r\n    need_cmd tail\r\n    # ELF e_machine detection without dependencies beyond coreutils.\r\n    # Two-byte field at offset 0x12 indicates the CPU,\r\n    # but we're interested in it being 0x3E to indicate amd64, or not that.\r\n    local _current_exe_machine\r\n    _current_exe_machine=$(head -c 19 /proc/self/exe | tail -c 1)\r\n    [ \"$_current_exe_machine\" = \"$(printf '\\076')\" ]\r\n}\r\n\r\nget_endianness() {\r\n    local cputype=$1\r\n    local suffix_eb=$2\r\n    local suffix_el=$3\r\n\r\n    # detect endianness without od/hexdump, like get_bitness() does.\r\n    need_cmd head\r\n    need_cmd tail\r\n\r\n    local _current_exe_endianness\r\n    _current_exe_endianness=\"$(head -c 6 /proc/self/exe | tail -c 1)\"\r\n    if [ \"$_current_exe_endianness\" = \"$(printf '\\001')\" ]; then\r\n        echo \"${cputype}${suffix_el}\"\r\n    elif [ \"$_current_exe_endianness\" = \"$(printf '\\002')\" ]; then\r\n        echo \"${cputype}${suffix_eb}\"\r\n    else\r\n        err \"unknown platform endianness\"\r\n    fi\r\n}\r\n\r\nget_architecture() {\r\n    local _ostype _cputype _bitness _arch _clibtype\r\n    _ostype=\"$(uname -s)\"\r\n    _cputype=\"$(uname -m)\"\r\n    _clibtype=\"gnu\"\r\n\r\n    if [ \"$_ostype\" = Linux ]; then\r\n        if [ \"$(uname -o)\" = Android ]; then\r\n            _ostype=Android\r\n        fi\r\n        if ldd --version 2>&1 | grep -q 'musl'; then\r\n            _clibtype=\"musl\"\r\n        fi\r\n    fi\r\n\r\n    if [ \"$_ostype\" = Darwin ] && [ \"$_cputype\" = i386 ]; then\r\n        # Darwin `uname -m` lies\r\n        if sysctl hw.optional.x86_64 | grep -q ': 1'; then\r\n            _cputype=x86_64\r\n        fi\r\n    fi\r\n\r\n    if [ \"$_ostype\" = SunOS ]; then\r\n        # Both Solaris and illumos presently announce as \"SunOS\" in \"uname -s\"\r\n        # so use \"uname -o\" to disambiguate.  We use the full path to the\r\n        # system uname in case the user has coreutils uname first in PATH,\r\n        # which has historically sometimes printed the wrong value here.\r\n        if [ \"$(/usr/bin/uname -o)\" = illumos ]; then\r\n            _ostype=illumos\r\n        fi\r\n\r\n        # illumos systems have multi-arch userlands, and \"uname -m\" reports the\r\n        # machine hardware name; e.g., \"i86pc\" on both 32- and 64-bit x86\r\n        # systems.  Check for the native (widest) instruction set on the\r\n        # running kernel:\r\n        if [ \"$_cputype\" = i86pc ]; then\r\n            _cputype=\"$(isainfo -n)\"\r\n        fi\r\n    fi\r\n\r\n    case \"$_ostype\" in\r\n\r\n        Android)\r\n            _ostype=linux-android\r\n            ;;\r\n\r\n        Linux)\r\n            check_proc\r\n            _ostype=unknown-linux-$_clibtype\r\n            _bitness=$(get_bitness)\r\n            ;;\r\n\r\n        FreeBSD)\r\n            _ostype=unknown-freebsd\r\n            ;;\r\n\r\n        NetBSD)\r\n            _ostype=unknown-netbsd\r\n            ;;\r\n\r\n        DragonFly)\r\n            _ostype=unknown-dragonfly\r\n            ;;\r\n\r\n        Darwin)\r\n            _ostype=apple-darwin\r\n            ;;\r\n\r\n        illumos)\r\n            _ostype=unknown-illumos\r\n            ;;\r\n\r\n        MINGW* | MSYS* | CYGWIN* | Windows_NT)\r\n            _ostype=pc-windows-gnu\r\n            ;;\r\n\r\n        *)\r\n            err \"unrecognized OS type: $_ostype\"\r\n            ;;\r\n\r\n    esac\r\n\r\n    case \"$_cputype\" in\r\n\r\n        i386 | i486 | i686 | i786 | x86)\r\n            _cputype=i686\r\n            ;;\r\n\r\n        xscale | arm)\r\n            _cputype=arm\r\n            if [ \"$_ostype\" = \"linux-android\" ]; then\r\n                _ostype=linux-androideabi\r\n            fi\r\n            ;;\r\n\r\n        armv6l)\r\n            _cputype=arm\r\n            if [ \"$_ostype\" = \"linux-android\" ]; then\r\n                _ostype=linux-androideabi\r\n            else\r\n                _ostype=\"${_ostype}eabihf\"\r\n            fi\r\n            ;;\r\n\r\n        armv7l | armv8l)\r\n            _cputype=armv7\r\n            if [ \"$_ostype\" = \"linux-android\" ]; then\r\n                _ostype=linux-androideabi\r\n            else\r\n                _ostype=\"${_ostype}eabihf\"\r\n            fi\r\n            ;;\r\n\r\n        aarch64 | arm64)\r\n            _cputype=aarch64\r\n            ;;\r\n\r\n        x86_64 | x86-64 | x64 | amd64)\r\n            _cputype=x86_64\r\n            ;;\r\n\r\n        mips)\r\n            _cputype=$(get_endianness mips '' el)\r\n            ;;\r\n\r\n        mips64)\r\n            if [ \"$_bitness\" -eq 64 ]; then\r\n                # only n64 ABI is supported for now\r\n                _ostype=\"${_ostype}abi64\"\r\n                _cputype=$(get_endianness mips64 '' el)\r\n            fi\r\n            ;;\r\n\r\n        ppc)\r\n            _cputype=powerpc\r\n            ;;\r\n\r\n        ppc64)\r\n            _cputype=powerpc64\r\n            ;;\r\n\r\n        ppc64le)\r\n            _cputype=powerpc64le\r\n            ;;\r\n\r\n        s390x)\r\n            _cputype=s390x\r\n            ;;\r\n        riscv64)\r\n            _cputype=riscv64gc\r\n            ;;\r\n        *)\r\n            err \"unknown CPU type: $_cputype\"\r\n\r\n    esac\r\n\r\n    # Detect 64-bit linux with 32-bit userland\r\n    if [ \"${_ostype}\" = unknown-linux-gnu ] && [ \"${_bitness}\" -eq 32 ]; then\r\n        case $_cputype in\r\n            x86_64)\r\n                if [ -n \"${RUSTUP_CPUTYPE:-}\" ]; then\r\n                    _cputype=\"$RUSTUP_CPUTYPE\"\r\n                else {\r\n                    # 32-bit executable for amd64 = x32\r\n                    if is_host_amd64_elf; then {\r\n                         echo \"This host is running an x32 userland; as it stands, x32 support is poor,\" 1>&2\r\n                         echo \"and there isn't a native toolchain -- you will have to install\" 1>&2\r\n                         echo \"multiarch compatibility with i686 and/or amd64, then select one\" 1>&2\r\n                         echo \"by re-running this script with the RUSTUP_CPUTYPE environment variable\" 1>&2\r\n                         echo \"set to i686 or x86_64, respectively.\" 1>&2\r\n                         echo 1>&2\r\n                         echo \"You will be able to add an x32 target after installation by running\" 1>&2\r\n                         echo \"  rustup target add x86_64-unknown-linux-gnux32\" 1>&2\r\n                         exit 1\r\n                    }; else\r\n                        _cputype=i686\r\n                    fi\r\n                }; fi\r\n                ;;\r\n            mips64)\r\n                _cputype=$(get_endianness mips '' el)\r\n                ;;\r\n            powerpc64)\r\n                _cputype=powerpc\r\n                ;;\r\n            aarch64)\r\n                _cputype=armv7\r\n                if [ \"$_ostype\" = \"linux-android\" ]; then\r\n                    _ostype=linux-androideabi\r\n                else\r\n                    _ostype=\"${_ostype}eabihf\"\r\n                fi\r\n                ;;\r\n            riscv64gc)\r\n                err \"riscv64 with 32-bit userland unsupported\"\r\n                ;;\r\n        esac\r\n    fi\r\n\r\n    # Detect armv7 but without the CPU features Rust needs in that build,\r\n    # and fall back to arm.\r\n    # See https://github.com/rust-lang/rustup.rs/issues/587.\r\n    if [ \"$_ostype\" = \"unknown-linux-gnueabihf\" ] && [ \"$_cputype\" = armv7 ]; then\r\n        if ensure grep '^Features' /proc/cpuinfo | grep -q -v neon; then\r\n            # At least one processor does not have NEON.\r\n            _cputype=arm\r\n        fi\r\n    fi\r\n\r\n    _arch=\"${_cputype}-${_ostype}\"\r\n\r\n    RETVAL=\"$_arch\"\r\n}\r\n\r\nsay() {\r\n    printf 'rustup: %s\\n' \"$1\"\r\n}\r\n\r\nerr() {\r\n    say \"$1\" >&2\r\n    exit 1\r\n}\r\n\r\nneed_cmd() {\r\n    if ! check_cmd \"$1\"; then\r\n        err \"need '$1' (command not found)\"\r\n    fi\r\n}\r\n\r\ncheck_cmd() {\r\n    command -v \"$1\" > /dev/null 2>&1\r\n}\r\n\r\nassert_nz() {\r\n    if [ -z \"$1\" ]; then err \"assert_nz $2\"; fi\r\n}\r\n\r\n# Run a command that should never fail. If the command fails execution\r\n# will immediately terminate with an error showing the failing\r\n# command.\r\nensure() {\r\n    if ! \"$@\"; then err \"command failed: $*\"; fi\r\n}\r\n\r\n# This is just for indicating that commands' results are being\r\n# intentionally ignored. Usually, because it's being executed\r\n# as part of error handling.\r\nignore() {\r\n    \"$@\"\r\n}\r\n\r\n# This wraps curl or wget. Try curl first, if not installed,\r\n# use wget instead.\r\ndownloader() {\r\n    local _dld\r\n    local _ciphersuites\r\n    local _err\r\n    local _status\r\n    local _retry\r\n    if check_cmd curl; then\r\n        _dld=curl\r\n    elif check_cmd wget; then\r\n        _dld=wget\r\n    else\r\n        _dld='curl or wget' # to be used in error message of need_cmd\r\n    fi\r\n\r\n    if [ \"$1\" = --check ]; then\r\n        need_cmd \"$_dld\"\r\n    elif [ \"$_dld\" = curl ]; then\r\n        check_curl_for_retry_support\r\n        _retry=\"$RETVAL\"\r\n        get_ciphersuites_for_curl\r\n        _ciphersuites=\"$RETVAL\"\r\n        if [ -n \"$_ciphersuites\" ]; then\r\n            _err=$(curl $_retry --proto '=https' --tlsv1.2 --ciphers \"$_ciphersuites\" --silent --show-error --fail --location \"$1\" --output \"$2\" 2>&1)\r\n            _status=$?\r\n        else\r\n            echo \"Warning: Not enforcing strong cipher suites for TLS, this is potentially less secure\"\r\n            if ! check_help_for \"$3\" curl --proto --tlsv1.2; then\r\n                echo \"Warning: Not enforcing TLS v1.2, this is potentially less secure\"\r\n                _err=$(curl $_retry --silent --show-error --fail --location \"$1\" --output \"$2\" 2>&1)\r\n                _status=$?\r\n            else\r\n                _err=$(curl $_retry --proto '=https' --tlsv1.2 --silent --show-error --fail --location \"$1\" --output \"$2\" 2>&1)\r\n                _status=$?\r\n            fi\r\n        fi\r\n        if [ -n \"$_err\" ]; then\r\n            echo \"$_err\" >&2\r\n            if echo \"$_err\" | grep -q 404$; then\r\n                err \"installer for platform '$3' not found, this may be unsupported\"\r\n            fi\r\n        fi\r\n        return $_status\r\n    elif [ \"$_dld\" = wget ]; then\r\n        if [ \"$(wget -V 2>&1|head -2|tail -1|cut -f1 -d\" \")\" = \"BusyBox\" ]; then\r\n            echo \"Warning: using the BusyBox version of wget.  Not enforcing strong cipher suites for TLS or TLS v1.2, this is potentially less secure\"\r\n            _err=$(wget \"$1\" -O \"$2\" 2>&1)\r\n            _status=$?\r\n        else\r\n            get_ciphersuites_for_wget\r\n            _ciphersuites=\"$RETVAL\"\r\n            if [ -n \"$_ciphersuites\" ]; then\r\n                _err=$(wget --https-only --secure-protocol=TLSv1_2 --ciphers \"$_ciphersuites\" \"$1\" -O \"$2\" 2>&1)\r\n                _status=$?\r\n            else\r\n                echo \"Warning: Not enforcing strong cipher suites for TLS, this is potentially less secure\"\r\n                if ! check_help_for \"$3\" wget --https-only --secure-protocol; then\r\n                    echo \"Warning: Not enforcing TLS v1.2, this is potentially less secure\"\r\n                    _err=$(wget \"$1\" -O \"$2\" 2>&1)\r\n                    _status=$?\r\n                else\r\n                    _err=$(wget --https-only --secure-protocol=TLSv1_2 \"$1\" -O \"$2\" 2>&1)\r\n                    _status=$?\r\n                fi\r\n            fi\r\n        fi\r\n        if [ -n \"$_err\" ]; then\r\n            echo \"$_err\" >&2\r\n            if echo \"$_err\" | grep -q ' 404 Not Found$'; then\r\n                err \"installer for platform '$3' not found, this may be unsupported\"\r\n            fi\r\n        fi\r\n        return $_status\r\n    else\r\n        err \"Unknown downloader\"   # should not reach here\r\n    fi\r\n}\r\n\r\ncheck_help_for() {\r\n    local _arch\r\n    local _cmd\r\n    local _arg\r\n    _arch=\"$1\"\r\n    shift\r\n    _cmd=\"$1\"\r\n    shift\r\n\r\n    local _category\r\n    if \"$_cmd\" --help | grep -q 'For all options use the manual or \"--help all\".'; then\r\n      _category=\"all\"\r\n    else\r\n      _category=\"\"\r\n    fi\r\n\r\n    case \"$_arch\" in\r\n\r\n        *darwin*)\r\n        if check_cmd sw_vers; then\r\n            case $(sw_vers -productVersion) in\r\n                10.*)\r\n                    # If we're running on macOS, older than 10.13, then we always\r\n                    # fail to find these options to force fallback\r\n                    if [ \"$(sw_vers -productVersion | cut -d. -f2)\" -lt 13 ]; then\r\n                        # Older than 10.13\r\n                        echo \"Warning: Detected macOS platform older than 10.13\"\r\n                        return 1\r\n                    fi\r\n                    ;;\r\n                11.*)\r\n                    # We assume Big Sur will be OK for now\r\n                    ;;\r\n                *)\r\n                    # Unknown product version, warn and continue\r\n                    echo \"Warning: Detected unknown macOS major version: $(sw_vers -productVersion)\"\r\n                    echo \"Warning TLS capabilities detection may fail\"\r\n                    ;;\r\n            esac\r\n        fi\r\n        ;;\r\n\r\n    esac\r\n\r\n    for _arg in \"$@\"; do\r\n        if ! \"$_cmd\" --help $_category | grep -q -- \"$_arg\"; then\r\n            return 1\r\n        fi\r\n    done\r\n\r\n    true # not strictly needed\r\n}\r\n\r\n# Check if curl supports the --retry flag, then pass it to the curl invocation.\r\ncheck_curl_for_retry_support() {\r\n  local _retry_supported=\"\"\r\n  # \"unspecified\" is for arch, allows for possibility old OS using macports, homebrew, etc.\r\n  if check_help_for \"notspecified\" \"curl\" \"--retry\"; then\r\n    _retry_supported=\"--retry 3\"\r\n  fi\r\n\r\n  RETVAL=\"$_retry_supported\"\r\n\r\n}\r\n\r\n# Return cipher suite string specified by user, otherwise return strong TLS 1.2-1.3 cipher suites\r\n# if support by local tools is detected. Detection currently supports these curl backends:\r\n# GnuTLS and OpenSSL (possibly also LibreSSL and BoringSSL). Return value can be empty.\r\nget_ciphersuites_for_curl() {\r\n    if [ -n \"${RUSTUP_TLS_CIPHERSUITES-}\" ]; then\r\n        # user specified custom cipher suites, assume they know what they're doing\r\n        RETVAL=\"$RUSTUP_TLS_CIPHERSUITES\"\r\n        return\r\n    fi\r\n\r\n    local _openssl_syntax=\"no\"\r\n    local _gnutls_syntax=\"no\"\r\n    local _backend_supported=\"yes\"\r\n    if curl -V | grep -q ' OpenSSL/'; then\r\n        _openssl_syntax=\"yes\"\r\n    elif curl -V | grep -iq ' LibreSSL/'; then\r\n        _openssl_syntax=\"yes\"\r\n    elif curl -V | grep -iq ' BoringSSL/'; then\r\n        _openssl_syntax=\"yes\"\r\n    elif curl -V | grep -iq ' GnuTLS/'; then\r\n        _gnutls_syntax=\"yes\"\r\n    else\r\n        _backend_supported=\"no\"\r\n    fi\r\n\r\n    local _args_supported=\"no\"\r\n    if [ \"$_backend_supported\" = \"yes\" ]; then\r\n        # \"unspecified\" is for arch, allows for possibility old OS using macports, homebrew, etc.\r\n        if check_help_for \"notspecified\" \"curl\" \"--tlsv1.2\" \"--ciphers\" \"--proto\"; then\r\n            _args_supported=\"yes\"\r\n        fi\r\n    fi\r\n\r\n    local _cs=\"\"\r\n    if [ \"$_args_supported\" = \"yes\" ]; then\r\n        if [ \"$_openssl_syntax\" = \"yes\" ]; then\r\n            _cs=$(get_strong_ciphersuites_for \"openssl\")\r\n        elif [ \"$_gnutls_syntax\" = \"yes\" ]; then\r\n            _cs=$(get_strong_ciphersuites_for \"gnutls\")\r\n        fi\r\n    fi\r\n\r\n    RETVAL=\"$_cs\"\r\n}\r\n\r\n# Return cipher suite string specified by user, otherwise return strong TLS 1.2-1.3 cipher suites\r\n# if support by local tools is detected. Detection currently supports these wget backends:\r\n# GnuTLS and OpenSSL (possibly also LibreSSL and BoringSSL). Return value can be empty.\r\nget_ciphersuites_for_wget() {\r\n    if [ -n \"${RUSTUP_TLS_CIPHERSUITES-}\" ]; then\r\n        # user specified custom cipher suites, assume they know what they're doing\r\n        RETVAL=\"$RUSTUP_TLS_CIPHERSUITES\"\r\n        return\r\n    fi\r\n\r\n    local _cs=\"\"\r\n    if wget -V | grep -q '\\-DHAVE_LIBSSL'; then\r\n        # \"unspecified\" is for arch, allows for possibility old OS using macports, homebrew, etc.\r\n        if check_help_for \"notspecified\" \"wget\" \"TLSv1_2\" \"--ciphers\" \"--https-only\" \"--secure-protocol\"; then\r\n            _cs=$(get_strong_ciphersuites_for \"openssl\")\r\n        fi\r\n    elif wget -V | grep -q '\\-DHAVE_LIBGNUTLS'; then\r\n        # \"unspecified\" is for arch, allows for possibility old OS using macports, homebrew, etc.\r\n        if check_help_for \"notspecified\" \"wget\" \"TLSv1_2\" \"--ciphers\" \"--https-only\" \"--secure-protocol\"; then\r\n            _cs=$(get_strong_ciphersuites_for \"gnutls\")\r\n        fi\r\n    fi\r\n\r\n    RETVAL=\"$_cs\"\r\n}\r\n\r\n# Return strong TLS 1.2-1.3 cipher suites in OpenSSL or GnuTLS syntax. TLS 1.2\r\n# excludes non-ECDHE and non-AEAD cipher suites. DHE is excluded due to bad\r\n# DH params often found on servers (see RFC 7919). Sequence matches or is\r\n# similar to Firefox 68 ESR with weak cipher suites disabled via about:config.\r\n# $1 must be openssl or gnutls.\r\nget_strong_ciphersuites_for() {\r\n    if [ \"$1\" = \"openssl\" ]; then\r\n        # OpenSSL is forgiving of unknown values, no problems with TLS 1.3 values on versions that don't support it yet.\r\n        echo \"TLS_AES_128_GCM_SHA256:TLS_CHACHA20_POLY1305_SHA256:TLS_AES_256_GCM_SHA384:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384\"\r\n    elif [ \"$1\" = \"gnutls\" ]; then\r\n        # GnuTLS isn't forgiving of unknown values, so this may require a GnuTLS version that supports TLS 1.3 even if wget doesn't.\r\n        # Begin with SECURE128 (and higher) then remove/add to build cipher suites. Produces same 9 cipher suites as OpenSSL but in slightly different order.\r\n        echo \"SECURE128:-VERS-SSL3.0:-VERS-TLS1.0:-VERS-TLS1.1:-VERS-DTLS-ALL:-CIPHER-ALL:-MAC-ALL:-KX-ALL:+AEAD:+ECDHE-ECDSA:+ECDHE-RSA:+AES-128-GCM:+CHACHA20-POLY1305:+AES-256-GCM\"\r\n    fi\r\n}\r\n\r\nmain \"$@\" || exit 1\r\ncurl: (6) Could not resolve host: |\r\ncurl: (6) Could not resolve host: sh", "stdout_lines": ["#!/bin/sh", "# shellcheck shell=dash", "", "# This is just a little script that can be downloaded from the internet to", "# install rustup. It just does platform detection, downloads the installer", "# and runs it.", "", "# It runs on Unix shells like {a,ba,da,k,z}sh. It uses the common `local`", "# extension. Note: Most shells limit `local` to 1 var per line, contra bash.", "", "if [ \"$KSH_VERSION\" = 'Version JM 93t+ 2010-03-05' ]; then", "    # The version of ksh93 that ships with many illumos systems does not", "    # support the \"local\" extension.  Print a message rather than fail in", "    # subtle ways later on:", "    echo 'rustup does not work with this ksh93 version; please try bash!' >&2", "    exit 1", "fi", "", "", "set -u", "", "# If RUSTUP_UPDATE_ROOT is unset or empty, default it.", "RUSTUP_UPDATE_ROOT=\"${RUSTUP_UPDATE_ROOT:-https://static.rust-lang.org/rustup}\"", "", "#XXX: If you change anything here, please make the same changes in setup_mode.rs", "usage() {", "    cat 1>&2 <<EOF", "rustup-init 1.25.1 (48d233f65 2022-07-12)", "The installer for rustup", "", "USAGE:", "    rustup-init [FLAGS] [OPTIONS]", "", "FLAGS:", "    -v, --verbose           Enable verbose output", "    -q, --quiet             Disable progress output", "    -y                      Disable confirmation prompt.", "        --no-modify-path    Don't configure the PATH environment variable", "    -h, --help              Prints help information", "    -V, --version           Prints version information", "", "OPTIONS:", "        --default-host <default-host>              Choose a default host triple", "        --default-toolchain <default-toolchain>    Choose a default toolchain to install", "        --default-toolchain none                   Do not install any toolchains", "        --profile [minimal|default|complete]       Choose a profile", "    -c, --component <components>...                Component name to also install", "    -t, --target <targets>...                      Target name to also install", "EOF", "}", "", "main() {", "    downloader --check", "    need_cmd uname", "    need_cmd mktemp", "    need_cmd chmod", "    need_cmd mkdir", "    need_cmd rm", "    need_cmd rmdir", "", "    get_architecture || return 1", "    local _arch=\"$RETVAL\"", "    assert_nz \"$_arch\" \"arch\"", "", "    local _ext=\"\"", "    case \"$_arch\" in", "        *windows*)", "            _ext=\".exe\"", "            ;;", "    esac", "", "    local _url=\"${RUSTUP_UPDATE_ROOT}/dist/${_arch}/rustup-init${_ext}\"", "", "    local _dir", "    _dir=\"$(ensure mktemp -d)\"", "    local _file=\"${_dir}/rustup-init${_ext}\"", "", "    local _ansi_escapes_are_valid=false", "    if [ -t 2 ]; then", "        if [ \"${TERM+set}\" = 'set' ]; then", "            case \"$TERM\" in", "                xterm*|rxvt*|urxvt*|linux*|vt*)", "                    _ansi_escapes_are_valid=true", "                ;;", "            esac", "        fi", "    fi", "", "    # check if we have to use /dev/tty to prompt the user", "    local need_tty=yes", "    for arg in \"$@\"; do", "        case \"$arg\" in", "            --help)", "                usage", "                exit 0", "                ;;", "            *)", "                OPTIND=1", "                if [ \"${arg%%--*}\" = \"\" ]; then", "                    # Long option (other than --help);", "                    # don't attempt to interpret it.", "                    continue", "                fi", "                while getopts :hy sub_arg \"$arg\"; do", "                    case \"$sub_arg\" in", "                        h)", "                            usage", "                            exit 0", "                            ;;", "                        y)", "                            # user wants to skip the prompt --", "                            # we don't need /dev/tty", "                            need_tty=no", "                            ;;", "                        *)", "                            ;;", "                        esac", "                done", "                ;;", "        esac", "    done", "", "    if $_ansi_escapes_are_valid; then", "        printf \"\\33[1minfo:\\33[0m downloading installer\\n\" 1>&2", "    else", "        printf '%s\\n' 'info: downloading installer' 1>&2", "    fi", "", "    ensure mkdir -p \"$_dir\"", "    ensure downloader \"$_url\" \"$_file\" \"$_arch\"", "    ensure chmod u+x \"$_file\"", "    if [ ! -x \"$_file\" ]; then", "        printf '%s\\n' \"Cannot execute $_file (likely because of mounting /tmp as noexec).\" 1>&2", "        printf '%s\\n' \"Please copy the file to a location where you can execute binaries and run ./rustup-init${_ext}.\" 1>&2", "        exit 1", "    fi", "", "    if [ \"$need_tty\" = \"yes\" ] && [ ! -t 0 ]; then", "        # The installer is going to want to ask for confirmation by", "        # reading stdin.  This script was piped into `sh` though and", "        # doesn't have stdin to pass to its children. Instead we're going", "        # to explicitly connect /dev/tty to the installer's stdin.", "        if [ ! -t 1 ]; then", "            err \"Unable to run interactively. Run with -y to accept defaults, --help for additional options\"", "        fi", "", "        ignore \"$_file\" \"$@\" < /dev/tty", "    else", "        ignore \"$_file\" \"$@\"", "    fi", "", "    local _retval=$?", "", "    ignore rm \"$_file\"", "    ignore rmdir \"$_dir\"", "", "    return \"$_retval\"", "}", "", "check_proc() {", "    # Check for /proc by looking for the /proc/self/exe link", "    # This is only run on Linux", "    if ! test -L /proc/self/exe ; then", "        err \"fatal: Unable to find /proc/self/exe.  Is /proc mounted?  Installation cannot proceed without /proc.\"", "    fi", "}", "", "get_bitness() {", "    need_cmd head", "    # Architecture detection without dependencies beyond coreutils.", "    # ELF files start out \"\\x7fELF\", and the following byte is", "    #   0x01 for 32-bit and", "    #   0x02 for 64-bit.", "    # The printf builtin on some shells like dash only supports octal", "    # escape sequences, so we use those.", "    local _current_exe_head", "    _current_exe_head=$(head -c 5 /proc/self/exe )", "    if [ \"$_current_exe_head\" = \"$(printf '\\177ELF\\001')\" ]; then", "        echo 32", "    elif [ \"$_current_exe_head\" = \"$(printf '\\177ELF\\002')\" ]; then", "        echo 64", "    else", "        err \"unknown platform bitness\"", "    fi", "}", "", "is_host_amd64_elf() {", "    need_cmd head", "    need_cmd tail", "    # ELF e_machine detection without dependencies beyond coreutils.", "    # Two-byte field at offset 0x12 indicates the CPU,", "    # but we're interested in it being 0x3E to indicate amd64, or not that.", "    local _current_exe_machine", "    _current_exe_machine=$(head -c 19 /proc/self/exe | tail -c 1)", "    [ \"$_current_exe_machine\" = \"$(printf '\\076')\" ]", "}", "", "get_endianness() {", "    local cputype=$1", "    local suffix_eb=$2", "    local suffix_el=$3", "", "    # detect endianness without od/hexdump, like get_bitness() does.", "    need_cmd head", "    need_cmd tail", "", "    local _current_exe_endianness", "    _current_exe_endianness=\"$(head -c 6 /proc/self/exe | tail -c 1)\"", "    if [ \"$_current_exe_endianness\" = \"$(printf '\\001')\" ]; then", "        echo \"${cputype}${suffix_el}\"", "    elif [ \"$_current_exe_endianness\" = \"$(printf '\\002')\" ]; then", "        echo \"${cputype}${suffix_eb}\"", "    else", "        err \"unknown platform endianness\"", "    fi", "}", "", "get_architecture() {", "    local _ostype _cputype _bitness _arch _clibtype", "    _ostype=\"$(uname -s)\"", "    _cputype=\"$(uname -m)\"", "    _clibtype=\"gnu\"", "", "    if [ \"$_ostype\" = Linux ]; then", "        if [ \"$(uname -o)\" = Android ]; then", "            _ostype=Android", "        fi", "        if ldd --version 2>&1 | grep -q 'musl'; then", "            _clibtype=\"musl\"", "        fi", "    fi", "", "    if [ \"$_ostype\" = Darwin ] && [ \"$_cputype\" = i386 ]; then", "        # Darwin `uname -m` lies", "        if sysctl hw.optional.x86_64 | grep -q ': 1'; then", "            _cputype=x86_64", "        fi", "    fi", "", "    if [ \"$_ostype\" = SunOS ]; then", "        # Both Solaris and illumos presently announce as \"SunOS\" in \"uname -s\"", "        # so use \"uname -o\" to disambiguate.  We use the full path to the", "        # system uname in case the user has coreutils uname first in PATH,", "        # which has historically sometimes printed the wrong value here.", "        if [ \"$(/usr/bin/uname -o)\" = illumos ]; then", "            _ostype=illumos", "        fi", "", "        # illumos systems have multi-arch userlands, and \"uname -m\" reports the", "        # machine hardware name; e.g., \"i86pc\" on both 32- and 64-bit x86", "        # systems.  Check for the native (widest) instruction set on the", "        # running kernel:", "        if [ \"$_cputype\" = i86pc ]; then", "            _cputype=\"$(isainfo -n)\"", "        fi", "    fi", "", "    case \"$_ostype\" in", "", "        Android)", "            _ostype=linux-android", "            ;;", "", "        Linux)", "            check_proc", "            _ostype=unknown-linux-$_clibtype", "            _bitness=$(get_bitness)", "            ;;", "", "        FreeBSD)", "            _ostype=unknown-freebsd", "            ;;", "", "        NetBSD)", "            _ostype=unknown-netbsd", "            ;;", "", "        DragonFly)", "            _ostype=unknown-dragonfly", "            ;;", "", "        Darwin)", "            _ostype=apple-darwin", "            ;;", "", "        illumos)", "            _ostype=unknown-illumos", "            ;;", "", "        MINGW* | MSYS* | CYGWIN* | Windows_NT)", "            _ostype=pc-windows-gnu", "            ;;", "", "        *)", "            err \"unrecognized OS type: $_ostype\"", "            ;;", "", "    esac", "", "    case \"$_cputype\" in", "", "        i386 | i486 | i686 | i786 | x86)", "            _cputype=i686", "            ;;", "", "        xscale | arm)", "            _cputype=arm", "            if [ \"$_ostype\" = \"linux-android\" ]; then", "                _ostype=linux-androideabi", "            fi", "            ;;", "", "        armv6l)", "            _cputype=arm", "            if [ \"$_ostype\" = \"linux-android\" ]; then", "                _ostype=linux-androideabi", "            else", "                _ostype=\"${_ostype}eabihf\"", "            fi", "            ;;", "", "        armv7l | armv8l)", "            _cputype=armv7", "            if [ \"$_ostype\" = \"linux-android\" ]; then", "                _ostype=linux-androideabi", "            else", "                _ostype=\"${_ostype}eabihf\"", "            fi", "            ;;", "", "        aarch64 | arm64)", "            _cputype=aarch64", "            ;;", "", "        x86_64 | x86-64 | x64 | amd64)", "            _cputype=x86_64", "            ;;", "", "        mips)", "            _cputype=$(get_endianness mips '' el)", "            ;;", "", "        mips64)", "            if [ \"$_bitness\" -eq 64 ]; then", "                # only n64 ABI is supported for now", "                _ostype=\"${_ostype}abi64\"", "                _cputype=$(get_endianness mips64 '' el)", "            fi", "            ;;", "", "        ppc)", "            _cputype=powerpc", "            ;;", "", "        ppc64)", "            _cputype=powerpc64", "            ;;", "", "        ppc64le)", "            _cputype=powerpc64le", "            ;;", "", "        s390x)", "            _cputype=s390x", "            ;;", "        riscv64)", "            _cputype=riscv64gc", "            ;;", "        *)", "            err \"unknown CPU type: $_cputype\"", "", "    esac", "", "    # Detect 64-bit linux with 32-bit userland", "    if [ \"${_ostype}\" = unknown-linux-gnu ] && [ \"${_bitness}\" -eq 32 ]; then", "        case $_cputype in", "            x86_64)", "                if [ -n \"${RUSTUP_CPUTYPE:-}\" ]; then", "                    _cputype=\"$RUSTUP_CPUTYPE\"", "                else {", "                    # 32-bit executable for amd64 = x32", "                    if is_host_amd64_elf; then {", "                         echo \"This host is running an x32 userland; as it stands, x32 support is poor,\" 1>&2", "                         echo \"and there isn't a native toolchain -- you will have to install\" 1>&2", "                         echo \"multiarch compatibility with i686 and/or amd64, then select one\" 1>&2", "                         echo \"by re-running this script with the RUSTUP_CPUTYPE environment variable\" 1>&2", "                         echo \"set to i686 or x86_64, respectively.\" 1>&2", "                         echo 1>&2", "                         echo \"You will be able to add an x32 target after installation by running\" 1>&2", "                         echo \"  rustup target add x86_64-unknown-linux-gnux32\" 1>&2", "                         exit 1", "                    }; else", "                        _cputype=i686", "                    fi", "                }; fi", "                ;;", "            mips64)", "                _cputype=$(get_endianness mips '' el)", "                ;;", "            powerpc64)", "                _cputype=powerpc", "                ;;", "            aarch64)", "                _cputype=armv7", "                if [ \"$_ostype\" = \"linux-android\" ]; then", "                    _ostype=linux-androideabi", "                else", "                    _ostype=\"${_ostype}eabihf\"", "                fi", "                ;;", "            riscv64gc)", "                err \"riscv64 with 32-bit userland unsupported\"", "                ;;", "        esac", "    fi", "", "    # Detect armv7 but without the CPU features Rust needs in that build,", "    # and fall back to arm.", "    # See https://github.com/rust-lang/rustup.rs/issues/587.", "    if [ \"$_ostype\" = \"unknown-linux-gnueabihf\" ] && [ \"$_cputype\" = armv7 ]; then", "        if ensure grep '^Features' /proc/cpuinfo | grep -q -v neon; then", "            # At least one processor does not have NEON.", "            _cputype=arm", "        fi", "    fi", "", "    _arch=\"${_cputype}-${_ostype}\"", "", "    RETVAL=\"$_arch\"", "}", "", "say() {", "    printf 'rustup: %s\\n' \"$1\"", "}", "", "err() {", "    say \"$1\" >&2", "    exit 1", "}", "", "need_cmd() {", "    if ! check_cmd \"$1\"; then", "        err \"need '$1' (command not found)\"", "    fi", "}", "", "check_cmd() {", "    command -v \"$1\" > /dev/null 2>&1", "}", "", "assert_nz() {", "    if [ -z \"$1\" ]; then err \"assert_nz $2\"; fi", "}", "", "# Run a command that should never fail. If the command fails execution", "# will immediately terminate with an error showing the failing", "# command.", "ensure() {", "    if ! \"$@\"; then err \"command failed: $*\"; fi", "}", "", "# This is just for indicating that commands' results are being", "# intentionally ignored. Usually, because it's being executed", "# as part of error handling.", "ignore() {", "    \"$@\"", "}", "", "# This wraps curl or wget. Try curl first, if not installed,", "# use wget instead.", "downloader() {", "    local _dld", "    local _ciphersuites", "    local _err", "    local _status", "    local _retry", "    if check_cmd curl; then", "        _dld=curl", "    elif check_cmd wget; then", "        _dld=wget", "    else", "        _dld='curl or wget' # to be used in error message of need_cmd", "    fi", "", "    if [ \"$1\" = --check ]; then", "        need_cmd \"$_dld\"", "    elif [ \"$_dld\" = curl ]; then", "        check_curl_for_retry_support", "        _retry=\"$RETVAL\"", "        get_ciphersuites_for_curl", "        _ciphersuites=\"$RETVAL\"", "        if [ -n \"$_ciphersuites\" ]; then", "            _err=$(curl $_retry --proto '=https' --tlsv1.2 --ciphers \"$_ciphersuites\" --silent --show-error --fail --location \"$1\" --output \"$2\" 2>&1)", "            _status=$?", "        else", "            echo \"Warning: Not enforcing strong cipher suites for TLS, this is potentially less secure\"", "            if ! check_help_for \"$3\" curl --proto --tlsv1.2; then", "                echo \"Warning: Not enforcing TLS v1.2, this is potentially less secure\"", "                _err=$(curl $_retry --silent --show-error --fail --location \"$1\" --output \"$2\" 2>&1)", "                _status=$?", "            else", "                _err=$(curl $_retry --proto '=https' --tlsv1.2 --silent --show-error --fail --location \"$1\" --output \"$2\" 2>&1)", "                _status=$?", "            fi", "        fi", "        if [ -n \"$_err\" ]; then", "            echo \"$_err\" >&2", "            if echo \"$_err\" | grep -q 404$; then", "                err \"installer for platform '$3' not found, this may be unsupported\"", "            fi", "        fi", "        return $_status", "    elif [ \"$_dld\" = wget ]; then", "        if [ \"$(wget -V 2>&1|head -2|tail -1|cut -f1 -d\" \")\" = \"BusyBox\" ]; then", "            echo \"Warning: using the BusyBox version of wget.  Not enforcing strong cipher suites for TLS or TLS v1.2, this is potentially less secure\"", "            _err=$(wget \"$1\" -O \"$2\" 2>&1)", "            _status=$?", "        else", "            get_ciphersuites_for_wget", "            _ciphersuites=\"$RETVAL\"", "            if [ -n \"$_ciphersuites\" ]; then", "                _err=$(wget --https-only --secure-protocol=TLSv1_2 --ciphers \"$_ciphersuites\" \"$1\" -O \"$2\" 2>&1)", "                _status=$?", "            else", "                echo \"Warning: Not enforcing strong cipher suites for TLS, this is potentially less secure\"", "                if ! check_help_for \"$3\" wget --https-only --secure-protocol; then", "                    echo \"Warning: Not enforcing TLS v1.2, this is potentially less secure\"", "                    _err=$(wget \"$1\" -O \"$2\" 2>&1)", "                    _status=$?", "                else", "                    _err=$(wget --https-only --secure-protocol=TLSv1_2 \"$1\" -O \"$2\" 2>&1)", "                    _status=$?", "                fi", "            fi", "        fi", "        if [ -n \"$_err\" ]; then", "            echo \"$_err\" >&2", "            if echo \"$_err\" | grep -q ' 404 Not Found$'; then", "                err \"installer for platform '$3' not found, this may be unsupported\"", "            fi", "        fi", "        return $_status", "    else", "        err \"Unknown downloader\"   # should not reach here", "    fi", "}", "", "check_help_for() {", "    local _arch", "    local _cmd", "    local _arg", "    _arch=\"$1\"", "    shift", "    _cmd=\"$1\"", "    shift", "", "    local _category", "    if \"$_cmd\" --help | grep -q 'For all options use the manual or \"--help all\".'; then", "      _category=\"all\"", "    else", "      _category=\"\"", "    fi", "", "    case \"$_arch\" in", "", "        *darwin*)", "        if check_cmd sw_vers; then", "            case $(sw_vers -productVersion) in", "                10.*)", "                    # If we're running on macOS, older than 10.13, then we always", "                    # fail to find these options to force fallback", "                    if [ \"$(sw_vers -productVersion | cut -d. -f2)\" -lt 13 ]; then", "                        # Older than 10.13", "                        echo \"Warning: Detected macOS platform older than 10.13\"", "                        return 1", "                    fi", "                    ;;", "                11.*)", "                    # We assume Big Sur will be OK for now", "                    ;;", "                *)", "                    # Unknown product version, warn and continue", "                    echo \"Warning: Detected unknown macOS major version: $(sw_vers -productVersion)\"", "                    echo \"Warning TLS capabilities detection may fail\"", "                    ;;", "            esac", "        fi", "        ;;", "", "    esac", "", "    for _arg in \"$@\"; do", "        if ! \"$_cmd\" --help $_category | grep -q -- \"$_arg\"; then", "            return 1", "        fi", "    done", "", "    true # not strictly needed", "}", "", "# Check if curl supports the --retry flag, then pass it to the curl invocation.", "check_curl_for_retry_support() {", "  local _retry_supported=\"\"", "  # \"unspecified\" is for arch, allows for possibility old OS using macports, homebrew, etc.", "  if check_help_for \"notspecified\" \"curl\" \"--retry\"; then", "    _retry_supported=\"--retry 3\"", "  fi", "", "  RETVAL=\"$_retry_supported\"", "", "}", "", "# Return cipher suite string specified by user, otherwise return strong TLS 1.2-1.3 cipher suites", "# if support by local tools is detected. Detection currently supports these curl backends:", "# GnuTLS and OpenSSL (possibly also LibreSSL and BoringSSL). Return value can be empty.", "get_ciphersuites_for_curl() {", "    if [ -n \"${RUSTUP_TLS_CIPHERSUITES-}\" ]; then", "        # user specified custom cipher suites, assume they know what they're doing", "        RETVAL=\"$RUSTUP_TLS_CIPHERSUITES\"", "        return", "    fi", "", "    local _openssl_syntax=\"no\"", "    local _gnutls_syntax=\"no\"", "    local _backend_supported=\"yes\"", "    if curl -V | grep -q ' OpenSSL/'; then", "        _openssl_syntax=\"yes\"", "    elif curl -V | grep -iq ' LibreSSL/'; then", "        _openssl_syntax=\"yes\"", "    elif curl -V | grep -iq ' BoringSSL/'; then", "        _openssl_syntax=\"yes\"", "    elif curl -V | grep -iq ' GnuTLS/'; then", "        _gnutls_syntax=\"yes\"", "    else", "        _backend_supported=\"no\"", "    fi", "", "    local _args_supported=\"no\"", "    if [ \"$_backend_supported\" = \"yes\" ]; then", "        # \"unspecified\" is for arch, allows for possibility old OS using macports, homebrew, etc.", "        if check_help_for \"notspecified\" \"curl\" \"--tlsv1.2\" \"--ciphers\" \"--proto\"; then", "            _args_supported=\"yes\"", "        fi", "    fi", "", "    local _cs=\"\"", "    if [ \"$_args_supported\" = \"yes\" ]; then", "        if [ \"$_openssl_syntax\" = \"yes\" ]; then", "            _cs=$(get_strong_ciphersuites_for \"openssl\")", "        elif [ \"$_gnutls_syntax\" = \"yes\" ]; then", "            _cs=$(get_strong_ciphersuites_for \"gnutls\")", "        fi", "    fi", "", "    RETVAL=\"$_cs\"", "}", "", "# Return cipher suite string specified by user, otherwise return strong TLS 1.2-1.3 cipher suites", "# if support by local tools is detected. Detection currently supports these wget backends:", "# GnuTLS and OpenSSL (possibly also LibreSSL and BoringSSL). Return value can be empty.", "get_ciphersuites_for_wget() {", "    if [ -n \"${RUSTUP_TLS_CIPHERSUITES-}\" ]; then", "        # user specified custom cipher suites, assume they know what they're doing", "        RETVAL=\"$RUSTUP_TLS_CIPHERSUITES\"", "        return", "    fi", "", "    local _cs=\"\"", "    if wget -V | grep -q '\\-DHAVE_LIBSSL'; then", "        # \"unspecified\" is for arch, allows for possibility old OS using macports, homebrew, etc.", "        if check_help_for \"notspecified\" \"wget\" \"TLSv1_2\" \"--ciphers\" \"--https-only\" \"--secure-protocol\"; then", "            _cs=$(get_strong_ciphersuites_for \"openssl\")", "        fi", "    elif wget -V | grep -q '\\-DHAVE_LIBGNUTLS'; then", "        # \"unspecified\" is for arch, allows for possibility old OS using macports, homebrew, etc.", "        if check_help_for \"notspecified\" \"wget\" \"TLSv1_2\" \"--ciphers\" \"--https-only\" \"--secure-protocol\"; then", "            _cs=$(get_strong_ciphersuites_for \"gnutls\")", "        fi", "    fi", "", "    RETVAL=\"$_cs\"", "}", "", "# Return strong TLS 1.2-1.3 cipher suites in OpenSSL or GnuTLS syntax. TLS 1.2", "# excludes non-ECDHE and non-AEAD cipher suites. DHE is excluded due to bad", "# DH params often found on servers (see RFC 7919). Sequence matches or is", "# similar to Firefox 68 ESR with weak cipher suites disabled via about:config.", "# $1 must be openssl or gnutls.", "get_strong_ciphersuites_for() {", "    if [ \"$1\" = \"openssl\" ]; then", "        # OpenSSL is forgiving of unknown values, no problems with TLS 1.3 values on versions that don't support it yet.", "        echo \"TLS_AES_128_GCM_SHA256:TLS_CHACHA20_POLY1305_SHA256:TLS_AES_256_GCM_SHA384:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384\"", "    elif [ \"$1\" = \"gnutls\" ]; then", "        # GnuTLS isn't forgiving of unknown values, so this may require a GnuTLS version that supports TLS 1.3 even if wget doesn't.", "        # Begin with SECURE128 (and higher) then remove/add to build cipher suites. Produces same 9 cipher suites as OpenSSL but in slightly different order.", "        echo \"SECURE128:-VERS-SSL3.0:-VERS-TLS1.0:-VERS-TLS1.1:-VERS-DTLS-ALL:-CIPHER-ALL:-MAC-ALL:-KX-ALL:+AEAD:+ECDHE-ECDSA:+ECDHE-RSA:+AES-128-GCM:+CHACHA20-POLY1305:+AES-256-GCM\"", "    fi", "}", "", "main \"$@\" || exit 1", "curl: (6) Could not resolve host: |", "curl: (6) Could not resolve host: sh"]}
2022-12-30 00:10:53,138 p=90283 u=kal n=ansible | PLAY RECAP *******************************************************************************************************************************************
2022-12-30 00:10:53,138 p=90283 u=kal n=ansible | krpz                       : ok=3    changed=0    unreachable=0    failed=1    skipped=0    rescued=0    ignored=0   
2022-12-30 00:10:57,425 p=90511 u=kal n=ansible | PLAY [localhost] *************************************************************************************************************************************
2022-12-30 00:10:57,432 p=90511 u=kal n=ansible | TASK [Gathering Facts] *******************************************************************************************************************************
2022-12-30 00:10:58,531 p=90511 u=kal n=ansible | ok: [krpz]
2022-12-30 00:10:58,552 p=90511 u=kal n=ansible | TASK [install pexpect] *******************************************************************************************************************************
2022-12-30 00:10:58,984 p=90511 u=kal n=ansible | ok: [krpz]
2022-12-30 00:10:58,992 p=90511 u=kal n=ansible | TASK [install setuptools] ****************************************************************************************************************************
2022-12-30 00:10:59,339 p=90511 u=kal n=ansible | ok: [krpz]
2022-12-30 00:10:59,347 p=90511 u=kal n=ansible | TASK [Install Rust] **********************************************************************************************************************************
2022-12-30 00:11:00,608 p=90511 u=kal n=ansible | fatal: [krpz]: FAILED! => {"changed": true, "cmd": "curl https://sh.rustup.rs | sh", "delta": "0:00:01.013540", "end": "2022-12-30 00:11:00.525487", "msg": "non-zero return code", "rc": 6, "start": "2022-12-30 00:10:59.511947", "stdout": "#!/bin/sh\r\n# shellcheck shell=dash\r\n\r\n# This is just a little script that can be downloaded from the internet to\r\n# install rustup. It just does platform detection, downloads the installer\r\n# and runs it.\r\n\r\n# It runs on Unix shells like {a,ba,da,k,z}sh. It uses the common `local`\r\n# extension. Note: Most shells limit `local` to 1 var per line, contra bash.\r\n\r\nif [ \"$KSH_VERSION\" = 'Version JM 93t+ 2010-03-05' ]; then\r\n    # The version of ksh93 that ships with many illumos systems does not\r\n    # support the \"local\" extension.  Print a message rather than fail in\r\n    # subtle ways later on:\r\n    echo 'rustup does not work with this ksh93 version; please try bash!' >&2\r\n    exit 1\r\nfi\r\n\r\n\r\nset -u\r\n\r\n# If RUSTUP_UPDATE_ROOT is unset or empty, default it.\r\nRUSTUP_UPDATE_ROOT=\"${RUSTUP_UPDATE_ROOT:-https://static.rust-lang.org/rustup}\"\r\n\r\n#XXX: If you change anything here, please make the same changes in setup_mode.rs\r\nusage() {\r\n    cat 1>&2 <<EOF\r\nrustup-init 1.25.1 (48d233f65 2022-07-12)\r\nThe installer for rustup\r\n\r\nUSAGE:\r\n    rustup-init [FLAGS] [OPTIONS]\r\n\r\nFLAGS:\r\n    -v, --verbose           Enable verbose output\r\n    -q, --quiet             Disable progress output\r\n    -y                      Disable confirmation prompt.\r\n        --no-modify-path    Don't configure the PATH environment variable\r\n    -h, --help              Prints help information\r\n    -V, --version           Prints version information\r\n\r\nOPTIONS:\r\n        --default-host <default-host>              Choose a default host triple\r\n        --default-toolchain <default-toolchain>    Choose a default toolchain to install\r\n        --default-toolchain none                   Do not install any toolchains\r\n        --profile [minimal|default|complete]       Choose a profile\r\n    -c, --component <components>...                Component name to also install\r\n    -t, --target <targets>...                      Target name to also install\r\nEOF\r\n}\r\n\r\nmain() {\r\n    downloader --check\r\n    need_cmd uname\r\n    need_cmd mktemp\r\n    need_cmd chmod\r\n    need_cmd mkdir\r\n    need_cmd rm\r\n    need_cmd rmdir\r\n\r\n    get_architecture || return 1\r\n    local _arch=\"$RETVAL\"\r\n    assert_nz \"$_arch\" \"arch\"\r\n\r\n    local _ext=\"\"\r\n    case \"$_arch\" in\r\n        *windows*)\r\n            _ext=\".exe\"\r\n            ;;\r\n    esac\r\n\r\n    local _url=\"${RUSTUP_UPDATE_ROOT}/dist/${_arch}/rustup-init${_ext}\"\r\n\r\n    local _dir\r\n    _dir=\"$(ensure mktemp -d)\"\r\n    local _file=\"${_dir}/rustup-init${_ext}\"\r\n\r\n    local _ansi_escapes_are_valid=false\r\n    if [ -t 2 ]; then\r\n        if [ \"${TERM+set}\" = 'set' ]; then\r\n            case \"$TERM\" in\r\n                xterm*|rxvt*|urxvt*|linux*|vt*)\r\n                    _ansi_escapes_are_valid=true\r\n                ;;\r\n            esac\r\n        fi\r\n    fi\r\n\r\n    # check if we have to use /dev/tty to prompt the user\r\n    local need_tty=yes\r\n    for arg in \"$@\"; do\r\n        case \"$arg\" in\r\n            --help)\r\n                usage\r\n                exit 0\r\n                ;;\r\n            *)\r\n                OPTIND=1\r\n                if [ \"${arg%%--*}\" = \"\" ]; then\r\n                    # Long option (other than --help);\r\n                    # don't attempt to interpret it.\r\n                    continue\r\n                fi\r\n                while getopts :hy sub_arg \"$arg\"; do\r\n                    case \"$sub_arg\" in\r\n                        h)\r\n                            usage\r\n                            exit 0\r\n                            ;;\r\n                        y)\r\n                            # user wants to skip the prompt --\r\n                            # we don't need /dev/tty\r\n                            need_tty=no\r\n                            ;;\r\n                        *)\r\n                            ;;\r\n                        esac\r\n                done\r\n                ;;\r\n        esac\r\n    done\r\n\r\n    if $_ansi_escapes_are_valid; then\r\n        printf \"\\33[1minfo:\\33[0m downloading installer\\n\" 1>&2\r\n    else\r\n        printf '%s\\n' 'info: downloading installer' 1>&2\r\n    fi\r\n\r\n    ensure mkdir -p \"$_dir\"\r\n    ensure downloader \"$_url\" \"$_file\" \"$_arch\"\r\n    ensure chmod u+x \"$_file\"\r\n    if [ ! -x \"$_file\" ]; then\r\n        printf '%s\\n' \"Cannot execute $_file (likely because of mounting /tmp as noexec).\" 1>&2\r\n        printf '%s\\n' \"Please copy the file to a location where you can execute binaries and run ./rustup-init${_ext}.\" 1>&2\r\n        exit 1\r\n    fi\r\n\r\n    if [ \"$need_tty\" = \"yes\" ] && [ ! -t 0 ]; then\r\n        # The installer is going to want to ask for confirmation by\r\n        # reading stdin.  This script was piped into `sh` though and\r\n        # doesn't have stdin to pass to its children. Instead we're going\r\n        # to explicitly connect /dev/tty to the installer's stdin.\r\n        if [ ! -t 1 ]; then\r\n            err \"Unable to run interactively. Run with -y to accept defaults, --help for additional options\"\r\n        fi\r\n\r\n        ignore \"$_file\" \"$@\" < /dev/tty\r\n    else\r\n        ignore \"$_file\" \"$@\"\r\n    fi\r\n\r\n    local _retval=$?\r\n\r\n    ignore rm \"$_file\"\r\n    ignore rmdir \"$_dir\"\r\n\r\n    return \"$_retval\"\r\n}\r\n\r\ncheck_proc() {\r\n    # Check for /proc by looking for the /proc/self/exe link\r\n    # This is only run on Linux\r\n    if ! test -L /proc/self/exe ; then\r\n        err \"fatal: Unable to find /proc/self/exe.  Is /proc mounted?  Installation cannot proceed without /proc.\"\r\n    fi\r\n}\r\n\r\nget_bitness() {\r\n    need_cmd head\r\n    # Architecture detection without dependencies beyond coreutils.\r\n    # ELF files start out \"\\x7fELF\", and the following byte is\r\n    #   0x01 for 32-bit and\r\n    #   0x02 for 64-bit.\r\n    # The printf builtin on some shells like dash only supports octal\r\n    # escape sequences, so we use those.\r\n    local _current_exe_head\r\n    _current_exe_head=$(head -c 5 /proc/self/exe )\r\n    if [ \"$_current_exe_head\" = \"$(printf '\\177ELF\\001')\" ]; then\r\n        echo 32\r\n    elif [ \"$_current_exe_head\" = \"$(printf '\\177ELF\\002')\" ]; then\r\n        echo 64\r\n    else\r\n        err \"unknown platform bitness\"\r\n    fi\r\n}\r\n\r\nis_host_amd64_elf() {\r\n    need_cmd head\r\n    need_cmd tail\r\n    # ELF e_machine detection without dependencies beyond coreutils.\r\n    # Two-byte field at offset 0x12 indicates the CPU,\r\n    # but we're interested in it being 0x3E to indicate amd64, or not that.\r\n    local _current_exe_machine\r\n    _current_exe_machine=$(head -c 19 /proc/self/exe | tail -c 1)\r\n    [ \"$_current_exe_machine\" = \"$(printf '\\076')\" ]\r\n}\r\n\r\nget_endianness() {\r\n    local cputype=$1\r\n    local suffix_eb=$2\r\n    local suffix_el=$3\r\n\r\n    # detect endianness without od/hexdump, like get_bitness() does.\r\n    need_cmd head\r\n    need_cmd tail\r\n\r\n    local _current_exe_endianness\r\n    _current_exe_endianness=\"$(head -c 6 /proc/self/exe | tail -c 1)\"\r\n    if [ \"$_current_exe_endianness\" = \"$(printf '\\001')\" ]; then\r\n        echo \"${cputype}${suffix_el}\"\r\n    elif [ \"$_current_exe_endianness\" = \"$(printf '\\002')\" ]; then\r\n        echo \"${cputype}${suffix_eb}\"\r\n    else\r\n        err \"unknown platform endianness\"\r\n    fi\r\n}\r\n\r\nget_architecture() {\r\n    local _ostype _cputype _bitness _arch _clibtype\r\n    _ostype=\"$(uname -s)\"\r\n    _cputype=\"$(uname -m)\"\r\n    _clibtype=\"gnu\"\r\n\r\n    if [ \"$_ostype\" = Linux ]; then\r\n        if [ \"$(uname -o)\" = Android ]; then\r\n            _ostype=Android\r\n        fi\r\n        if ldd --version 2>&1 | grep -q 'musl'; then\r\n            _clibtype=\"musl\"\r\n        fi\r\n    fi\r\n\r\n    if [ \"$_ostype\" = Darwin ] && [ \"$_cputype\" = i386 ]; then\r\n        # Darwin `uname -m` lies\r\n        if sysctl hw.optional.x86_64 | grep -q ': 1'; then\r\n            _cputype=x86_64\r\n        fi\r\n    fi\r\n\r\n    if [ \"$_ostype\" = SunOS ]; then\r\n        # Both Solaris and illumos presently announce as \"SunOS\" in \"uname -s\"\r\n        # so use \"uname -o\" to disambiguate.  We use the full path to the\r\n        # system uname in case the user has coreutils uname first in PATH,\r\n        # which has historically sometimes printed the wrong value here.\r\n        if [ \"$(/usr/bin/uname -o)\" = illumos ]; then\r\n            _ostype=illumos\r\n        fi\r\n\r\n        # illumos systems have multi-arch userlands, and \"uname -m\" reports the\r\n        # machine hardware name; e.g., \"i86pc\" on both 32- and 64-bit x86\r\n        # systems.  Check for the native (widest) instruction set on the\r\n        # running kernel:\r\n        if [ \"$_cputype\" = i86pc ]; then\r\n            _cputype=\"$(isainfo -n)\"\r\n        fi\r\n    fi\r\n\r\n    case \"$_ostype\" in\r\n\r\n        Android)\r\n            _ostype=linux-android\r\n            ;;\r\n\r\n        Linux)\r\n            check_proc\r\n            _ostype=unknown-linux-$_clibtype\r\n            _bitness=$(get_bitness)\r\n            ;;\r\n\r\n        FreeBSD)\r\n            _ostype=unknown-freebsd\r\n            ;;\r\n\r\n        NetBSD)\r\n            _ostype=unknown-netbsd\r\n            ;;\r\n\r\n        DragonFly)\r\n            _ostype=unknown-dragonfly\r\n            ;;\r\n\r\n        Darwin)\r\n            _ostype=apple-darwin\r\n            ;;\r\n\r\n        illumos)\r\n            _ostype=unknown-illumos\r\n            ;;\r\n\r\n        MINGW* | MSYS* | CYGWIN* | Windows_NT)\r\n            _ostype=pc-windows-gnu\r\n            ;;\r\n\r\n        *)\r\n            err \"unrecognized OS type: $_ostype\"\r\n            ;;\r\n\r\n    esac\r\n\r\n    case \"$_cputype\" in\r\n\r\n        i386 | i486 | i686 | i786 | x86)\r\n            _cputype=i686\r\n            ;;\r\n\r\n        xscale | arm)\r\n            _cputype=arm\r\n            if [ \"$_ostype\" = \"linux-android\" ]; then\r\n                _ostype=linux-androideabi\r\n            fi\r\n            ;;\r\n\r\n        armv6l)\r\n            _cputype=arm\r\n            if [ \"$_ostype\" = \"linux-android\" ]; then\r\n                _ostype=linux-androideabi\r\n            else\r\n                _ostype=\"${_ostype}eabihf\"\r\n            fi\r\n            ;;\r\n\r\n        armv7l | armv8l)\r\n            _cputype=armv7\r\n            if [ \"$_ostype\" = \"linux-android\" ]; then\r\n                _ostype=linux-androideabi\r\n            else\r\n                _ostype=\"${_ostype}eabihf\"\r\n            fi\r\n            ;;\r\n\r\n        aarch64 | arm64)\r\n            _cputype=aarch64\r\n            ;;\r\n\r\n        x86_64 | x86-64 | x64 | amd64)\r\n            _cputype=x86_64\r\n            ;;\r\n\r\n        mips)\r\n            _cputype=$(get_endianness mips '' el)\r\n            ;;\r\n\r\n        mips64)\r\n            if [ \"$_bitness\" -eq 64 ]; then\r\n                # only n64 ABI is supported for now\r\n                _ostype=\"${_ostype}abi64\"\r\n                _cputype=$(get_endianness mips64 '' el)\r\n            fi\r\n            ;;\r\n\r\n        ppc)\r\n            _cputype=powerpc\r\n            ;;\r\n\r\n        ppc64)\r\n            _cputype=powerpc64\r\n            ;;\r\n\r\n        ppc64le)\r\n            _cputype=powerpc64le\r\n            ;;\r\n\r\n        s390x)\r\n            _cputype=s390x\r\n            ;;\r\n        riscv64)\r\n            _cputype=riscv64gc\r\n            ;;\r\n        *)\r\n            err \"unknown CPU type: $_cputype\"\r\n\r\n    esac\r\n\r\n    # Detect 64-bit linux with 32-bit userland\r\n    if [ \"${_ostype}\" = unknown-linux-gnu ] && [ \"${_bitness}\" -eq 32 ]; then\r\n        case $_cputype in\r\n            x86_64)\r\n                if [ -n \"${RUSTUP_CPUTYPE:-}\" ]; then\r\n                    _cputype=\"$RUSTUP_CPUTYPE\"\r\n                else {\r\n                    # 32-bit executable for amd64 = x32\r\n                    if is_host_amd64_elf; then {\r\n                         echo \"This host is running an x32 userland; as it stands, x32 support is poor,\" 1>&2\r\n                         echo \"and there isn't a native toolchain -- you will have to install\" 1>&2\r\n                         echo \"multiarch compatibility with i686 and/or amd64, then select one\" 1>&2\r\n                         echo \"by re-running this script with the RUSTUP_CPUTYPE environment variable\" 1>&2\r\n                         echo \"set to i686 or x86_64, respectively.\" 1>&2\r\n                         echo 1>&2\r\n                         echo \"You will be able to add an x32 target after installation by running\" 1>&2\r\n                         echo \"  rustup target add x86_64-unknown-linux-gnux32\" 1>&2\r\n                         exit 1\r\n                    }; else\r\n                        _cputype=i686\r\n                    fi\r\n                }; fi\r\n                ;;\r\n            mips64)\r\n                _cputype=$(get_endianness mips '' el)\r\n                ;;\r\n            powerpc64)\r\n                _cputype=powerpc\r\n                ;;\r\n            aarch64)\r\n                _cputype=armv7\r\n                if [ \"$_ostype\" = \"linux-android\" ]; then\r\n                    _ostype=linux-androideabi\r\n                else\r\n                    _ostype=\"${_ostype}eabihf\"\r\n                fi\r\n                ;;\r\n            riscv64gc)\r\n                err \"riscv64 with 32-bit userland unsupported\"\r\n                ;;\r\n        esac\r\n    fi\r\n\r\n    # Detect armv7 but without the CPU features Rust needs in that build,\r\n    # and fall back to arm.\r\n    # See https://github.com/rust-lang/rustup.rs/issues/587.\r\n    if [ \"$_ostype\" = \"unknown-linux-gnueabihf\" ] && [ \"$_cputype\" = armv7 ]; then\r\n        if ensure grep '^Features' /proc/cpuinfo | grep -q -v neon; then\r\n            # At least one processor does not have NEON.\r\n            _cputype=arm\r\n        fi\r\n    fi\r\n\r\n    _arch=\"${_cputype}-${_ostype}\"\r\n\r\n    RETVAL=\"$_arch\"\r\n}\r\n\r\nsay() {\r\n    printf 'rustup: %s\\n' \"$1\"\r\n}\r\n\r\nerr() {\r\n    say \"$1\" >&2\r\n    exit 1\r\n}\r\n\r\nneed_cmd() {\r\n    if ! check_cmd \"$1\"; then\r\n        err \"need '$1' (command not found)\"\r\n    fi\r\n}\r\n\r\ncheck_cmd() {\r\n    command -v \"$1\" > /dev/null 2>&1\r\n}\r\n\r\nassert_nz() {\r\n    if [ -z \"$1\" ]; then err \"assert_nz $2\"; fi\r\n}\r\n\r\n# Run a command that should never fail. If the command fails execution\r\n# will immediately terminate with an error showing the failing\r\n# command.\r\nensure() {\r\n    if ! \"$@\"; then err \"command failed: $*\"; fi\r\n}\r\n\r\n# This is just for indicating that commands' results are being\r\n# intentionally ignored. Usually, because it's being executed\r\n# as part of error handling.\r\nignore() {\r\n    \"$@\"\r\n}\r\n\r\n# This wraps curl or wget. Try curl first, if not installed,\r\n# use wget instead.\r\ndownloader() {\r\n    local _dld\r\n    local _ciphersuites\r\n    local _err\r\n    local _status\r\n    local _retry\r\n    if check_cmd curl; then\r\n        _dld=curl\r\n    elif check_cmd wget; then\r\n        _dld=wget\r\n    else\r\n        _dld='curl or wget' # to be used in error message of need_cmd\r\n    fi\r\n\r\n    if [ \"$1\" = --check ]; then\r\n        need_cmd \"$_dld\"\r\n    elif [ \"$_dld\" = curl ]; then\r\n        check_curl_for_retry_support\r\n        _retry=\"$RETVAL\"\r\n        get_ciphersuites_for_curl\r\n        _ciphersuites=\"$RETVAL\"\r\n        if [ -n \"$_ciphersuites\" ]; then\r\n            _err=$(curl $_retry --proto '=https' --tlsv1.2 --ciphers \"$_ciphersuites\" --silent --show-error --fail --location \"$1\" --output \"$2\" 2>&1)\r\n            _status=$?\r\n        else\r\n            echo \"Warning: Not enforcing strong cipher suites for TLS, this is potentially less secure\"\r\n            if ! check_help_for \"$3\" curl --proto --tlsv1.2; then\r\n                echo \"Warning: Not enforcing TLS v1.2, this is potentially less secure\"\r\n                _err=$(curl $_retry --silent --show-error --fail --location \"$1\" --output \"$2\" 2>&1)\r\n                _status=$?\r\n            else\r\n                _err=$(curl $_retry --proto '=https' --tlsv1.2 --silent --show-error --fail --location \"$1\" --output \"$2\" 2>&1)\r\n                _status=$?\r\n            fi\r\n        fi\r\n        if [ -n \"$_err\" ]; then\r\n            echo \"$_err\" >&2\r\n            if echo \"$_err\" | grep -q 404$; then\r\n                err \"installer for platform '$3' not found, this may be unsupported\"\r\n            fi\r\n        fi\r\n        return $_status\r\n    elif [ \"$_dld\" = wget ]; then\r\n        if [ \"$(wget -V 2>&1|head -2|tail -1|cut -f1 -d\" \")\" = \"BusyBox\" ]; then\r\n            echo \"Warning: using the BusyBox version of wget.  Not enforcing strong cipher suites for TLS or TLS v1.2, this is potentially less secure\"\r\n            _err=$(wget \"$1\" -O \"$2\" 2>&1)\r\n            _status=$?\r\n        else\r\n            get_ciphersuites_for_wget\r\n            _ciphersuites=\"$RETVAL\"\r\n            if [ -n \"$_ciphersuites\" ]; then\r\n                _err=$(wget --https-only --secure-protocol=TLSv1_2 --ciphers \"$_ciphersuites\" \"$1\" -O \"$2\" 2>&1)\r\n                _status=$?\r\n            else\r\n                echo \"Warning: Not enforcing strong cipher suites for TLS, this is potentially less secure\"\r\n                if ! check_help_for \"$3\" wget --https-only --secure-protocol; then\r\n                    echo \"Warning: Not enforcing TLS v1.2, this is potentially less secure\"\r\n                    _err=$(wget \"$1\" -O \"$2\" 2>&1)\r\n                    _status=$?\r\n                else\r\n                    _err=$(wget --https-only --secure-protocol=TLSv1_2 \"$1\" -O \"$2\" 2>&1)\r\n                    _status=$?\r\n                fi\r\n            fi\r\n        fi\r\n        if [ -n \"$_err\" ]; then\r\n            echo \"$_err\" >&2\r\n            if echo \"$_err\" | grep -q ' 404 Not Found$'; then\r\n                err \"installer for platform '$3' not found, this may be unsupported\"\r\n            fi\r\n        fi\r\n        return $_status\r\n    else\r\n        err \"Unknown downloader\"   # should not reach here\r\n    fi\r\n}\r\n\r\ncheck_help_for() {\r\n    local _arch\r\n    local _cmd\r\n    local _arg\r\n    _arch=\"$1\"\r\n    shift\r\n    _cmd=\"$1\"\r\n    shift\r\n\r\n    local _category\r\n    if \"$_cmd\" --help | grep -q 'For all options use the manual or \"--help all\".'; then\r\n      _category=\"all\"\r\n    else\r\n      _category=\"\"\r\n    fi\r\n\r\n    case \"$_arch\" in\r\n\r\n        *darwin*)\r\n        if check_cmd sw_vers; then\r\n            case $(sw_vers -productVersion) in\r\n                10.*)\r\n                    # If we're running on macOS, older than 10.13, then we always\r\n                    # fail to find these options to force fallback\r\n                    if [ \"$(sw_vers -productVersion | cut -d. -f2)\" -lt 13 ]; then\r\n                        # Older than 10.13\r\n                        echo \"Warning: Detected macOS platform older than 10.13\"\r\n                        return 1\r\n                    fi\r\n                    ;;\r\n                11.*)\r\n                    # We assume Big Sur will be OK for now\r\n                    ;;\r\n                *)\r\n                    # Unknown product version, warn and continue\r\n                    echo \"Warning: Detected unknown macOS major version: $(sw_vers -productVersion)\"\r\n                    echo \"Warning TLS capabilities detection may fail\"\r\n                    ;;\r\n            esac\r\n        fi\r\n        ;;\r\n\r\n    esac\r\n\r\n    for _arg in \"$@\"; do\r\n        if ! \"$_cmd\" --help $_category | grep -q -- \"$_arg\"; then\r\n            return 1\r\n        fi\r\n    done\r\n\r\n    true # not strictly needed\r\n}\r\n\r\n# Check if curl supports the --retry flag, then pass it to the curl invocation.\r\ncheck_curl_for_retry_support() {\r\n  local _retry_supported=\"\"\r\n  # \"unspecified\" is for arch, allows for possibility old OS using macports, homebrew, etc.\r\n  if check_help_for \"notspecified\" \"curl\" \"--retry\"; then\r\n    _retry_supported=\"--retry 3\"\r\n  fi\r\n\r\n  RETVAL=\"$_retry_supported\"\r\n\r\n}\r\n\r\n# Return cipher suite string specified by user, otherwise return strong TLS 1.2-1.3 cipher suites\r\n# if support by local tools is detected. Detection currently supports these curl backends:\r\n# GnuTLS and OpenSSL (possibly also LibreSSL and BoringSSL). Return value can be empty.\r\nget_ciphersuites_for_curl() {\r\n    if [ -n \"${RUSTUP_TLS_CIPHERSUITES-}\" ]; then\r\n        # user specified custom cipher suites, assume they know what they're doing\r\n        RETVAL=\"$RUSTUP_TLS_CIPHERSUITES\"\r\n        return\r\n    fi\r\n\r\n    local _openssl_syntax=\"no\"\r\n    local _gnutls_syntax=\"no\"\r\n    local _backend_supported=\"yes\"\r\n    if curl -V | grep -q ' OpenSSL/'; then\r\n        _openssl_syntax=\"yes\"\r\n    elif curl -V | grep -iq ' LibreSSL/'; then\r\n        _openssl_syntax=\"yes\"\r\n    elif curl -V | grep -iq ' BoringSSL/'; then\r\n        _openssl_syntax=\"yes\"\r\n    elif curl -V | grep -iq ' GnuTLS/'; then\r\n        _gnutls_syntax=\"yes\"\r\n    else\r\n        _backend_supported=\"no\"\r\n    fi\r\n\r\n    local _args_supported=\"no\"\r\n    if [ \"$_backend_supported\" = \"yes\" ]; then\r\n        # \"unspecified\" is for arch, allows for possibility old OS using macports, homebrew, etc.\r\n        if check_help_for \"notspecified\" \"curl\" \"--tlsv1.2\" \"--ciphers\" \"--proto\"; then\r\n            _args_supported=\"yes\"\r\n        fi\r\n    fi\r\n\r\n    local _cs=\"\"\r\n    if [ \"$_args_supported\" = \"yes\" ]; then\r\n        if [ \"$_openssl_syntax\" = \"yes\" ]; then\r\n            _cs=$(get_strong_ciphersuites_for \"openssl\")\r\n        elif [ \"$_gnutls_syntax\" = \"yes\" ]; then\r\n            _cs=$(get_strong_ciphersuites_for \"gnutls\")\r\n        fi\r\n    fi\r\n\r\n    RETVAL=\"$_cs\"\r\n}\r\n\r\n# Return cipher suite string specified by user, otherwise return strong TLS 1.2-1.3 cipher suites\r\n# if support by local tools is detected. Detection currently supports these wget backends:\r\n# GnuTLS and OpenSSL (possibly also LibreSSL and BoringSSL). Return value can be empty.\r\nget_ciphersuites_for_wget() {\r\n    if [ -n \"${RUSTUP_TLS_CIPHERSUITES-}\" ]; then\r\n        # user specified custom cipher suites, assume they know what they're doing\r\n        RETVAL=\"$RUSTUP_TLS_CIPHERSUITES\"\r\n        return\r\n    fi\r\n\r\n    local _cs=\"\"\r\n    if wget -V | grep -q '\\-DHAVE_LIBSSL'; then\r\n        # \"unspecified\" is for arch, allows for possibility old OS using macports, homebrew, etc.\r\n        if check_help_for \"notspecified\" \"wget\" \"TLSv1_2\" \"--ciphers\" \"--https-only\" \"--secure-protocol\"; then\r\n            _cs=$(get_strong_ciphersuites_for \"openssl\")\r\n        fi\r\n    elif wget -V | grep -q '\\-DHAVE_LIBGNUTLS'; then\r\n        # \"unspecified\" is for arch, allows for possibility old OS using macports, homebrew, etc.\r\n        if check_help_for \"notspecified\" \"wget\" \"TLSv1_2\" \"--ciphers\" \"--https-only\" \"--secure-protocol\"; then\r\n            _cs=$(get_strong_ciphersuites_for \"gnutls\")\r\n        fi\r\n    fi\r\n\r\n    RETVAL=\"$_cs\"\r\n}\r\n\r\n# Return strong TLS 1.2-1.3 cipher suites in OpenSSL or GnuTLS syntax. TLS 1.2\r\n# excludes non-ECDHE and non-AEAD cipher suites. DHE is excluded due to bad\r\n# DH params often found on servers (see RFC 7919). Sequence matches or is\r\n# similar to Firefox 68 ESR with weak cipher suites disabled via about:config.\r\n# $1 must be openssl or gnutls.\r\nget_strong_ciphersuites_for() {\r\n    if [ \"$1\" = \"openssl\" ]; then\r\n        # OpenSSL is forgiving of unknown values, no problems with TLS 1.3 values on versions that don't support it yet.\r\n        echo \"TLS_AES_128_GCM_SHA256:TLS_CHACHA20_POLY1305_SHA256:TLS_AES_256_GCM_SHA384:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384\"\r\n    elif [ \"$1\" = \"gnutls\" ]; then\r\n        # GnuTLS isn't forgiving of unknown values, so this may require a GnuTLS version that supports TLS 1.3 even if wget doesn't.\r\n        # Begin with SECURE128 (and higher) then remove/add to build cipher suites. Produces same 9 cipher suites as OpenSSL but in slightly different order.\r\n        echo \"SECURE128:-VERS-SSL3.0:-VERS-TLS1.0:-VERS-TLS1.1:-VERS-DTLS-ALL:-CIPHER-ALL:-MAC-ALL:-KX-ALL:+AEAD:+ECDHE-ECDSA:+ECDHE-RSA:+AES-128-GCM:+CHACHA20-POLY1305:+AES-256-GCM\"\r\n    fi\r\n}\r\n\r\nmain \"$@\" || exit 1\r\ncurl: (6) Could not resolve host: |\r\ncurl: (6) Could not resolve host: sh", "stdout_lines": ["#!/bin/sh", "# shellcheck shell=dash", "", "# This is just a little script that can be downloaded from the internet to", "# install rustup. It just does platform detection, downloads the installer", "# and runs it.", "", "# It runs on Unix shells like {a,ba,da,k,z}sh. It uses the common `local`", "# extension. Note: Most shells limit `local` to 1 var per line, contra bash.", "", "if [ \"$KSH_VERSION\" = 'Version JM 93t+ 2010-03-05' ]; then", "    # The version of ksh93 that ships with many illumos systems does not", "    # support the \"local\" extension.  Print a message rather than fail in", "    # subtle ways later on:", "    echo 'rustup does not work with this ksh93 version; please try bash!' >&2", "    exit 1", "fi", "", "", "set -u", "", "# If RUSTUP_UPDATE_ROOT is unset or empty, default it.", "RUSTUP_UPDATE_ROOT=\"${RUSTUP_UPDATE_ROOT:-https://static.rust-lang.org/rustup}\"", "", "#XXX: If you change anything here, please make the same changes in setup_mode.rs", "usage() {", "    cat 1>&2 <<EOF", "rustup-init 1.25.1 (48d233f65 2022-07-12)", "The installer for rustup", "", "USAGE:", "    rustup-init [FLAGS] [OPTIONS]", "", "FLAGS:", "    -v, --verbose           Enable verbose output", "    -q, --quiet             Disable progress output", "    -y                      Disable confirmation prompt.", "        --no-modify-path    Don't configure the PATH environment variable", "    -h, --help              Prints help information", "    -V, --version           Prints version information", "", "OPTIONS:", "        --default-host <default-host>              Choose a default host triple", "        --default-toolchain <default-toolchain>    Choose a default toolchain to install", "        --default-toolchain none                   Do not install any toolchains", "        --profile [minimal|default|complete]       Choose a profile", "    -c, --component <components>...                Component name to also install", "    -t, --target <targets>...                      Target name to also install", "EOF", "}", "", "main() {", "    downloader --check", "    need_cmd uname", "    need_cmd mktemp", "    need_cmd chmod", "    need_cmd mkdir", "    need_cmd rm", "    need_cmd rmdir", "", "    get_architecture || return 1", "    local _arch=\"$RETVAL\"", "    assert_nz \"$_arch\" \"arch\"", "", "    local _ext=\"\"", "    case \"$_arch\" in", "        *windows*)", "            _ext=\".exe\"", "            ;;", "    esac", "", "    local _url=\"${RUSTUP_UPDATE_ROOT}/dist/${_arch}/rustup-init${_ext}\"", "", "    local _dir", "    _dir=\"$(ensure mktemp -d)\"", "    local _file=\"${_dir}/rustup-init${_ext}\"", "", "    local _ansi_escapes_are_valid=false", "    if [ -t 2 ]; then", "        if [ \"${TERM+set}\" = 'set' ]; then", "            case \"$TERM\" in", "                xterm*|rxvt*|urxvt*|linux*|vt*)", "                    _ansi_escapes_are_valid=true", "                ;;", "            esac", "        fi", "    fi", "", "    # check if we have to use /dev/tty to prompt the user", "    local need_tty=yes", "    for arg in \"$@\"; do", "        case \"$arg\" in", "            --help)", "                usage", "                exit 0", "                ;;", "            *)", "                OPTIND=1", "                if [ \"${arg%%--*}\" = \"\" ]; then", "                    # Long option (other than --help);", "                    # don't attempt to interpret it.", "                    continue", "                fi", "                while getopts :hy sub_arg \"$arg\"; do", "                    case \"$sub_arg\" in", "                        h)", "                            usage", "                            exit 0", "                            ;;", "                        y)", "                            # user wants to skip the prompt --", "                            # we don't need /dev/tty", "                            need_tty=no", "                            ;;", "                        *)", "                            ;;", "                        esac", "                done", "                ;;", "        esac", "    done", "", "    if $_ansi_escapes_are_valid; then", "        printf \"\\33[1minfo:\\33[0m downloading installer\\n\" 1>&2", "    else", "        printf '%s\\n' 'info: downloading installer' 1>&2", "    fi", "", "    ensure mkdir -p \"$_dir\"", "    ensure downloader \"$_url\" \"$_file\" \"$_arch\"", "    ensure chmod u+x \"$_file\"", "    if [ ! -x \"$_file\" ]; then", "        printf '%s\\n' \"Cannot execute $_file (likely because of mounting /tmp as noexec).\" 1>&2", "        printf '%s\\n' \"Please copy the file to a location where you can execute binaries and run ./rustup-init${_ext}.\" 1>&2", "        exit 1", "    fi", "", "    if [ \"$need_tty\" = \"yes\" ] && [ ! -t 0 ]; then", "        # The installer is going to want to ask for confirmation by", "        # reading stdin.  This script was piped into `sh` though and", "        # doesn't have stdin to pass to its children. Instead we're going", "        # to explicitly connect /dev/tty to the installer's stdin.", "        if [ ! -t 1 ]; then", "            err \"Unable to run interactively. Run with -y to accept defaults, --help for additional options\"", "        fi", "", "        ignore \"$_file\" \"$@\" < /dev/tty", "    else", "        ignore \"$_file\" \"$@\"", "    fi", "", "    local _retval=$?", "", "    ignore rm \"$_file\"", "    ignore rmdir \"$_dir\"", "", "    return \"$_retval\"", "}", "", "check_proc() {", "    # Check for /proc by looking for the /proc/self/exe link", "    # This is only run on Linux", "    if ! test -L /proc/self/exe ; then", "        err \"fatal: Unable to find /proc/self/exe.  Is /proc mounted?  Installation cannot proceed without /proc.\"", "    fi", "}", "", "get_bitness() {", "    need_cmd head", "    # Architecture detection without dependencies beyond coreutils.", "    # ELF files start out \"\\x7fELF\", and the following byte is", "    #   0x01 for 32-bit and", "    #   0x02 for 64-bit.", "    # The printf builtin on some shells like dash only supports octal", "    # escape sequences, so we use those.", "    local _current_exe_head", "    _current_exe_head=$(head -c 5 /proc/self/exe )", "    if [ \"$_current_exe_head\" = \"$(printf '\\177ELF\\001')\" ]; then", "        echo 32", "    elif [ \"$_current_exe_head\" = \"$(printf '\\177ELF\\002')\" ]; then", "        echo 64", "    else", "        err \"unknown platform bitness\"", "    fi", "}", "", "is_host_amd64_elf() {", "    need_cmd head", "    need_cmd tail", "    # ELF e_machine detection without dependencies beyond coreutils.", "    # Two-byte field at offset 0x12 indicates the CPU,", "    # but we're interested in it being 0x3E to indicate amd64, or not that.", "    local _current_exe_machine", "    _current_exe_machine=$(head -c 19 /proc/self/exe | tail -c 1)", "    [ \"$_current_exe_machine\" = \"$(printf '\\076')\" ]", "}", "", "get_endianness() {", "    local cputype=$1", "    local suffix_eb=$2", "    local suffix_el=$3", "", "    # detect endianness without od/hexdump, like get_bitness() does.", "    need_cmd head", "    need_cmd tail", "", "    local _current_exe_endianness", "    _current_exe_endianness=\"$(head -c 6 /proc/self/exe | tail -c 1)\"", "    if [ \"$_current_exe_endianness\" = \"$(printf '\\001')\" ]; then", "        echo \"${cputype}${suffix_el}\"", "    elif [ \"$_current_exe_endianness\" = \"$(printf '\\002')\" ]; then", "        echo \"${cputype}${suffix_eb}\"", "    else", "        err \"unknown platform endianness\"", "    fi", "}", "", "get_architecture() {", "    local _ostype _cputype _bitness _arch _clibtype", "    _ostype=\"$(uname -s)\"", "    _cputype=\"$(uname -m)\"", "    _clibtype=\"gnu\"", "", "    if [ \"$_ostype\" = Linux ]; then", "        if [ \"$(uname -o)\" = Android ]; then", "            _ostype=Android", "        fi", "        if ldd --version 2>&1 | grep -q 'musl'; then", "            _clibtype=\"musl\"", "        fi", "    fi", "", "    if [ \"$_ostype\" = Darwin ] && [ \"$_cputype\" = i386 ]; then", "        # Darwin `uname -m` lies", "        if sysctl hw.optional.x86_64 | grep -q ': 1'; then", "            _cputype=x86_64", "        fi", "    fi", "", "    if [ \"$_ostype\" = SunOS ]; then", "        # Both Solaris and illumos presently announce as \"SunOS\" in \"uname -s\"", "        # so use \"uname -o\" to disambiguate.  We use the full path to the", "        # system uname in case the user has coreutils uname first in PATH,", "        # which has historically sometimes printed the wrong value here.", "        if [ \"$(/usr/bin/uname -o)\" = illumos ]; then", "            _ostype=illumos", "        fi", "", "        # illumos systems have multi-arch userlands, and \"uname -m\" reports the", "        # machine hardware name; e.g., \"i86pc\" on both 32- and 64-bit x86", "        # systems.  Check for the native (widest) instruction set on the", "        # running kernel:", "        if [ \"$_cputype\" = i86pc ]; then", "            _cputype=\"$(isainfo -n)\"", "        fi", "    fi", "", "    case \"$_ostype\" in", "", "        Android)", "            _ostype=linux-android", "            ;;", "", "        Linux)", "            check_proc", "            _ostype=unknown-linux-$_clibtype", "            _bitness=$(get_bitness)", "            ;;", "", "        FreeBSD)", "            _ostype=unknown-freebsd", "            ;;", "", "        NetBSD)", "            _ostype=unknown-netbsd", "            ;;", "", "        DragonFly)", "            _ostype=unknown-dragonfly", "            ;;", "", "        Darwin)", "            _ostype=apple-darwin", "            ;;", "", "        illumos)", "            _ostype=unknown-illumos", "            ;;", "", "        MINGW* | MSYS* | CYGWIN* | Windows_NT)", "            _ostype=pc-windows-gnu", "            ;;", "", "        *)", "            err \"unrecognized OS type: $_ostype\"", "            ;;", "", "    esac", "", "    case \"$_cputype\" in", "", "        i386 | i486 | i686 | i786 | x86)", "            _cputype=i686", "            ;;", "", "        xscale | arm)", "            _cputype=arm", "            if [ \"$_ostype\" = \"linux-android\" ]; then", "                _ostype=linux-androideabi", "            fi", "            ;;", "", "        armv6l)", "            _cputype=arm", "            if [ \"$_ostype\" = \"linux-android\" ]; then", "                _ostype=linux-androideabi", "            else", "                _ostype=\"${_ostype}eabihf\"", "            fi", "            ;;", "", "        armv7l | armv8l)", "            _cputype=armv7", "            if [ \"$_ostype\" = \"linux-android\" ]; then", "                _ostype=linux-androideabi", "            else", "                _ostype=\"${_ostype}eabihf\"", "            fi", "            ;;", "", "        aarch64 | arm64)", "            _cputype=aarch64", "            ;;", "", "        x86_64 | x86-64 | x64 | amd64)", "            _cputype=x86_64", "            ;;", "", "        mips)", "            _cputype=$(get_endianness mips '' el)", "            ;;", "", "        mips64)", "            if [ \"$_bitness\" -eq 64 ]; then", "                # only n64 ABI is supported for now", "                _ostype=\"${_ostype}abi64\"", "                _cputype=$(get_endianness mips64 '' el)", "            fi", "            ;;", "", "        ppc)", "            _cputype=powerpc", "            ;;", "", "        ppc64)", "            _cputype=powerpc64", "            ;;", "", "        ppc64le)", "            _cputype=powerpc64le", "            ;;", "", "        s390x)", "            _cputype=s390x", "            ;;", "        riscv64)", "            _cputype=riscv64gc", "            ;;", "        *)", "            err \"unknown CPU type: $_cputype\"", "", "    esac", "", "    # Detect 64-bit linux with 32-bit userland", "    if [ \"${_ostype}\" = unknown-linux-gnu ] && [ \"${_bitness}\" -eq 32 ]; then", "        case $_cputype in", "            x86_64)", "                if [ -n \"${RUSTUP_CPUTYPE:-}\" ]; then", "                    _cputype=\"$RUSTUP_CPUTYPE\"", "                else {", "                    # 32-bit executable for amd64 = x32", "                    if is_host_amd64_elf; then {", "                         echo \"This host is running an x32 userland; as it stands, x32 support is poor,\" 1>&2", "                         echo \"and there isn't a native toolchain -- you will have to install\" 1>&2", "                         echo \"multiarch compatibility with i686 and/or amd64, then select one\" 1>&2", "                         echo \"by re-running this script with the RUSTUP_CPUTYPE environment variable\" 1>&2", "                         echo \"set to i686 or x86_64, respectively.\" 1>&2", "                         echo 1>&2", "                         echo \"You will be able to add an x32 target after installation by running\" 1>&2", "                         echo \"  rustup target add x86_64-unknown-linux-gnux32\" 1>&2", "                         exit 1", "                    }; else", "                        _cputype=i686", "                    fi", "                }; fi", "                ;;", "            mips64)", "                _cputype=$(get_endianness mips '' el)", "                ;;", "            powerpc64)", "                _cputype=powerpc", "                ;;", "            aarch64)", "                _cputype=armv7", "                if [ \"$_ostype\" = \"linux-android\" ]; then", "                    _ostype=linux-androideabi", "                else", "                    _ostype=\"${_ostype}eabihf\"", "                fi", "                ;;", "            riscv64gc)", "                err \"riscv64 with 32-bit userland unsupported\"", "                ;;", "        esac", "    fi", "", "    # Detect armv7 but without the CPU features Rust needs in that build,", "    # and fall back to arm.", "    # See https://github.com/rust-lang/rustup.rs/issues/587.", "    if [ \"$_ostype\" = \"unknown-linux-gnueabihf\" ] && [ \"$_cputype\" = armv7 ]; then", "        if ensure grep '^Features' /proc/cpuinfo | grep -q -v neon; then", "            # At least one processor does not have NEON.", "            _cputype=arm", "        fi", "    fi", "", "    _arch=\"${_cputype}-${_ostype}\"", "", "    RETVAL=\"$_arch\"", "}", "", "say() {", "    printf 'rustup: %s\\n' \"$1\"", "}", "", "err() {", "    say \"$1\" >&2", "    exit 1", "}", "", "need_cmd() {", "    if ! check_cmd \"$1\"; then", "        err \"need '$1' (command not found)\"", "    fi", "}", "", "check_cmd() {", "    command -v \"$1\" > /dev/null 2>&1", "}", "", "assert_nz() {", "    if [ -z \"$1\" ]; then err \"assert_nz $2\"; fi", "}", "", "# Run a command that should never fail. If the command fails execution", "# will immediately terminate with an error showing the failing", "# command.", "ensure() {", "    if ! \"$@\"; then err \"command failed: $*\"; fi", "}", "", "# This is just for indicating that commands' results are being", "# intentionally ignored. Usually, because it's being executed", "# as part of error handling.", "ignore() {", "    \"$@\"", "}", "", "# This wraps curl or wget. Try curl first, if not installed,", "# use wget instead.", "downloader() {", "    local _dld", "    local _ciphersuites", "    local _err", "    local _status", "    local _retry", "    if check_cmd curl; then", "        _dld=curl", "    elif check_cmd wget; then", "        _dld=wget", "    else", "        _dld='curl or wget' # to be used in error message of need_cmd", "    fi", "", "    if [ \"$1\" = --check ]; then", "        need_cmd \"$_dld\"", "    elif [ \"$_dld\" = curl ]; then", "        check_curl_for_retry_support", "        _retry=\"$RETVAL\"", "        get_ciphersuites_for_curl", "        _ciphersuites=\"$RETVAL\"", "        if [ -n \"$_ciphersuites\" ]; then", "            _err=$(curl $_retry --proto '=https' --tlsv1.2 --ciphers \"$_ciphersuites\" --silent --show-error --fail --location \"$1\" --output \"$2\" 2>&1)", "            _status=$?", "        else", "            echo \"Warning: Not enforcing strong cipher suites for TLS, this is potentially less secure\"", "            if ! check_help_for \"$3\" curl --proto --tlsv1.2; then", "                echo \"Warning: Not enforcing TLS v1.2, this is potentially less secure\"", "                _err=$(curl $_retry --silent --show-error --fail --location \"$1\" --output \"$2\" 2>&1)", "                _status=$?", "            else", "                _err=$(curl $_retry --proto '=https' --tlsv1.2 --silent --show-error --fail --location \"$1\" --output \"$2\" 2>&1)", "                _status=$?", "            fi", "        fi", "        if [ -n \"$_err\" ]; then", "            echo \"$_err\" >&2", "            if echo \"$_err\" | grep -q 404$; then", "                err \"installer for platform '$3' not found, this may be unsupported\"", "            fi", "        fi", "        return $_status", "    elif [ \"$_dld\" = wget ]; then", "        if [ \"$(wget -V 2>&1|head -2|tail -1|cut -f1 -d\" \")\" = \"BusyBox\" ]; then", "            echo \"Warning: using the BusyBox version of wget.  Not enforcing strong cipher suites for TLS or TLS v1.2, this is potentially less secure\"", "            _err=$(wget \"$1\" -O \"$2\" 2>&1)", "            _status=$?", "        else", "            get_ciphersuites_for_wget", "            _ciphersuites=\"$RETVAL\"", "            if [ -n \"$_ciphersuites\" ]; then", "                _err=$(wget --https-only --secure-protocol=TLSv1_2 --ciphers \"$_ciphersuites\" \"$1\" -O \"$2\" 2>&1)", "                _status=$?", "            else", "                echo \"Warning: Not enforcing strong cipher suites for TLS, this is potentially less secure\"", "                if ! check_help_for \"$3\" wget --https-only --secure-protocol; then", "                    echo \"Warning: Not enforcing TLS v1.2, this is potentially less secure\"", "                    _err=$(wget \"$1\" -O \"$2\" 2>&1)", "                    _status=$?", "                else", "                    _err=$(wget --https-only --secure-protocol=TLSv1_2 \"$1\" -O \"$2\" 2>&1)", "                    _status=$?", "                fi", "            fi", "        fi", "        if [ -n \"$_err\" ]; then", "            echo \"$_err\" >&2", "            if echo \"$_err\" | grep -q ' 404 Not Found$'; then", "                err \"installer for platform '$3' not found, this may be unsupported\"", "            fi", "        fi", "        return $_status", "    else", "        err \"Unknown downloader\"   # should not reach here", "    fi", "}", "", "check_help_for() {", "    local _arch", "    local _cmd", "    local _arg", "    _arch=\"$1\"", "    shift", "    _cmd=\"$1\"", "    shift", "", "    local _category", "    if \"$_cmd\" --help | grep -q 'For all options use the manual or \"--help all\".'; then", "      _category=\"all\"", "    else", "      _category=\"\"", "    fi", "", "    case \"$_arch\" in", "", "        *darwin*)", "        if check_cmd sw_vers; then", "            case $(sw_vers -productVersion) in", "                10.*)", "                    # If we're running on macOS, older than 10.13, then we always", "                    # fail to find these options to force fallback", "                    if [ \"$(sw_vers -productVersion | cut -d. -f2)\" -lt 13 ]; then", "                        # Older than 10.13", "                        echo \"Warning: Detected macOS platform older than 10.13\"", "                        return 1", "                    fi", "                    ;;", "                11.*)", "                    # We assume Big Sur will be OK for now", "                    ;;", "                *)", "                    # Unknown product version, warn and continue", "                    echo \"Warning: Detected unknown macOS major version: $(sw_vers -productVersion)\"", "                    echo \"Warning TLS capabilities detection may fail\"", "                    ;;", "            esac", "        fi", "        ;;", "", "    esac", "", "    for _arg in \"$@\"; do", "        if ! \"$_cmd\" --help $_category | grep -q -- \"$_arg\"; then", "            return 1", "        fi", "    done", "", "    true # not strictly needed", "}", "", "# Check if curl supports the --retry flag, then pass it to the curl invocation.", "check_curl_for_retry_support() {", "  local _retry_supported=\"\"", "  # \"unspecified\" is for arch, allows for possibility old OS using macports, homebrew, etc.", "  if check_help_for \"notspecified\" \"curl\" \"--retry\"; then", "    _retry_supported=\"--retry 3\"", "  fi", "", "  RETVAL=\"$_retry_supported\"", "", "}", "", "# Return cipher suite string specified by user, otherwise return strong TLS 1.2-1.3 cipher suites", "# if support by local tools is detected. Detection currently supports these curl backends:", "# GnuTLS and OpenSSL (possibly also LibreSSL and BoringSSL). Return value can be empty.", "get_ciphersuites_for_curl() {", "    if [ -n \"${RUSTUP_TLS_CIPHERSUITES-}\" ]; then", "        # user specified custom cipher suites, assume they know what they're doing", "        RETVAL=\"$RUSTUP_TLS_CIPHERSUITES\"", "        return", "    fi", "", "    local _openssl_syntax=\"no\"", "    local _gnutls_syntax=\"no\"", "    local _backend_supported=\"yes\"", "    if curl -V | grep -q ' OpenSSL/'; then", "        _openssl_syntax=\"yes\"", "    elif curl -V | grep -iq ' LibreSSL/'; then", "        _openssl_syntax=\"yes\"", "    elif curl -V | grep -iq ' BoringSSL/'; then", "        _openssl_syntax=\"yes\"", "    elif curl -V | grep -iq ' GnuTLS/'; then", "        _gnutls_syntax=\"yes\"", "    else", "        _backend_supported=\"no\"", "    fi", "", "    local _args_supported=\"no\"", "    if [ \"$_backend_supported\" = \"yes\" ]; then", "        # \"unspecified\" is for arch, allows for possibility old OS using macports, homebrew, etc.", "        if check_help_for \"notspecified\" \"curl\" \"--tlsv1.2\" \"--ciphers\" \"--proto\"; then", "            _args_supported=\"yes\"", "        fi", "    fi", "", "    local _cs=\"\"", "    if [ \"$_args_supported\" = \"yes\" ]; then", "        if [ \"$_openssl_syntax\" = \"yes\" ]; then", "            _cs=$(get_strong_ciphersuites_for \"openssl\")", "        elif [ \"$_gnutls_syntax\" = \"yes\" ]; then", "            _cs=$(get_strong_ciphersuites_for \"gnutls\")", "        fi", "    fi", "", "    RETVAL=\"$_cs\"", "}", "", "# Return cipher suite string specified by user, otherwise return strong TLS 1.2-1.3 cipher suites", "# if support by local tools is detected. Detection currently supports these wget backends:", "# GnuTLS and OpenSSL (possibly also LibreSSL and BoringSSL). Return value can be empty.", "get_ciphersuites_for_wget() {", "    if [ -n \"${RUSTUP_TLS_CIPHERSUITES-}\" ]; then", "        # user specified custom cipher suites, assume they know what they're doing", "        RETVAL=\"$RUSTUP_TLS_CIPHERSUITES\"", "        return", "    fi", "", "    local _cs=\"\"", "    if wget -V | grep -q '\\-DHAVE_LIBSSL'; then", "        # \"unspecified\" is for arch, allows for possibility old OS using macports, homebrew, etc.", "        if check_help_for \"notspecified\" \"wget\" \"TLSv1_2\" \"--ciphers\" \"--https-only\" \"--secure-protocol\"; then", "            _cs=$(get_strong_ciphersuites_for \"openssl\")", "        fi", "    elif wget -V | grep -q '\\-DHAVE_LIBGNUTLS'; then", "        # \"unspecified\" is for arch, allows for possibility old OS using macports, homebrew, etc.", "        if check_help_for \"notspecified\" \"wget\" \"TLSv1_2\" \"--ciphers\" \"--https-only\" \"--secure-protocol\"; then", "            _cs=$(get_strong_ciphersuites_for \"gnutls\")", "        fi", "    fi", "", "    RETVAL=\"$_cs\"", "}", "", "# Return strong TLS 1.2-1.3 cipher suites in OpenSSL or GnuTLS syntax. TLS 1.2", "# excludes non-ECDHE and non-AEAD cipher suites. DHE is excluded due to bad", "# DH params often found on servers (see RFC 7919). Sequence matches or is", "# similar to Firefox 68 ESR with weak cipher suites disabled via about:config.", "# $1 must be openssl or gnutls.", "get_strong_ciphersuites_for() {", "    if [ \"$1\" = \"openssl\" ]; then", "        # OpenSSL is forgiving of unknown values, no problems with TLS 1.3 values on versions that don't support it yet.", "        echo \"TLS_AES_128_GCM_SHA256:TLS_CHACHA20_POLY1305_SHA256:TLS_AES_256_GCM_SHA384:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384\"", "    elif [ \"$1\" = \"gnutls\" ]; then", "        # GnuTLS isn't forgiving of unknown values, so this may require a GnuTLS version that supports TLS 1.3 even if wget doesn't.", "        # Begin with SECURE128 (and higher) then remove/add to build cipher suites. Produces same 9 cipher suites as OpenSSL but in slightly different order.", "        echo \"SECURE128:-VERS-SSL3.0:-VERS-TLS1.0:-VERS-TLS1.1:-VERS-DTLS-ALL:-CIPHER-ALL:-MAC-ALL:-KX-ALL:+AEAD:+ECDHE-ECDSA:+ECDHE-RSA:+AES-128-GCM:+CHACHA20-POLY1305:+AES-256-GCM\"", "    fi", "}", "", "main \"$@\" || exit 1", "curl: (6) Could not resolve host: |", "curl: (6) Could not resolve host: sh"]}
2022-12-30 00:11:00,611 p=90511 u=kal n=ansible | PLAY RECAP *******************************************************************************************************************************************
2022-12-30 00:11:00,611 p=90511 u=kal n=ansible | krpz                       : ok=3    changed=0    unreachable=0    failed=1    skipped=0    rescued=0    ignored=0   
2022-12-30 00:11:28,292 p=90761 u=kal n=ansible | PLAY [localhost] *************************************************************************************************************************************
2022-12-30 00:11:28,299 p=90761 u=kal n=ansible | TASK [Gathering Facts] *******************************************************************************************************************************
2022-12-30 00:11:32,319 p=90761 u=kal n=ansible | ok: [krpz]
2022-12-30 00:11:32,340 p=90761 u=kal n=ansible | TASK [install pexpect] *******************************************************************************************************************************
2022-12-30 00:11:32,770 p=90761 u=kal n=ansible | ok: [krpz]
2022-12-30 00:11:32,778 p=90761 u=kal n=ansible | TASK [install setuptools] ****************************************************************************************************************************
2022-12-30 00:11:33,120 p=90761 u=kal n=ansible | ok: [krpz]
2022-12-30 00:11:33,128 p=90761 u=kal n=ansible | TASK [Install Rust] **********************************************************************************************************************************
2022-12-30 00:11:35,250 p=90761 u=kal n=ansible | fatal: [krpz]: FAILED! => {"changed": true, "cmd": "curl https://sh.rustup.rs | sh", "delta": "0:00:01.906684", "end": "2022-12-30 00:11:35.197091", "msg": "non-zero return code", "rc": 6, "start": "2022-12-30 00:11:33.290407", "stdout": "#!/bin/sh\r\n# shellcheck shell=dash\r\n\r\n# This is just a little script that can be downloaded from the internet to\r\n# install rustup. It just does platform detection, downloads the installer\r\n# and runs it.\r\n\r\n# It runs on Unix shells like {a,ba,da,k,z}sh. It uses the common `local`\r\n# extension. Note: Most shells limit `local` to 1 var per line, contra bash.\r\n\r\nif [ \"$KSH_VERSION\" = 'Version JM 93t+ 2010-03-05' ]; then\r\n    # The version of ksh93 that ships with many illumos systems does not\r\n    # support the \"local\" extension.  Print a message rather than fail in\r\n    # subtle ways later on:\r\n    echo 'rustup does not work with this ksh93 version; please try bash!' >&2\r\n    exit 1\r\nfi\r\n\r\n\r\nset -u\r\n\r\n# If RUSTUP_UPDATE_ROOT is unset or empty, default it.\r\nRUSTUP_UPDATE_ROOT=\"${RUSTUP_UPDATE_ROOT:-https://static.rust-lang.org/rustup}\"\r\n\r\n#XXX: If you change anything here, please make the same changes in setup_mode.rs\r\nusage() {\r\n    cat 1>&2 <<EOF\r\nrustup-init 1.25.1 (48d233f65 2022-07-12)\r\nThe installer for rustup\r\n\r\nUSAGE:\r\n    rustup-init [FLAGS] [OPTIONS]\r\n\r\nFLAGS:\r\n    -v, --verbose           Enable verbose output\r\n    -q, --quiet             Disable progress output\r\n    -y                      Disable confirmation prompt.\r\n        --no-modify-path    Don't configure the PATH environment variable\r\n    -h, --help              Prints help information\r\n    -V, --version           Prints version information\r\n\r\nOPTIONS:\r\n        --default-host <default-host>              Choose a default host triple\r\n        --default-toolchain <default-toolchain>    Choose a default toolchain to install\r\n        --default-toolchain none                   Do not install any toolchains\r\n        --profile [minimal|default|complete]       Choose a profile\r\n    -c, --component <components>...                Component name to also install\r\n    -t, --target <targets>...                      Target name to also install\r\nEOF\r\n}\r\n\r\nmain() {\r\n    downloader --check\r\n    need_cmd uname\r\n    need_cmd mktemp\r\n    need_cmd chmod\r\n    need_cmd mkdir\r\n    need_cmd rm\r\n    need_cmd rmdir\r\n\r\n    get_architecture || return 1\r\n    local _arch=\"$RETVAL\"\r\n    assert_nz \"$_arch\" \"arch\"\r\n\r\n    local _ext=\"\"\r\n    case \"$_arch\" in\r\n        *windows*)\r\n            _ext=\".exe\"\r\n            ;;\r\n    esac\r\n\r\n    local _url=\"${RUSTUP_UPDATE_ROOT}/dist/${_arch}/rustup-init${_ext}\"\r\n\r\n    local _dir\r\n    _dir=\"$(ensure mktemp -d)\"\r\n    local _file=\"${_dir}/rustup-init${_ext}\"\r\n\r\n    local _ansi_escapes_are_valid=false\r\n    if [ -t 2 ]; then\r\n        if [ \"${TERM+set}\" = 'set' ]; then\r\n            case \"$TERM\" in\r\n                xterm*|rxvt*|urxvt*|linux*|vt*)\r\n                    _ansi_escapes_are_valid=true\r\n                ;;\r\n            esac\r\n        fi\r\n    fi\r\n\r\n    # check if we have to use /dev/tty to prompt the user\r\n    local need_tty=yes\r\n    for arg in \"$@\"; do\r\n        case \"$arg\" in\r\n            --help)\r\n                usage\r\n                exit 0\r\n                ;;\r\n            *)\r\n                OPTIND=1\r\n                if [ \"${arg%%--*}\" = \"\" ]; then\r\n                    # Long option (other than --help);\r\n                    # don't attempt to interpret it.\r\n                    continue\r\n                fi\r\n                while getopts :hy sub_arg \"$arg\"; do\r\n                    case \"$sub_arg\" in\r\n                        h)\r\n                            usage\r\n                            exit 0\r\n                            ;;\r\n                        y)\r\n                            # user wants to skip the prompt --\r\n                            # we don't need /dev/tty\r\n                            need_tty=no\r\n                            ;;\r\n                        *)\r\n                            ;;\r\n                        esac\r\n                done\r\n                ;;\r\n        esac\r\n    done\r\n\r\n    if $_ansi_escapes_are_valid; then\r\n        printf \"\\33[1minfo:\\33[0m downloading installer\\n\" 1>&2\r\n    else\r\n        printf '%s\\n' 'info: downloading installer' 1>&2\r\n    fi\r\n\r\n    ensure mkdir -p \"$_dir\"\r\n    ensure downloader \"$_url\" \"$_file\" \"$_arch\"\r\n    ensure chmod u+x \"$_file\"\r\n    if [ ! -x \"$_file\" ]; then\r\n        printf '%s\\n' \"Cannot execute $_file (likely because of mounting /tmp as noexec).\" 1>&2\r\n        printf '%s\\n' \"Please copy the file to a location where you can execute binaries and run ./rustup-init${_ext}.\" 1>&2\r\n        exit 1\r\n    fi\r\n\r\n    if [ \"$need_tty\" = \"yes\" ] && [ ! -t 0 ]; then\r\n        # The installer is going to want to ask for confirmation by\r\n        # reading stdin.  This script was piped into `sh` though and\r\n        # doesn't have stdin to pass to its children. Instead we're going\r\n        # to explicitly connect /dev/tty to the installer's stdin.\r\n        if [ ! -t 1 ]; then\r\n            err \"Unable to run interactively. Run with -y to accept defaults, --help for additional options\"\r\n        fi\r\n\r\n        ignore \"$_file\" \"$@\" < /dev/tty\r\n    else\r\n        ignore \"$_file\" \"$@\"\r\n    fi\r\n\r\n    local _retval=$?\r\n\r\n    ignore rm \"$_file\"\r\n    ignore rmdir \"$_dir\"\r\n\r\n    return \"$_retval\"\r\n}\r\n\r\ncheck_proc() {\r\n    # Check for /proc by looking for the /proc/self/exe link\r\n    # This is only run on Linux\r\n    if ! test -L /proc/self/exe ; then\r\n        err \"fatal: Unable to find /proc/self/exe.  Is /proc mounted?  Installation cannot proceed without /proc.\"\r\n    fi\r\n}\r\n\r\nget_bitness() {\r\n    need_cmd head\r\n    # Architecture detection without dependencies beyond coreutils.\r\n    # ELF files start out \"\\x7fELF\", and the following byte is\r\n    #   0x01 for 32-bit and\r\n    #   0x02 for 64-bit.\r\n    # The printf builtin on some shells like dash only supports octal\r\n    # escape sequences, so we use those.\r\n    local _current_exe_head\r\n    _current_exe_head=$(head -c 5 /proc/self/exe )\r\n    if [ \"$_current_exe_head\" = \"$(printf '\\177ELF\\001')\" ]; then\r\n        echo 32\r\n    elif [ \"$_current_exe_head\" = \"$(printf '\\177ELF\\002')\" ]; then\r\n        echo 64\r\n    else\r\n        err \"unknown platform bitness\"\r\n    fi\r\n}\r\n\r\nis_host_amd64_elf() {\r\n    need_cmd head\r\n    need_cmd tail\r\n    # ELF e_machine detection without dependencies beyond coreutils.\r\n    # Two-byte field at offset 0x12 indicates the CPU,\r\n    # but we're interested in it being 0x3E to indicate amd64, or not that.\r\n    local _current_exe_machine\r\n    _current_exe_machine=$(head -c 19 /proc/self/exe | tail -c 1)\r\n    [ \"$_current_exe_machine\" = \"$(printf '\\076')\" ]\r\n}\r\n\r\nget_endianness() {\r\n    local cputype=$1\r\n    local suffix_eb=$2\r\n    local suffix_el=$3\r\n\r\n    # detect endianness without od/hexdump, like get_bitness() does.\r\n    need_cmd head\r\n    need_cmd tail\r\n\r\n    local _current_exe_endianness\r\n    _current_exe_endianness=\"$(head -c 6 /proc/self/exe | tail -c 1)\"\r\n    if [ \"$_current_exe_endianness\" = \"$(printf '\\001')\" ]; then\r\n        echo \"${cputype}${suffix_el}\"\r\n    elif [ \"$_current_exe_endianness\" = \"$(printf '\\002')\" ]; then\r\n        echo \"${cputype}${suffix_eb}\"\r\n    else\r\n        err \"unknown platform endianness\"\r\n    fi\r\n}\r\n\r\nget_architecture() {\r\n    local _ostype _cputype _bitness _arch _clibtype\r\n    _ostype=\"$(uname -s)\"\r\n    _cputype=\"$(uname -m)\"\r\n    _clibtype=\"gnu\"\r\n\r\n    if [ \"$_ostype\" = Linux ]; then\r\n        if [ \"$(uname -o)\" = Android ]; then\r\n            _ostype=Android\r\n        fi\r\n        if ldd --version 2>&1 | grep -q 'musl'; then\r\n            _clibtype=\"musl\"\r\n        fi\r\n    fi\r\n\r\n    if [ \"$_ostype\" = Darwin ] && [ \"$_cputype\" = i386 ]; then\r\n        # Darwin `uname -m` lies\r\n        if sysctl hw.optional.x86_64 | grep -q ': 1'; then\r\n            _cputype=x86_64\r\n        fi\r\n    fi\r\n\r\n    if [ \"$_ostype\" = SunOS ]; then\r\n        # Both Solaris and illumos presently announce as \"SunOS\" in \"uname -s\"\r\n        # so use \"uname -o\" to disambiguate.  We use the full path to the\r\n        # system uname in case the user has coreutils uname first in PATH,\r\n        # which has historically sometimes printed the wrong value here.\r\n        if [ \"$(/usr/bin/uname -o)\" = illumos ]; then\r\n            _ostype=illumos\r\n        fi\r\n\r\n        # illumos systems have multi-arch userlands, and \"uname -m\" reports the\r\n        # machine hardware name; e.g., \"i86pc\" on both 32- and 64-bit x86\r\n        # systems.  Check for the native (widest) instruction set on the\r\n        # running kernel:\r\n        if [ \"$_cputype\" = i86pc ]; then\r\n            _cputype=\"$(isainfo -n)\"\r\n        fi\r\n    fi\r\n\r\n    case \"$_ostype\" in\r\n\r\n        Android)\r\n            _ostype=linux-android\r\n            ;;\r\n\r\n        Linux)\r\n            check_proc\r\n            _ostype=unknown-linux-$_clibtype\r\n            _bitness=$(get_bitness)\r\n            ;;\r\n\r\n        FreeBSD)\r\n            _ostype=unknown-freebsd\r\n            ;;\r\n\r\n        NetBSD)\r\n            _ostype=unknown-netbsd\r\n            ;;\r\n\r\n        DragonFly)\r\n            _ostype=unknown-dragonfly\r\n            ;;\r\n\r\n        Darwin)\r\n            _ostype=apple-darwin\r\n            ;;\r\n\r\n        illumos)\r\n            _ostype=unknown-illumos\r\n            ;;\r\n\r\n        MINGW* | MSYS* | CYGWIN* | Windows_NT)\r\n            _ostype=pc-windows-gnu\r\n            ;;\r\n\r\n        *)\r\n            err \"unrecognized OS type: $_ostype\"\r\n            ;;\r\n\r\n    esac\r\n\r\n    case \"$_cputype\" in\r\n\r\n        i386 | i486 | i686 | i786 | x86)\r\n            _cputype=i686\r\n            ;;\r\n\r\n        xscale | arm)\r\n            _cputype=arm\r\n            if [ \"$_ostype\" = \"linux-android\" ]; then\r\n                _ostype=linux-androideabi\r\n            fi\r\n            ;;\r\n\r\n        armv6l)\r\n            _cputype=arm\r\n            if [ \"$_ostype\" = \"linux-android\" ]; then\r\n                _ostype=linux-androideabi\r\n            else\r\n                _ostype=\"${_ostype}eabihf\"\r\n            fi\r\n            ;;\r\n\r\n        armv7l | armv8l)\r\n            _cputype=armv7\r\n            if [ \"$_ostype\" = \"linux-android\" ]; then\r\n                _ostype=linux-androideabi\r\n            else\r\n                _ostype=\"${_ostype}eabihf\"\r\n            fi\r\n            ;;\r\n\r\n        aarch64 | arm64)\r\n            _cputype=aarch64\r\n            ;;\r\n\r\n        x86_64 | x86-64 | x64 | amd64)\r\n            _cputype=x86_64\r\n            ;;\r\n\r\n        mips)\r\n            _cputype=$(get_endianness mips '' el)\r\n            ;;\r\n\r\n        mips64)\r\n            if [ \"$_bitness\" -eq 64 ]; then\r\n                # only n64 ABI is supported for now\r\n                _ostype=\"${_ostype}abi64\"\r\n                _cputype=$(get_endianness mips64 '' el)\r\n            fi\r\n            ;;\r\n\r\n        ppc)\r\n            _cputype=powerpc\r\n            ;;\r\n\r\n        ppc64)\r\n            _cputype=powerpc64\r\n            ;;\r\n\r\n        ppc64le)\r\n            _cputype=powerpc64le\r\n            ;;\r\n\r\n        s390x)\r\n            _cputype=s390x\r\n            ;;\r\n        riscv64)\r\n            _cputype=riscv64gc\r\n            ;;\r\n        *)\r\n            err \"unknown CPU type: $_cputype\"\r\n\r\n    esac\r\n\r\n    # Detect 64-bit linux with 32-bit userland\r\n    if [ \"${_ostype}\" = unknown-linux-gnu ] && [ \"${_bitness}\" -eq 32 ]; then\r\n        case $_cputype in\r\n            x86_64)\r\n                if [ -n \"${RUSTUP_CPUTYPE:-}\" ]; then\r\n                    _cputype=\"$RUSTUP_CPUTYPE\"\r\n                else {\r\n                    # 32-bit executable for amd64 = x32\r\n                    if is_host_amd64_elf; then {\r\n                         echo \"This host is running an x32 userland; as it stands, x32 support is poor,\" 1>&2\r\n                         echo \"and there isn't a native toolchain -- you will have to install\" 1>&2\r\n                         echo \"multiarch compatibility with i686 and/or amd64, then select one\" 1>&2\r\n                         echo \"by re-running this script with the RUSTUP_CPUTYPE environment variable\" 1>&2\r\n                         echo \"set to i686 or x86_64, respectively.\" 1>&2\r\n                         echo 1>&2\r\n                         echo \"You will be able to add an x32 target after installation by running\" 1>&2\r\n                         echo \"  rustup target add x86_64-unknown-linux-gnux32\" 1>&2\r\n                         exit 1\r\n                    }; else\r\n                        _cputype=i686\r\n                    fi\r\n                }; fi\r\n                ;;\r\n            mips64)\r\n                _cputype=$(get_endianness mips '' el)\r\n                ;;\r\n            powerpc64)\r\n                _cputype=powerpc\r\n                ;;\r\n            aarch64)\r\n                _cputype=armv7\r\n                if [ \"$_ostype\" = \"linux-android\" ]; then\r\n                    _ostype=linux-androideabi\r\n                else\r\n                    _ostype=\"${_ostype}eabihf\"\r\n                fi\r\n                ;;\r\n            riscv64gc)\r\n                err \"riscv64 with 32-bit userland unsupported\"\r\n                ;;\r\n        esac\r\n    fi\r\n\r\n    # Detect armv7 but without the CPU features Rust needs in that build,\r\n    # and fall back to arm.\r\n    # See https://github.com/rust-lang/rustup.rs/issues/587.\r\n    if [ \"$_ostype\" = \"unknown-linux-gnueabihf\" ] && [ \"$_cputype\" = armv7 ]; then\r\n        if ensure grep '^Features' /proc/cpuinfo | grep -q -v neon; then\r\n            # At least one processor does not have NEON.\r\n            _cputype=arm\r\n        fi\r\n    fi\r\n\r\n    _arch=\"${_cputype}-${_ostype}\"\r\n\r\n    RETVAL=\"$_arch\"\r\n}\r\n\r\nsay() {\r\n    printf 'rustup: %s\\n' \"$1\"\r\n}\r\n\r\nerr() {\r\n    say \"$1\" >&2\r\n    exit 1\r\n}\r\n\r\nneed_cmd() {\r\n    if ! check_cmd \"$1\"; then\r\n        err \"need '$1' (command not found)\"\r\n    fi\r\n}\r\n\r\ncheck_cmd() {\r\n    command -v \"$1\" > /dev/null 2>&1\r\n}\r\n\r\nassert_nz() {\r\n    if [ -z \"$1\" ]; then err \"assert_nz $2\"; fi\r\n}\r\n\r\n# Run a command that should never fail. If the command fails execution\r\n# will immediately terminate with an error showing the failing\r\n# command.\r\nensure() {\r\n    if ! \"$@\"; then err \"command failed: $*\"; fi\r\n}\r\n\r\n# This is just for indicating that commands' results are being\r\n# intentionally ignored. Usually, because it's being executed\r\n# as part of error handling.\r\nignore() {\r\n    \"$@\"\r\n}\r\n\r\n# This wraps curl or wget. Try curl first, if not installed,\r\n# use wget instead.\r\ndownloader() {\r\n    local _dld\r\n    local _ciphersuites\r\n    local _err\r\n    local _status\r\n    local _retry\r\n    if check_cmd curl; then\r\n        _dld=curl\r\n    elif check_cmd wget; then\r\n        _dld=wget\r\n    else\r\n        _dld='curl or wget' # to be used in error message of need_cmd\r\n    fi\r\n\r\n    if [ \"$1\" = --check ]; then\r\n        need_cmd \"$_dld\"\r\n    elif [ \"$_dld\" = curl ]; then\r\n        check_curl_for_retry_support\r\n        _retry=\"$RETVAL\"\r\n        get_ciphersuites_for_curl\r\n        _ciphersuites=\"$RETVAL\"\r\n        if [ -n \"$_ciphersuites\" ]; then\r\n            _err=$(curl $_retry --proto '=https' --tlsv1.2 --ciphers \"$_ciphersuites\" --silent --show-error --fail --location \"$1\" --output \"$2\" 2>&1)\r\n            _status=$?\r\n        else\r\n            echo \"Warning: Not enforcing strong cipher suites for TLS, this is potentially less secure\"\r\n            if ! check_help_for \"$3\" curl --proto --tlsv1.2; then\r\n                echo \"Warning: Not enforcing TLS v1.2, this is potentially less secure\"\r\n                _err=$(curl $_retry --silent --show-error --fail --location \"$1\" --output \"$2\" 2>&1)\r\n                _status=$?\r\n            else\r\n                _err=$(curl $_retry --proto '=https' --tlsv1.2 --silent --show-error --fail --location \"$1\" --output \"$2\" 2>&1)\r\n                _status=$?\r\n            fi\r\n        fi\r\n        if [ -n \"$_err\" ]; then\r\n            echo \"$_err\" >&2\r\n            if echo \"$_err\" | grep -q 404$; then\r\n                err \"installer for platform '$3' not found, this may be unsupported\"\r\n            fi\r\n        fi\r\n        return $_status\r\n    elif [ \"$_dld\" = wget ]; then\r\n        if [ \"$(wget -V 2>&1|head -2|tail -1|cut -f1 -d\" \")\" = \"BusyBox\" ]; then\r\n            echo \"Warning: using the BusyBox version of wget.  Not enforcing strong cipher suites for TLS or TLS v1.2, this is potentially less secure\"\r\n            _err=$(wget \"$1\" -O \"$2\" 2>&1)\r\n            _status=$?\r\n        else\r\n            get_ciphersuites_for_wget\r\n            _ciphersuites=\"$RETVAL\"\r\n            if [ -n \"$_ciphersuites\" ]; then\r\n                _err=$(wget --https-only --secure-protocol=TLSv1_2 --ciphers \"$_ciphersuites\" \"$1\" -O \"$2\" 2>&1)\r\n                _status=$?\r\n            else\r\n                echo \"Warning: Not enforcing strong cipher suites for TLS, this is potentially less secure\"\r\n                if ! check_help_for \"$3\" wget --https-only --secure-protocol; then\r\n                    echo \"Warning: Not enforcing TLS v1.2, this is potentially less secure\"\r\n                    _err=$(wget \"$1\" -O \"$2\" 2>&1)\r\n                    _status=$?\r\n                else\r\n                    _err=$(wget --https-only --secure-protocol=TLSv1_2 \"$1\" -O \"$2\" 2>&1)\r\n                    _status=$?\r\n                fi\r\n            fi\r\n        fi\r\n        if [ -n \"$_err\" ]; then\r\n            echo \"$_err\" >&2\r\n            if echo \"$_err\" | grep -q ' 404 Not Found$'; then\r\n                err \"installer for platform '$3' not found, this may be unsupported\"\r\n            fi\r\n        fi\r\n        return $_status\r\n    else\r\n        err \"Unknown downloader\"   # should not reach here\r\n    fi\r\n}\r\n\r\ncheck_help_for() {\r\n    local _arch\r\n    local _cmd\r\n    local _arg\r\n    _arch=\"$1\"\r\n    shift\r\n    _cmd=\"$1\"\r\n    shift\r\n\r\n    local _category\r\n    if \"$_cmd\" --help | grep -q 'For all options use the manual or \"--help all\".'; then\r\n      _category=\"all\"\r\n    else\r\n      _category=\"\"\r\n    fi\r\n\r\n    case \"$_arch\" in\r\n\r\n        *darwin*)\r\n        if check_cmd sw_vers; then\r\n            case $(sw_vers -productVersion) in\r\n                10.*)\r\n                    # If we're running on macOS, older than 10.13, then we always\r\n                    # fail to find these options to force fallback\r\n                    if [ \"$(sw_vers -productVersion | cut -d. -f2)\" -lt 13 ]; then\r\n                        # Older than 10.13\r\n                        echo \"Warning: Detected macOS platform older than 10.13\"\r\n                        return 1\r\n                    fi\r\n                    ;;\r\n                11.*)\r\n                    # We assume Big Sur will be OK for now\r\n                    ;;\r\n                *)\r\n                    # Unknown product version, warn and continue\r\n                    echo \"Warning: Detected unknown macOS major version: $(sw_vers -productVersion)\"\r\n                    echo \"Warning TLS capabilities detection may fail\"\r\n                    ;;\r\n            esac\r\n        fi\r\n        ;;\r\n\r\n    esac\r\n\r\n    for _arg in \"$@\"; do\r\n        if ! \"$_cmd\" --help $_category | grep -q -- \"$_arg\"; then\r\n            return 1\r\n        fi\r\n    done\r\n\r\n    true # not strictly needed\r\n}\r\n\r\n# Check if curl supports the --retry flag, then pass it to the curl invocation.\r\ncheck_curl_for_retry_support() {\r\n  local _retry_supported=\"\"\r\n  # \"unspecified\" is for arch, allows for possibility old OS using macports, homebrew, etc.\r\n  if check_help_for \"notspecified\" \"curl\" \"--retry\"; then\r\n    _retry_supported=\"--retry 3\"\r\n  fi\r\n\r\n  RETVAL=\"$_retry_supported\"\r\n\r\n}\r\n\r\n# Return cipher suite string specified by user, otherwise return strong TLS 1.2-1.3 cipher suites\r\n# if support by local tools is detected. Detection currently supports these curl backends:\r\n# GnuTLS and OpenSSL (possibly also LibreSSL and BoringSSL). Return value can be empty.\r\nget_ciphersuites_for_curl() {\r\n    if [ -n \"${RUSTUP_TLS_CIPHERSUITES-}\" ]; then\r\n        # user specified custom cipher suites, assume they know what they're doing\r\n        RETVAL=\"$RUSTUP_TLS_CIPHERSUITES\"\r\n        return\r\n    fi\r\n\r\n    local _openssl_syntax=\"no\"\r\n    local _gnutls_syntax=\"no\"\r\n    local _backend_supported=\"yes\"\r\n    if curl -V | grep -q ' OpenSSL/'; then\r\n        _openssl_syntax=\"yes\"\r\n    elif curl -V | grep -iq ' LibreSSL/'; then\r\n        _openssl_syntax=\"yes\"\r\n    elif curl -V | grep -iq ' BoringSSL/'; then\r\n        _openssl_syntax=\"yes\"\r\n    elif curl -V | grep -iq ' GnuTLS/'; then\r\n        _gnutls_syntax=\"yes\"\r\n    else\r\n        _backend_supported=\"no\"\r\n    fi\r\n\r\n    local _args_supported=\"no\"\r\n    if [ \"$_backend_supported\" = \"yes\" ]; then\r\n        # \"unspecified\" is for arch, allows for possibility old OS using macports, homebrew, etc.\r\n        if check_help_for \"notspecified\" \"curl\" \"--tlsv1.2\" \"--ciphers\" \"--proto\"; then\r\n            _args_supported=\"yes\"\r\n        fi\r\n    fi\r\n\r\n    local _cs=\"\"\r\n    if [ \"$_args_supported\" = \"yes\" ]; then\r\n        if [ \"$_openssl_syntax\" = \"yes\" ]; then\r\n            _cs=$(get_strong_ciphersuites_for \"openssl\")\r\n        elif [ \"$_gnutls_syntax\" = \"yes\" ]; then\r\n            _cs=$(get_strong_ciphersuites_for \"gnutls\")\r\n        fi\r\n    fi\r\n\r\n    RETVAL=\"$_cs\"\r\n}\r\n\r\n# Return cipher suite string specified by user, otherwise return strong TLS 1.2-1.3 cipher suites\r\n# if support by local tools is detected. Detection currently supports these wget backends:\r\n# GnuTLS and OpenSSL (possibly also LibreSSL and BoringSSL). Return value can be empty.\r\nget_ciphersuites_for_wget() {\r\n    if [ -n \"${RUSTUP_TLS_CIPHERSUITES-}\" ]; then\r\n        # user specified custom cipher suites, assume they know what they're doing\r\n        RETVAL=\"$RUSTUP_TLS_CIPHERSUITES\"\r\n        return\r\n    fi\r\n\r\n    local _cs=\"\"\r\n    if wget -V | grep -q '\\-DHAVE_LIBSSL'; then\r\n        # \"unspecified\" is for arch, allows for possibility old OS using macports, homebrew, etc.\r\n        if check_help_for \"notspecified\" \"wget\" \"TLSv1_2\" \"--ciphers\" \"--https-only\" \"--secure-protocol\"; then\r\n            _cs=$(get_strong_ciphersuites_for \"openssl\")\r\n        fi\r\n    elif wget -V | grep -q '\\-DHAVE_LIBGNUTLS'; then\r\n        # \"unspecified\" is for arch, allows for possibility old OS using macports, homebrew, etc.\r\n        if check_help_for \"notspecified\" \"wget\" \"TLSv1_2\" \"--ciphers\" \"--https-only\" \"--secure-protocol\"; then\r\n            _cs=$(get_strong_ciphersuites_for \"gnutls\")\r\n        fi\r\n    fi\r\n\r\n    RETVAL=\"$_cs\"\r\n}\r\n\r\n# Return strong TLS 1.2-1.3 cipher suites in OpenSSL or GnuTLS syntax. TLS 1.2\r\n# excludes non-ECDHE and non-AEAD cipher suites. DHE is excluded due to bad\r\n# DH params often found on servers (see RFC 7919). Sequence matches or is\r\n# similar to Firefox 68 ESR with weak cipher suites disabled via about:config.\r\n# $1 must be openssl or gnutls.\r\nget_strong_ciphersuites_for() {\r\n    if [ \"$1\" = \"openssl\" ]; then\r\n        # OpenSSL is forgiving of unknown values, no problems with TLS 1.3 values on versions that don't support it yet.\r\n        echo \"TLS_AES_128_GCM_SHA256:TLS_CHACHA20_POLY1305_SHA256:TLS_AES_256_GCM_SHA384:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384\"\r\n    elif [ \"$1\" = \"gnutls\" ]; then\r\n        # GnuTLS isn't forgiving of unknown values, so this may require a GnuTLS version that supports TLS 1.3 even if wget doesn't.\r\n        # Begin with SECURE128 (and higher) then remove/add to build cipher suites. Produces same 9 cipher suites as OpenSSL but in slightly different order.\r\n        echo \"SECURE128:-VERS-SSL3.0:-VERS-TLS1.0:-VERS-TLS1.1:-VERS-DTLS-ALL:-CIPHER-ALL:-MAC-ALL:-KX-ALL:+AEAD:+ECDHE-ECDSA:+ECDHE-RSA:+AES-128-GCM:+CHACHA20-POLY1305:+AES-256-GCM\"\r\n    fi\r\n}\r\n\r\nmain \"$@\" || exit 1\r\ncurl: (6) Could not resolve host: |\r\ncurl: (6) Could not resolve host: sh", "stdout_lines": ["#!/bin/sh", "# shellcheck shell=dash", "", "# This is just a little script that can be downloaded from the internet to", "# install rustup. It just does platform detection, downloads the installer", "# and runs it.", "", "# It runs on Unix shells like {a,ba,da,k,z}sh. It uses the common `local`", "# extension. Note: Most shells limit `local` to 1 var per line, contra bash.", "", "if [ \"$KSH_VERSION\" = 'Version JM 93t+ 2010-03-05' ]; then", "    # The version of ksh93 that ships with many illumos systems does not", "    # support the \"local\" extension.  Print a message rather than fail in", "    # subtle ways later on:", "    echo 'rustup does not work with this ksh93 version; please try bash!' >&2", "    exit 1", "fi", "", "", "set -u", "", "# If RUSTUP_UPDATE_ROOT is unset or empty, default it.", "RUSTUP_UPDATE_ROOT=\"${RUSTUP_UPDATE_ROOT:-https://static.rust-lang.org/rustup}\"", "", "#XXX: If you change anything here, please make the same changes in setup_mode.rs", "usage() {", "    cat 1>&2 <<EOF", "rustup-init 1.25.1 (48d233f65 2022-07-12)", "The installer for rustup", "", "USAGE:", "    rustup-init [FLAGS] [OPTIONS]", "", "FLAGS:", "    -v, --verbose           Enable verbose output", "    -q, --quiet             Disable progress output", "    -y                      Disable confirmation prompt.", "        --no-modify-path    Don't configure the PATH environment variable", "    -h, --help              Prints help information", "    -V, --version           Prints version information", "", "OPTIONS:", "        --default-host <default-host>              Choose a default host triple", "        --default-toolchain <default-toolchain>    Choose a default toolchain to install", "        --default-toolchain none                   Do not install any toolchains", "        --profile [minimal|default|complete]       Choose a profile", "    -c, --component <components>...                Component name to also install", "    -t, --target <targets>...                      Target name to also install", "EOF", "}", "", "main() {", "    downloader --check", "    need_cmd uname", "    need_cmd mktemp", "    need_cmd chmod", "    need_cmd mkdir", "    need_cmd rm", "    need_cmd rmdir", "", "    get_architecture || return 1", "    local _arch=\"$RETVAL\"", "    assert_nz \"$_arch\" \"arch\"", "", "    local _ext=\"\"", "    case \"$_arch\" in", "        *windows*)", "            _ext=\".exe\"", "            ;;", "    esac", "", "    local _url=\"${RUSTUP_UPDATE_ROOT}/dist/${_arch}/rustup-init${_ext}\"", "", "    local _dir", "    _dir=\"$(ensure mktemp -d)\"", "    local _file=\"${_dir}/rustup-init${_ext}\"", "", "    local _ansi_escapes_are_valid=false", "    if [ -t 2 ]; then", "        if [ \"${TERM+set}\" = 'set' ]; then", "            case \"$TERM\" in", "                xterm*|rxvt*|urxvt*|linux*|vt*)", "                    _ansi_escapes_are_valid=true", "                ;;", "            esac", "        fi", "    fi", "", "    # check if we have to use /dev/tty to prompt the user", "    local need_tty=yes", "    for arg in \"$@\"; do", "        case \"$arg\" in", "            --help)", "                usage", "                exit 0", "                ;;", "            *)", "                OPTIND=1", "                if [ \"${arg%%--*}\" = \"\" ]; then", "                    # Long option (other than --help);", "                    # don't attempt to interpret it.", "                    continue", "                fi", "                while getopts :hy sub_arg \"$arg\"; do", "                    case \"$sub_arg\" in", "                        h)", "                            usage", "                            exit 0", "                            ;;", "                        y)", "                            # user wants to skip the prompt --", "                            # we don't need /dev/tty", "                            need_tty=no", "                            ;;", "                        *)", "                            ;;", "                        esac", "                done", "                ;;", "        esac", "    done", "", "    if $_ansi_escapes_are_valid; then", "        printf \"\\33[1minfo:\\33[0m downloading installer\\n\" 1>&2", "    else", "        printf '%s\\n' 'info: downloading installer' 1>&2", "    fi", "", "    ensure mkdir -p \"$_dir\"", "    ensure downloader \"$_url\" \"$_file\" \"$_arch\"", "    ensure chmod u+x \"$_file\"", "    if [ ! -x \"$_file\" ]; then", "        printf '%s\\n' \"Cannot execute $_file (likely because of mounting /tmp as noexec).\" 1>&2", "        printf '%s\\n' \"Please copy the file to a location where you can execute binaries and run ./rustup-init${_ext}.\" 1>&2", "        exit 1", "    fi", "", "    if [ \"$need_tty\" = \"yes\" ] && [ ! -t 0 ]; then", "        # The installer is going to want to ask for confirmation by", "        # reading stdin.  This script was piped into `sh` though and", "        # doesn't have stdin to pass to its children. Instead we're going", "        # to explicitly connect /dev/tty to the installer's stdin.", "        if [ ! -t 1 ]; then", "            err \"Unable to run interactively. Run with -y to accept defaults, --help for additional options\"", "        fi", "", "        ignore \"$_file\" \"$@\" < /dev/tty", "    else", "        ignore \"$_file\" \"$@\"", "    fi", "", "    local _retval=$?", "", "    ignore rm \"$_file\"", "    ignore rmdir \"$_dir\"", "", "    return \"$_retval\"", "}", "", "check_proc() {", "    # Check for /proc by looking for the /proc/self/exe link", "    # This is only run on Linux", "    if ! test -L /proc/self/exe ; then", "        err \"fatal: Unable to find /proc/self/exe.  Is /proc mounted?  Installation cannot proceed without /proc.\"", "    fi", "}", "", "get_bitness() {", "    need_cmd head", "    # Architecture detection without dependencies beyond coreutils.", "    # ELF files start out \"\\x7fELF\", and the following byte is", "    #   0x01 for 32-bit and", "    #   0x02 for 64-bit.", "    # The printf builtin on some shells like dash only supports octal", "    # escape sequences, so we use those.", "    local _current_exe_head", "    _current_exe_head=$(head -c 5 /proc/self/exe )", "    if [ \"$_current_exe_head\" = \"$(printf '\\177ELF\\001')\" ]; then", "        echo 32", "    elif [ \"$_current_exe_head\" = \"$(printf '\\177ELF\\002')\" ]; then", "        echo 64", "    else", "        err \"unknown platform bitness\"", "    fi", "}", "", "is_host_amd64_elf() {", "    need_cmd head", "    need_cmd tail", "    # ELF e_machine detection without dependencies beyond coreutils.", "    # Two-byte field at offset 0x12 indicates the CPU,", "    # but we're interested in it being 0x3E to indicate amd64, or not that.", "    local _current_exe_machine", "    _current_exe_machine=$(head -c 19 /proc/self/exe | tail -c 1)", "    [ \"$_current_exe_machine\" = \"$(printf '\\076')\" ]", "}", "", "get_endianness() {", "    local cputype=$1", "    local suffix_eb=$2", "    local suffix_el=$3", "", "    # detect endianness without od/hexdump, like get_bitness() does.", "    need_cmd head", "    need_cmd tail", "", "    local _current_exe_endianness", "    _current_exe_endianness=\"$(head -c 6 /proc/self/exe | tail -c 1)\"", "    if [ \"$_current_exe_endianness\" = \"$(printf '\\001')\" ]; then", "        echo \"${cputype}${suffix_el}\"", "    elif [ \"$_current_exe_endianness\" = \"$(printf '\\002')\" ]; then", "        echo \"${cputype}${suffix_eb}\"", "    else", "        err \"unknown platform endianness\"", "    fi", "}", "", "get_architecture() {", "    local _ostype _cputype _bitness _arch _clibtype", "    _ostype=\"$(uname -s)\"", "    _cputype=\"$(uname -m)\"", "    _clibtype=\"gnu\"", "", "    if [ \"$_ostype\" = Linux ]; then", "        if [ \"$(uname -o)\" = Android ]; then", "            _ostype=Android", "        fi", "        if ldd --version 2>&1 | grep -q 'musl'; then", "            _clibtype=\"musl\"", "        fi", "    fi", "", "    if [ \"$_ostype\" = Darwin ] && [ \"$_cputype\" = i386 ]; then", "        # Darwin `uname -m` lies", "        if sysctl hw.optional.x86_64 | grep -q ': 1'; then", "            _cputype=x86_64", "        fi", "    fi", "", "    if [ \"$_ostype\" = SunOS ]; then", "        # Both Solaris and illumos presently announce as \"SunOS\" in \"uname -s\"", "        # so use \"uname -o\" to disambiguate.  We use the full path to the", "        # system uname in case the user has coreutils uname first in PATH,", "        # which has historically sometimes printed the wrong value here.", "        if [ \"$(/usr/bin/uname -o)\" = illumos ]; then", "            _ostype=illumos", "        fi", "", "        # illumos systems have multi-arch userlands, and \"uname -m\" reports the", "        # machine hardware name; e.g., \"i86pc\" on both 32- and 64-bit x86", "        # systems.  Check for the native (widest) instruction set on the", "        # running kernel:", "        if [ \"$_cputype\" = i86pc ]; then", "            _cputype=\"$(isainfo -n)\"", "        fi", "    fi", "", "    case \"$_ostype\" in", "", "        Android)", "            _ostype=linux-android", "            ;;", "", "        Linux)", "            check_proc", "            _ostype=unknown-linux-$_clibtype", "            _bitness=$(get_bitness)", "            ;;", "", "        FreeBSD)", "            _ostype=unknown-freebsd", "            ;;", "", "        NetBSD)", "            _ostype=unknown-netbsd", "            ;;", "", "        DragonFly)", "            _ostype=unknown-dragonfly", "            ;;", "", "        Darwin)", "            _ostype=apple-darwin", "            ;;", "", "        illumos)", "            _ostype=unknown-illumos", "            ;;", "", "        MINGW* | MSYS* | CYGWIN* | Windows_NT)", "            _ostype=pc-windows-gnu", "            ;;", "", "        *)", "            err \"unrecognized OS type: $_ostype\"", "            ;;", "", "    esac", "", "    case \"$_cputype\" in", "", "        i386 | i486 | i686 | i786 | x86)", "            _cputype=i686", "            ;;", "", "        xscale | arm)", "            _cputype=arm", "            if [ \"$_ostype\" = \"linux-android\" ]; then", "                _ostype=linux-androideabi", "            fi", "            ;;", "", "        armv6l)", "            _cputype=arm", "            if [ \"$_ostype\" = \"linux-android\" ]; then", "                _ostype=linux-androideabi", "            else", "                _ostype=\"${_ostype}eabihf\"", "            fi", "            ;;", "", "        armv7l | armv8l)", "            _cputype=armv7", "            if [ \"$_ostype\" = \"linux-android\" ]; then", "                _ostype=linux-androideabi", "            else", "                _ostype=\"${_ostype}eabihf\"", "            fi", "            ;;", "", "        aarch64 | arm64)", "            _cputype=aarch64", "            ;;", "", "        x86_64 | x86-64 | x64 | amd64)", "            _cputype=x86_64", "            ;;", "", "        mips)", "            _cputype=$(get_endianness mips '' el)", "            ;;", "", "        mips64)", "            if [ \"$_bitness\" -eq 64 ]; then", "                # only n64 ABI is supported for now", "                _ostype=\"${_ostype}abi64\"", "                _cputype=$(get_endianness mips64 '' el)", "            fi", "            ;;", "", "        ppc)", "            _cputype=powerpc", "            ;;", "", "        ppc64)", "            _cputype=powerpc64", "            ;;", "", "        ppc64le)", "            _cputype=powerpc64le", "            ;;", "", "        s390x)", "            _cputype=s390x", "            ;;", "        riscv64)", "            _cputype=riscv64gc", "            ;;", "        *)", "            err \"unknown CPU type: $_cputype\"", "", "    esac", "", "    # Detect 64-bit linux with 32-bit userland", "    if [ \"${_ostype}\" = unknown-linux-gnu ] && [ \"${_bitness}\" -eq 32 ]; then", "        case $_cputype in", "            x86_64)", "                if [ -n \"${RUSTUP_CPUTYPE:-}\" ]; then", "                    _cputype=\"$RUSTUP_CPUTYPE\"", "                else {", "                    # 32-bit executable for amd64 = x32", "                    if is_host_amd64_elf; then {", "                         echo \"This host is running an x32 userland; as it stands, x32 support is poor,\" 1>&2", "                         echo \"and there isn't a native toolchain -- you will have to install\" 1>&2", "                         echo \"multiarch compatibility with i686 and/or amd64, then select one\" 1>&2", "                         echo \"by re-running this script with the RUSTUP_CPUTYPE environment variable\" 1>&2", "                         echo \"set to i686 or x86_64, respectively.\" 1>&2", "                         echo 1>&2", "                         echo \"You will be able to add an x32 target after installation by running\" 1>&2", "                         echo \"  rustup target add x86_64-unknown-linux-gnux32\" 1>&2", "                         exit 1", "                    }; else", "                        _cputype=i686", "                    fi", "                }; fi", "                ;;", "            mips64)", "                _cputype=$(get_endianness mips '' el)", "                ;;", "            powerpc64)", "                _cputype=powerpc", "                ;;", "            aarch64)", "                _cputype=armv7", "                if [ \"$_ostype\" = \"linux-android\" ]; then", "                    _ostype=linux-androideabi", "                else", "                    _ostype=\"${_ostype}eabihf\"", "                fi", "                ;;", "            riscv64gc)", "                err \"riscv64 with 32-bit userland unsupported\"", "                ;;", "        esac", "    fi", "", "    # Detect armv7 but without the CPU features Rust needs in that build,", "    # and fall back to arm.", "    # See https://github.com/rust-lang/rustup.rs/issues/587.", "    if [ \"$_ostype\" = \"unknown-linux-gnueabihf\" ] && [ \"$_cputype\" = armv7 ]; then", "        if ensure grep '^Features' /proc/cpuinfo | grep -q -v neon; then", "            # At least one processor does not have NEON.", "            _cputype=arm", "        fi", "    fi", "", "    _arch=\"${_cputype}-${_ostype}\"", "", "    RETVAL=\"$_arch\"", "}", "", "say() {", "    printf 'rustup: %s\\n' \"$1\"", "}", "", "err() {", "    say \"$1\" >&2", "    exit 1", "}", "", "need_cmd() {", "    if ! check_cmd \"$1\"; then", "        err \"need '$1' (command not found)\"", "    fi", "}", "", "check_cmd() {", "    command -v \"$1\" > /dev/null 2>&1", "}", "", "assert_nz() {", "    if [ -z \"$1\" ]; then err \"assert_nz $2\"; fi", "}", "", "# Run a command that should never fail. If the command fails execution", "# will immediately terminate with an error showing the failing", "# command.", "ensure() {", "    if ! \"$@\"; then err \"command failed: $*\"; fi", "}", "", "# This is just for indicating that commands' results are being", "# intentionally ignored. Usually, because it's being executed", "# as part of error handling.", "ignore() {", "    \"$@\"", "}", "", "# This wraps curl or wget. Try curl first, if not installed,", "# use wget instead.", "downloader() {", "    local _dld", "    local _ciphersuites", "    local _err", "    local _status", "    local _retry", "    if check_cmd curl; then", "        _dld=curl", "    elif check_cmd wget; then", "        _dld=wget", "    else", "        _dld='curl or wget' # to be used in error message of need_cmd", "    fi", "", "    if [ \"$1\" = --check ]; then", "        need_cmd \"$_dld\"", "    elif [ \"$_dld\" = curl ]; then", "        check_curl_for_retry_support", "        _retry=\"$RETVAL\"", "        get_ciphersuites_for_curl", "        _ciphersuites=\"$RETVAL\"", "        if [ -n \"$_ciphersuites\" ]; then", "            _err=$(curl $_retry --proto '=https' --tlsv1.2 --ciphers \"$_ciphersuites\" --silent --show-error --fail --location \"$1\" --output \"$2\" 2>&1)", "            _status=$?", "        else", "            echo \"Warning: Not enforcing strong cipher suites for TLS, this is potentially less secure\"", "            if ! check_help_for \"$3\" curl --proto --tlsv1.2; then", "                echo \"Warning: Not enforcing TLS v1.2, this is potentially less secure\"", "                _err=$(curl $_retry --silent --show-error --fail --location \"$1\" --output \"$2\" 2>&1)", "                _status=$?", "            else", "                _err=$(curl $_retry --proto '=https' --tlsv1.2 --silent --show-error --fail --location \"$1\" --output \"$2\" 2>&1)", "                _status=$?", "            fi", "        fi", "        if [ -n \"$_err\" ]; then", "            echo \"$_err\" >&2", "            if echo \"$_err\" | grep -q 404$; then", "                err \"installer for platform '$3' not found, this may be unsupported\"", "            fi", "        fi", "        return $_status", "    elif [ \"$_dld\" = wget ]; then", "        if [ \"$(wget -V 2>&1|head -2|tail -1|cut -f1 -d\" \")\" = \"BusyBox\" ]; then", "            echo \"Warning: using the BusyBox version of wget.  Not enforcing strong cipher suites for TLS or TLS v1.2, this is potentially less secure\"", "            _err=$(wget \"$1\" -O \"$2\" 2>&1)", "            _status=$?", "        else", "            get_ciphersuites_for_wget", "            _ciphersuites=\"$RETVAL\"", "            if [ -n \"$_ciphersuites\" ]; then", "                _err=$(wget --https-only --secure-protocol=TLSv1_2 --ciphers \"$_ciphersuites\" \"$1\" -O \"$2\" 2>&1)", "                _status=$?", "            else", "                echo \"Warning: Not enforcing strong cipher suites for TLS, this is potentially less secure\"", "                if ! check_help_for \"$3\" wget --https-only --secure-protocol; then", "                    echo \"Warning: Not enforcing TLS v1.2, this is potentially less secure\"", "                    _err=$(wget \"$1\" -O \"$2\" 2>&1)", "                    _status=$?", "                else", "                    _err=$(wget --https-only --secure-protocol=TLSv1_2 \"$1\" -O \"$2\" 2>&1)", "                    _status=$?", "                fi", "            fi", "        fi", "        if [ -n \"$_err\" ]; then", "            echo \"$_err\" >&2", "            if echo \"$_err\" | grep -q ' 404 Not Found$'; then", "                err \"installer for platform '$3' not found, this may be unsupported\"", "            fi", "        fi", "        return $_status", "    else", "        err \"Unknown downloader\"   # should not reach here", "    fi", "}", "", "check_help_for() {", "    local _arch", "    local _cmd", "    local _arg", "    _arch=\"$1\"", "    shift", "    _cmd=\"$1\"", "    shift", "", "    local _category", "    if \"$_cmd\" --help | grep -q 'For all options use the manual or \"--help all\".'; then", "      _category=\"all\"", "    else", "      _category=\"\"", "    fi", "", "    case \"$_arch\" in", "", "        *darwin*)", "        if check_cmd sw_vers; then", "            case $(sw_vers -productVersion) in", "                10.*)", "                    # If we're running on macOS, older than 10.13, then we always", "                    # fail to find these options to force fallback", "                    if [ \"$(sw_vers -productVersion | cut -d. -f2)\" -lt 13 ]; then", "                        # Older than 10.13", "                        echo \"Warning: Detected macOS platform older than 10.13\"", "                        return 1", "                    fi", "                    ;;", "                11.*)", "                    # We assume Big Sur will be OK for now", "                    ;;", "                *)", "                    # Unknown product version, warn and continue", "                    echo \"Warning: Detected unknown macOS major version: $(sw_vers -productVersion)\"", "                    echo \"Warning TLS capabilities detection may fail\"", "                    ;;", "            esac", "        fi", "        ;;", "", "    esac", "", "    for _arg in \"$@\"; do", "        if ! \"$_cmd\" --help $_category | grep -q -- \"$_arg\"; then", "            return 1", "        fi", "    done", "", "    true # not strictly needed", "}", "", "# Check if curl supports the --retry flag, then pass it to the curl invocation.", "check_curl_for_retry_support() {", "  local _retry_supported=\"\"", "  # \"unspecified\" is for arch, allows for possibility old OS using macports, homebrew, etc.", "  if check_help_for \"notspecified\" \"curl\" \"--retry\"; then", "    _retry_supported=\"--retry 3\"", "  fi", "", "  RETVAL=\"$_retry_supported\"", "", "}", "", "# Return cipher suite string specified by user, otherwise return strong TLS 1.2-1.3 cipher suites", "# if support by local tools is detected. Detection currently supports these curl backends:", "# GnuTLS and OpenSSL (possibly also LibreSSL and BoringSSL). Return value can be empty.", "get_ciphersuites_for_curl() {", "    if [ -n \"${RUSTUP_TLS_CIPHERSUITES-}\" ]; then", "        # user specified custom cipher suites, assume they know what they're doing", "        RETVAL=\"$RUSTUP_TLS_CIPHERSUITES\"", "        return", "    fi", "", "    local _openssl_syntax=\"no\"", "    local _gnutls_syntax=\"no\"", "    local _backend_supported=\"yes\"", "    if curl -V | grep -q ' OpenSSL/'; then", "        _openssl_syntax=\"yes\"", "    elif curl -V | grep -iq ' LibreSSL/'; then", "        _openssl_syntax=\"yes\"", "    elif curl -V | grep -iq ' BoringSSL/'; then", "        _openssl_syntax=\"yes\"", "    elif curl -V | grep -iq ' GnuTLS/'; then", "        _gnutls_syntax=\"yes\"", "    else", "        _backend_supported=\"no\"", "    fi", "", "    local _args_supported=\"no\"", "    if [ \"$_backend_supported\" = \"yes\" ]; then", "        # \"unspecified\" is for arch, allows for possibility old OS using macports, homebrew, etc.", "        if check_help_for \"notspecified\" \"curl\" \"--tlsv1.2\" \"--ciphers\" \"--proto\"; then", "            _args_supported=\"yes\"", "        fi", "    fi", "", "    local _cs=\"\"", "    if [ \"$_args_supported\" = \"yes\" ]; then", "        if [ \"$_openssl_syntax\" = \"yes\" ]; then", "            _cs=$(get_strong_ciphersuites_for \"openssl\")", "        elif [ \"$_gnutls_syntax\" = \"yes\" ]; then", "            _cs=$(get_strong_ciphersuites_for \"gnutls\")", "        fi", "    fi", "", "    RETVAL=\"$_cs\"", "}", "", "# Return cipher suite string specified by user, otherwise return strong TLS 1.2-1.3 cipher suites", "# if support by local tools is detected. Detection currently supports these wget backends:", "# GnuTLS and OpenSSL (possibly also LibreSSL and BoringSSL). Return value can be empty.", "get_ciphersuites_for_wget() {", "    if [ -n \"${RUSTUP_TLS_CIPHERSUITES-}\" ]; then", "        # user specified custom cipher suites, assume they know what they're doing", "        RETVAL=\"$RUSTUP_TLS_CIPHERSUITES\"", "        return", "    fi", "", "    local _cs=\"\"", "    if wget -V | grep -q '\\-DHAVE_LIBSSL'; then", "        # \"unspecified\" is for arch, allows for possibility old OS using macports, homebrew, etc.", "        if check_help_for \"notspecified\" \"wget\" \"TLSv1_2\" \"--ciphers\" \"--https-only\" \"--secure-protocol\"; then", "            _cs=$(get_strong_ciphersuites_for \"openssl\")", "        fi", "    elif wget -V | grep -q '\\-DHAVE_LIBGNUTLS'; then", "        # \"unspecified\" is for arch, allows for possibility old OS using macports, homebrew, etc.", "        if check_help_for \"notspecified\" \"wget\" \"TLSv1_2\" \"--ciphers\" \"--https-only\" \"--secure-protocol\"; then", "            _cs=$(get_strong_ciphersuites_for \"gnutls\")", "        fi", "    fi", "", "    RETVAL=\"$_cs\"", "}", "", "# Return strong TLS 1.2-1.3 cipher suites in OpenSSL or GnuTLS syntax. TLS 1.2", "# excludes non-ECDHE and non-AEAD cipher suites. DHE is excluded due to bad", "# DH params often found on servers (see RFC 7919). Sequence matches or is", "# similar to Firefox 68 ESR with weak cipher suites disabled via about:config.", "# $1 must be openssl or gnutls.", "get_strong_ciphersuites_for() {", "    if [ \"$1\" = \"openssl\" ]; then", "        # OpenSSL is forgiving of unknown values, no problems with TLS 1.3 values on versions that don't support it yet.", "        echo \"TLS_AES_128_GCM_SHA256:TLS_CHACHA20_POLY1305_SHA256:TLS_AES_256_GCM_SHA384:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384\"", "    elif [ \"$1\" = \"gnutls\" ]; then", "        # GnuTLS isn't forgiving of unknown values, so this may require a GnuTLS version that supports TLS 1.3 even if wget doesn't.", "        # Begin with SECURE128 (and higher) then remove/add to build cipher suites. Produces same 9 cipher suites as OpenSSL but in slightly different order.", "        echo \"SECURE128:-VERS-SSL3.0:-VERS-TLS1.0:-VERS-TLS1.1:-VERS-DTLS-ALL:-CIPHER-ALL:-MAC-ALL:-KX-ALL:+AEAD:+ECDHE-ECDSA:+ECDHE-RSA:+AES-128-GCM:+CHACHA20-POLY1305:+AES-256-GCM\"", "    fi", "}", "", "main \"$@\" || exit 1", "curl: (6) Could not resolve host: |", "curl: (6) Could not resolve host: sh"]}
2022-12-30 00:11:35,253 p=90761 u=kal n=ansible | PLAY RECAP *******************************************************************************************************************************************
2022-12-30 00:11:35,254 p=90761 u=kal n=ansible | krpz                       : ok=3    changed=0    unreachable=0    failed=1    skipped=0    rescued=0    ignored=0   
2022-12-30 00:11:54,703 p=91007 u=kal n=ansible | PLAY [localhost] *************************************************************************************************************************************
2022-12-30 00:11:54,710 p=91007 u=kal n=ansible | TASK [Gathering Facts] *******************************************************************************************************************************
2022-12-30 00:11:58,654 p=91007 u=kal n=ansible | ok: [krpz]
2022-12-30 00:11:58,675 p=91007 u=kal n=ansible | TASK [Install Rust] **********************************************************************************************************************************
2022-12-30 00:12:00,782 p=91007 u=kal n=ansible | fatal: [krpz]: FAILED! => {"changed": true, "cmd": "curl https://sh.rustup.rs | sh", "delta": "0:00:01.898114", "end": "2022-12-30 00:12:00.731015", "msg": "non-zero return code", "rc": 6, "start": "2022-12-30 00:11:58.832901", "stdout": "#!/bin/sh\r\n# shellcheck shell=dash\r\n\r\n# This is just a little script that can be downloaded from the internet to\r\n# install rustup. It just does platform detection, downloads the installer\r\n# and runs it.\r\n\r\n# It runs on Unix shells like {a,ba,da,k,z}sh. It uses the common `local`\r\n# extension. Note: Most shells limit `local` to 1 var per line, contra bash.\r\n\r\nif [ \"$KSH_VERSION\" = 'Version JM 93t+ 2010-03-05' ]; then\r\n    # The version of ksh93 that ships with many illumos systems does not\r\n    # support the \"local\" extension.  Print a message rather than fail in\r\n    # subtle ways later on:\r\n    echo 'rustup does not work with this ksh93 version; please try bash!' >&2\r\n    exit 1\r\nfi\r\n\r\n\r\nset -u\r\n\r\n# If RUSTUP_UPDATE_ROOT is unset or empty, default it.\r\nRUSTUP_UPDATE_ROOT=\"${RUSTUP_UPDATE_ROOT:-https://static.rust-lang.org/rustup}\"\r\n\r\n#XXX: If you change anything here, please make the same changes in setup_mode.rs\r\nusage() {\r\n    cat 1>&2 <<EOF\r\nrustup-init 1.25.1 (48d233f65 2022-07-12)\r\nThe installer for rustup\r\n\r\nUSAGE:\r\n    rustup-init [FLAGS] [OPTIONS]\r\n\r\nFLAGS:\r\n    -v, --verbose           Enable verbose output\r\n    -q, --quiet             Disable progress output\r\n    -y                      Disable confirmation prompt.\r\n        --no-modify-path    Don't configure the PATH environment variable\r\n    -h, --help              Prints help information\r\n    -V, --version           Prints version information\r\n\r\nOPTIONS:\r\n        --default-host <default-host>              Choose a default host triple\r\n        --default-toolchain <default-toolchain>    Choose a default toolchain to install\r\n        --default-toolchain none                   Do not install any toolchains\r\n        --profile [minimal|default|complete]       Choose a profile\r\n    -c, --component <components>...                Component name to also install\r\n    -t, --target <targets>...                      Target name to also install\r\nEOF\r\n}\r\n\r\nmain() {\r\n    downloader --check\r\n    need_cmd uname\r\n    need_cmd mktemp\r\n    need_cmd chmod\r\n    need_cmd mkdir\r\n    need_cmd rm\r\n    need_cmd rmdir\r\n\r\n    get_architecture || return 1\r\n    local _arch=\"$RETVAL\"\r\n    assert_nz \"$_arch\" \"arch\"\r\n\r\n    local _ext=\"\"\r\n    case \"$_arch\" in\r\n        *windows*)\r\n            _ext=\".exe\"\r\n            ;;\r\n    esac\r\n\r\n    local _url=\"${RUSTUP_UPDATE_ROOT}/dist/${_arch}/rustup-init${_ext}\"\r\n\r\n    local _dir\r\n    _dir=\"$(ensure mktemp -d)\"\r\n    local _file=\"${_dir}/rustup-init${_ext}\"\r\n\r\n    local _ansi_escapes_are_valid=false\r\n    if [ -t 2 ]; then\r\n        if [ \"${TERM+set}\" = 'set' ]; then\r\n            case \"$TERM\" in\r\n                xterm*|rxvt*|urxvt*|linux*|vt*)\r\n                    _ansi_escapes_are_valid=true\r\n                ;;\r\n            esac\r\n        fi\r\n    fi\r\n\r\n    # check if we have to use /dev/tty to prompt the user\r\n    local need_tty=yes\r\n    for arg in \"$@\"; do\r\n        case \"$arg\" in\r\n            --help)\r\n                usage\r\n                exit 0\r\n                ;;\r\n            *)\r\n                OPTIND=1\r\n                if [ \"${arg%%--*}\" = \"\" ]; then\r\n                    # Long option (other than --help);\r\n                    # don't attempt to interpret it.\r\n                    continue\r\n                fi\r\n                while getopts :hy sub_arg \"$arg\"; do\r\n                    case \"$sub_arg\" in\r\n                        h)\r\n                            usage\r\n                            exit 0\r\n                            ;;\r\n                        y)\r\n                            # user wants to skip the prompt --\r\n                            # we don't need /dev/tty\r\n                            need_tty=no\r\n                            ;;\r\n                        *)\r\n                            ;;\r\n                        esac\r\n                done\r\n                ;;\r\n        esac\r\n    done\r\n\r\n    if $_ansi_escapes_are_valid; then\r\n        printf \"\\33[1minfo:\\33[0m downloading installer\\n\" 1>&2\r\n    else\r\n        printf '%s\\n' 'info: downloading installer' 1>&2\r\n    fi\r\n\r\n    ensure mkdir -p \"$_dir\"\r\n    ensure downloader \"$_url\" \"$_file\" \"$_arch\"\r\n    ensure chmod u+x \"$_file\"\r\n    if [ ! -x \"$_file\" ]; then\r\n        printf '%s\\n' \"Cannot execute $_file (likely because of mounting /tmp as noexec).\" 1>&2\r\n        printf '%s\\n' \"Please copy the file to a location where you can execute binaries and run ./rustup-init${_ext}.\" 1>&2\r\n        exit 1\r\n    fi\r\n\r\n    if [ \"$need_tty\" = \"yes\" ] && [ ! -t 0 ]; then\r\n        # The installer is going to want to ask for confirmation by\r\n        # reading stdin.  This script was piped into `sh` though and\r\n        # doesn't have stdin to pass to its children. Instead we're going\r\n        # to explicitly connect /dev/tty to the installer's stdin.\r\n        if [ ! -t 1 ]; then\r\n            err \"Unable to run interactively. Run with -y to accept defaults, --help for additional options\"\r\n        fi\r\n\r\n        ignore \"$_file\" \"$@\" < /dev/tty\r\n    else\r\n        ignore \"$_file\" \"$@\"\r\n    fi\r\n\r\n    local _retval=$?\r\n\r\n    ignore rm \"$_file\"\r\n    ignore rmdir \"$_dir\"\r\n\r\n    return \"$_retval\"\r\n}\r\n\r\ncheck_proc() {\r\n    # Check for /proc by looking for the /proc/self/exe link\r\n    # This is only run on Linux\r\n    if ! test -L /proc/self/exe ; then\r\n        err \"fatal: Unable to find /proc/self/exe.  Is /proc mounted?  Installation cannot proceed without /proc.\"\r\n    fi\r\n}\r\n\r\nget_bitness() {\r\n    need_cmd head\r\n    # Architecture detection without dependencies beyond coreutils.\r\n    # ELF files start out \"\\x7fELF\", and the following byte is\r\n    #   0x01 for 32-bit and\r\n    #   0x02 for 64-bit.\r\n    # The printf builtin on some shells like dash only supports octal\r\n    # escape sequences, so we use those.\r\n    local _current_exe_head\r\n    _current_exe_head=$(head -c 5 /proc/self/exe )\r\n    if [ \"$_current_exe_head\" = \"$(printf '\\177ELF\\001')\" ]; then\r\n        echo 32\r\n    elif [ \"$_current_exe_head\" = \"$(printf '\\177ELF\\002')\" ]; then\r\n        echo 64\r\n    else\r\n        err \"unknown platform bitness\"\r\n    fi\r\n}\r\n\r\nis_host_amd64_elf() {\r\n    need_cmd head\r\n    need_cmd tail\r\n    # ELF e_machine detection without dependencies beyond coreutils.\r\n    # Two-byte field at offset 0x12 indicates the CPU,\r\n    # but we're interested in it being 0x3E to indicate amd64, or not that.\r\n    local _current_exe_machine\r\n    _current_exe_machine=$(head -c 19 /proc/self/exe | tail -c 1)\r\n    [ \"$_current_exe_machine\" = \"$(printf '\\076')\" ]\r\n}\r\n\r\nget_endianness() {\r\n    local cputype=$1\r\n    local suffix_eb=$2\r\n    local suffix_el=$3\r\n\r\n    # detect endianness without od/hexdump, like get_bitness() does.\r\n    need_cmd head\r\n    need_cmd tail\r\n\r\n    local _current_exe_endianness\r\n    _current_exe_endianness=\"$(head -c 6 /proc/self/exe | tail -c 1)\"\r\n    if [ \"$_current_exe_endianness\" = \"$(printf '\\001')\" ]; then\r\n        echo \"${cputype}${suffix_el}\"\r\n    elif [ \"$_current_exe_endianness\" = \"$(printf '\\002')\" ]; then\r\n        echo \"${cputype}${suffix_eb}\"\r\n    else\r\n        err \"unknown platform endianness\"\r\n    fi\r\n}\r\n\r\nget_architecture() {\r\n    local _ostype _cputype _bitness _arch _clibtype\r\n    _ostype=\"$(uname -s)\"\r\n    _cputype=\"$(uname -m)\"\r\n    _clibtype=\"gnu\"\r\n\r\n    if [ \"$_ostype\" = Linux ]; then\r\n        if [ \"$(uname -o)\" = Android ]; then\r\n            _ostype=Android\r\n        fi\r\n        if ldd --version 2>&1 | grep -q 'musl'; then\r\n            _clibtype=\"musl\"\r\n        fi\r\n    fi\r\n\r\n    if [ \"$_ostype\" = Darwin ] && [ \"$_cputype\" = i386 ]; then\r\n        # Darwin `uname -m` lies\r\n        if sysctl hw.optional.x86_64 | grep -q ': 1'; then\r\n            _cputype=x86_64\r\n        fi\r\n    fi\r\n\r\n    if [ \"$_ostype\" = SunOS ]; then\r\n        # Both Solaris and illumos presently announce as \"SunOS\" in \"uname -s\"\r\n        # so use \"uname -o\" to disambiguate.  We use the full path to the\r\n        # system uname in case the user has coreutils uname first in PATH,\r\n        # which has historically sometimes printed the wrong value here.\r\n        if [ \"$(/usr/bin/uname -o)\" = illumos ]; then\r\n            _ostype=illumos\r\n        fi\r\n\r\n        # illumos systems have multi-arch userlands, and \"uname -m\" reports the\r\n        # machine hardware name; e.g., \"i86pc\" on both 32- and 64-bit x86\r\n        # systems.  Check for the native (widest) instruction set on the\r\n        # running kernel:\r\n        if [ \"$_cputype\" = i86pc ]; then\r\n            _cputype=\"$(isainfo -n)\"\r\n        fi\r\n    fi\r\n\r\n    case \"$_ostype\" in\r\n\r\n        Android)\r\n            _ostype=linux-android\r\n            ;;\r\n\r\n        Linux)\r\n            check_proc\r\n            _ostype=unknown-linux-$_clibtype\r\n            _bitness=$(get_bitness)\r\n            ;;\r\n\r\n        FreeBSD)\r\n            _ostype=unknown-freebsd\r\n            ;;\r\n\r\n        NetBSD)\r\n            _ostype=unknown-netbsd\r\n            ;;\r\n\r\n        DragonFly)\r\n            _ostype=unknown-dragonfly\r\n            ;;\r\n\r\n        Darwin)\r\n            _ostype=apple-darwin\r\n            ;;\r\n\r\n        illumos)\r\n            _ostype=unknown-illumos\r\n            ;;\r\n\r\n        MINGW* | MSYS* | CYGWIN* | Windows_NT)\r\n            _ostype=pc-windows-gnu\r\n            ;;\r\n\r\n        *)\r\n            err \"unrecognized OS type: $_ostype\"\r\n            ;;\r\n\r\n    esac\r\n\r\n    case \"$_cputype\" in\r\n\r\n        i386 | i486 | i686 | i786 | x86)\r\n            _cputype=i686\r\n            ;;\r\n\r\n        xscale | arm)\r\n            _cputype=arm\r\n            if [ \"$_ostype\" = \"linux-android\" ]; then\r\n                _ostype=linux-androideabi\r\n            fi\r\n            ;;\r\n\r\n        armv6l)\r\n            _cputype=arm\r\n            if [ \"$_ostype\" = \"linux-android\" ]; then\r\n                _ostype=linux-androideabi\r\n            else\r\n                _ostype=\"${_ostype}eabihf\"\r\n            fi\r\n            ;;\r\n\r\n        armv7l | armv8l)\r\n            _cputype=armv7\r\n            if [ \"$_ostype\" = \"linux-android\" ]; then\r\n                _ostype=linux-androideabi\r\n            else\r\n                _ostype=\"${_ostype}eabihf\"\r\n            fi\r\n            ;;\r\n\r\n        aarch64 | arm64)\r\n            _cputype=aarch64\r\n            ;;\r\n\r\n        x86_64 | x86-64 | x64 | amd64)\r\n            _cputype=x86_64\r\n            ;;\r\n\r\n        mips)\r\n            _cputype=$(get_endianness mips '' el)\r\n            ;;\r\n\r\n        mips64)\r\n            if [ \"$_bitness\" -eq 64 ]; then\r\n                # only n64 ABI is supported for now\r\n                _ostype=\"${_ostype}abi64\"\r\n                _cputype=$(get_endianness mips64 '' el)\r\n            fi\r\n            ;;\r\n\r\n        ppc)\r\n            _cputype=powerpc\r\n            ;;\r\n\r\n        ppc64)\r\n            _cputype=powerpc64\r\n            ;;\r\n\r\n        ppc64le)\r\n            _cputype=powerpc64le\r\n            ;;\r\n\r\n        s390x)\r\n            _cputype=s390x\r\n            ;;\r\n        riscv64)\r\n            _cputype=riscv64gc\r\n            ;;\r\n        *)\r\n            err \"unknown CPU type: $_cputype\"\r\n\r\n    esac\r\n\r\n    # Detect 64-bit linux with 32-bit userland\r\n    if [ \"${_ostype}\" = unknown-linux-gnu ] && [ \"${_bitness}\" -eq 32 ]; then\r\n        case $_cputype in\r\n            x86_64)\r\n                if [ -n \"${RUSTUP_CPUTYPE:-}\" ]; then\r\n                    _cputype=\"$RUSTUP_CPUTYPE\"\r\n                else {\r\n                    # 32-bit executable for amd64 = x32\r\n                    if is_host_amd64_elf; then {\r\n                         echo \"This host is running an x32 userland; as it stands, x32 support is poor,\" 1>&2\r\n                         echo \"and there isn't a native toolchain -- you will have to install\" 1>&2\r\n                         echo \"multiarch compatibility with i686 and/or amd64, then select one\" 1>&2\r\n                         echo \"by re-running this script with the RUSTUP_CPUTYPE environment variable\" 1>&2\r\n                         echo \"set to i686 or x86_64, respectively.\" 1>&2\r\n                         echo 1>&2\r\n                         echo \"You will be able to add an x32 target after installation by running\" 1>&2\r\n                         echo \"  rustup target add x86_64-unknown-linux-gnux32\" 1>&2\r\n                         exit 1\r\n                    }; else\r\n                        _cputype=i686\r\n                    fi\r\n                }; fi\r\n                ;;\r\n            mips64)\r\n                _cputype=$(get_endianness mips '' el)\r\n                ;;\r\n            powerpc64)\r\n                _cputype=powerpc\r\n                ;;\r\n            aarch64)\r\n                _cputype=armv7\r\n                if [ \"$_ostype\" = \"linux-android\" ]; then\r\n                    _ostype=linux-androideabi\r\n                else\r\n                    _ostype=\"${_ostype}eabihf\"\r\n                fi\r\n                ;;\r\n            riscv64gc)\r\n                err \"riscv64 with 32-bit userland unsupported\"\r\n                ;;\r\n        esac\r\n    fi\r\n\r\n    # Detect armv7 but without the CPU features Rust needs in that build,\r\n    # and fall back to arm.\r\n    # See https://github.com/rust-lang/rustup.rs/issues/587.\r\n    if [ \"$_ostype\" = \"unknown-linux-gnueabihf\" ] && [ \"$_cputype\" = armv7 ]; then\r\n        if ensure grep '^Features' /proc/cpuinfo | grep -q -v neon; then\r\n            # At least one processor does not have NEON.\r\n            _cputype=arm\r\n        fi\r\n    fi\r\n\r\n    _arch=\"${_cputype}-${_ostype}\"\r\n\r\n    RETVAL=\"$_arch\"\r\n}\r\n\r\nsay() {\r\n    printf 'rustup: %s\\n' \"$1\"\r\n}\r\n\r\nerr() {\r\n    say \"$1\" >&2\r\n    exit 1\r\n}\r\n\r\nneed_cmd() {\r\n    if ! check_cmd \"$1\"; then\r\n        err \"need '$1' (command not found)\"\r\n    fi\r\n}\r\n\r\ncheck_cmd() {\r\n    command -v \"$1\" > /dev/null 2>&1\r\n}\r\n\r\nassert_nz() {\r\n    if [ -z \"$1\" ]; then err \"assert_nz $2\"; fi\r\n}\r\n\r\n# Run a command that should never fail. If the command fails execution\r\n# will immediately terminate with an error showing the failing\r\n# command.\r\nensure() {\r\n    if ! \"$@\"; then err \"command failed: $*\"; fi\r\n}\r\n\r\n# This is just for indicating that commands' results are being\r\n# intentionally ignored. Usually, because it's being executed\r\n# as part of error handling.\r\nignore() {\r\n    \"$@\"\r\n}\r\n\r\n# This wraps curl or wget. Try curl first, if not installed,\r\n# use wget instead.\r\ndownloader() {\r\n    local _dld\r\n    local _ciphersuites\r\n    local _err\r\n    local _status\r\n    local _retry\r\n    if check_cmd curl; then\r\n        _dld=curl\r\n    elif check_cmd wget; then\r\n        _dld=wget\r\n    else\r\n        _dld='curl or wget' # to be used in error message of need_cmd\r\n    fi\r\n\r\n    if [ \"$1\" = --check ]; then\r\n        need_cmd \"$_dld\"\r\n    elif [ \"$_dld\" = curl ]; then\r\n        check_curl_for_retry_support\r\n        _retry=\"$RETVAL\"\r\n        get_ciphersuites_for_curl\r\n        _ciphersuites=\"$RETVAL\"\r\n        if [ -n \"$_ciphersuites\" ]; then\r\n            _err=$(curl $_retry --proto '=https' --tlsv1.2 --ciphers \"$_ciphersuites\" --silent --show-error --fail --location \"$1\" --output \"$2\" 2>&1)\r\n            _status=$?\r\n        else\r\n            echo \"Warning: Not enforcing strong cipher suites for TLS, this is potentially less secure\"\r\n            if ! check_help_for \"$3\" curl --proto --tlsv1.2; then\r\n                echo \"Warning: Not enforcing TLS v1.2, this is potentially less secure\"\r\n                _err=$(curl $_retry --silent --show-error --fail --location \"$1\" --output \"$2\" 2>&1)\r\n                _status=$?\r\n            else\r\n                _err=$(curl $_retry --proto '=https' --tlsv1.2 --silent --show-error --fail --location \"$1\" --output \"$2\" 2>&1)\r\n                _status=$?\r\n            fi\r\n        fi\r\n        if [ -n \"$_err\" ]; then\r\n            echo \"$_err\" >&2\r\n            if echo \"$_err\" | grep -q 404$; then\r\n                err \"installer for platform '$3' not found, this may be unsupported\"\r\n            fi\r\n        fi\r\n        return $_status\r\n    elif [ \"$_dld\" = wget ]; then\r\n        if [ \"$(wget -V 2>&1|head -2|tail -1|cut -f1 -d\" \")\" = \"BusyBox\" ]; then\r\n            echo \"Warning: using the BusyBox version of wget.  Not enforcing strong cipher suites for TLS or TLS v1.2, this is potentially less secure\"\r\n            _err=$(wget \"$1\" -O \"$2\" 2>&1)\r\n            _status=$?\r\n        else\r\n            get_ciphersuites_for_wget\r\n            _ciphersuites=\"$RETVAL\"\r\n            if [ -n \"$_ciphersuites\" ]; then\r\n                _err=$(wget --https-only --secure-protocol=TLSv1_2 --ciphers \"$_ciphersuites\" \"$1\" -O \"$2\" 2>&1)\r\n                _status=$?\r\n            else\r\n                echo \"Warning: Not enforcing strong cipher suites for TLS, this is potentially less secure\"\r\n                if ! check_help_for \"$3\" wget --https-only --secure-protocol; then\r\n                    echo \"Warning: Not enforcing TLS v1.2, this is potentially less secure\"\r\n                    _err=$(wget \"$1\" -O \"$2\" 2>&1)\r\n                    _status=$?\r\n                else\r\n                    _err=$(wget --https-only --secure-protocol=TLSv1_2 \"$1\" -O \"$2\" 2>&1)\r\n                    _status=$?\r\n                fi\r\n            fi\r\n        fi\r\n        if [ -n \"$_err\" ]; then\r\n            echo \"$_err\" >&2\r\n            if echo \"$_err\" | grep -q ' 404 Not Found$'; then\r\n                err \"installer for platform '$3' not found, this may be unsupported\"\r\n            fi\r\n        fi\r\n        return $_status\r\n    else\r\n        err \"Unknown downloader\"   # should not reach here\r\n    fi\r\n}\r\n\r\ncheck_help_for() {\r\n    local _arch\r\n    local _cmd\r\n    local _arg\r\n    _arch=\"$1\"\r\n    shift\r\n    _cmd=\"$1\"\r\n    shift\r\n\r\n    local _category\r\n    if \"$_cmd\" --help | grep -q 'For all options use the manual or \"--help all\".'; then\r\n      _category=\"all\"\r\n    else\r\n      _category=\"\"\r\n    fi\r\n\r\n    case \"$_arch\" in\r\n\r\n        *darwin*)\r\n        if check_cmd sw_vers; then\r\n            case $(sw_vers -productVersion) in\r\n                10.*)\r\n                    # If we're running on macOS, older than 10.13, then we always\r\n                    # fail to find these options to force fallback\r\n                    if [ \"$(sw_vers -productVersion | cut -d. -f2)\" -lt 13 ]; then\r\n                        # Older than 10.13\r\n                        echo \"Warning: Detected macOS platform older than 10.13\"\r\n                        return 1\r\n                    fi\r\n                    ;;\r\n                11.*)\r\n                    # We assume Big Sur will be OK for now\r\n                    ;;\r\n                *)\r\n                    # Unknown product version, warn and continue\r\n                    echo \"Warning: Detected unknown macOS major version: $(sw_vers -productVersion)\"\r\n                    echo \"Warning TLS capabilities detection may fail\"\r\n                    ;;\r\n            esac\r\n        fi\r\n        ;;\r\n\r\n    esac\r\n\r\n    for _arg in \"$@\"; do\r\n        if ! \"$_cmd\" --help $_category | grep -q -- \"$_arg\"; then\r\n            return 1\r\n        fi\r\n    done\r\n\r\n    true # not strictly needed\r\n}\r\n\r\n# Check if curl supports the --retry flag, then pass it to the curl invocation.\r\ncheck_curl_for_retry_support() {\r\n  local _retry_supported=\"\"\r\n  # \"unspecified\" is for arch, allows for possibility old OS using macports, homebrew, etc.\r\n  if check_help_for \"notspecified\" \"curl\" \"--retry\"; then\r\n    _retry_supported=\"--retry 3\"\r\n  fi\r\n\r\n  RETVAL=\"$_retry_supported\"\r\n\r\n}\r\n\r\n# Return cipher suite string specified by user, otherwise return strong TLS 1.2-1.3 cipher suites\r\n# if support by local tools is detected. Detection currently supports these curl backends:\r\n# GnuTLS and OpenSSL (possibly also LibreSSL and BoringSSL). Return value can be empty.\r\nget_ciphersuites_for_curl() {\r\n    if [ -n \"${RUSTUP_TLS_CIPHERSUITES-}\" ]; then\r\n        # user specified custom cipher suites, assume they know what they're doing\r\n        RETVAL=\"$RUSTUP_TLS_CIPHERSUITES\"\r\n        return\r\n    fi\r\n\r\n    local _openssl_syntax=\"no\"\r\n    local _gnutls_syntax=\"no\"\r\n    local _backend_supported=\"yes\"\r\n    if curl -V | grep -q ' OpenSSL/'; then\r\n        _openssl_syntax=\"yes\"\r\n    elif curl -V | grep -iq ' LibreSSL/'; then\r\n        _openssl_syntax=\"yes\"\r\n    elif curl -V | grep -iq ' BoringSSL/'; then\r\n        _openssl_syntax=\"yes\"\r\n    elif curl -V | grep -iq ' GnuTLS/'; then\r\n        _gnutls_syntax=\"yes\"\r\n    else\r\n        _backend_supported=\"no\"\r\n    fi\r\n\r\n    local _args_supported=\"no\"\r\n    if [ \"$_backend_supported\" = \"yes\" ]; then\r\n        # \"unspecified\" is for arch, allows for possibility old OS using macports, homebrew, etc.\r\n        if check_help_for \"notspecified\" \"curl\" \"--tlsv1.2\" \"--ciphers\" \"--proto\"; then\r\n            _args_supported=\"yes\"\r\n        fi\r\n    fi\r\n\r\n    local _cs=\"\"\r\n    if [ \"$_args_supported\" = \"yes\" ]; then\r\n        if [ \"$_openssl_syntax\" = \"yes\" ]; then\r\n            _cs=$(get_strong_ciphersuites_for \"openssl\")\r\n        elif [ \"$_gnutls_syntax\" = \"yes\" ]; then\r\n            _cs=$(get_strong_ciphersuites_for \"gnutls\")\r\n        fi\r\n    fi\r\n\r\n    RETVAL=\"$_cs\"\r\n}\r\n\r\n# Return cipher suite string specified by user, otherwise return strong TLS 1.2-1.3 cipher suites\r\n# if support by local tools is detected. Detection currently supports these wget backends:\r\n# GnuTLS and OpenSSL (possibly also LibreSSL and BoringSSL). Return value can be empty.\r\nget_ciphersuites_for_wget() {\r\n    if [ -n \"${RUSTUP_TLS_CIPHERSUITES-}\" ]; then\r\n        # user specified custom cipher suites, assume they know what they're doing\r\n        RETVAL=\"$RUSTUP_TLS_CIPHERSUITES\"\r\n        return\r\n    fi\r\n\r\n    local _cs=\"\"\r\n    if wget -V | grep -q '\\-DHAVE_LIBSSL'; then\r\n        # \"unspecified\" is for arch, allows for possibility old OS using macports, homebrew, etc.\r\n        if check_help_for \"notspecified\" \"wget\" \"TLSv1_2\" \"--ciphers\" \"--https-only\" \"--secure-protocol\"; then\r\n            _cs=$(get_strong_ciphersuites_for \"openssl\")\r\n        fi\r\n    elif wget -V | grep -q '\\-DHAVE_LIBGNUTLS'; then\r\n        # \"unspecified\" is for arch, allows for possibility old OS using macports, homebrew, etc.\r\n        if check_help_for \"notspecified\" \"wget\" \"TLSv1_2\" \"--ciphers\" \"--https-only\" \"--secure-protocol\"; then\r\n            _cs=$(get_strong_ciphersuites_for \"gnutls\")\r\n        fi\r\n    fi\r\n\r\n    RETVAL=\"$_cs\"\r\n}\r\n\r\n# Return strong TLS 1.2-1.3 cipher suites in OpenSSL or GnuTLS syntax. TLS 1.2\r\n# excludes non-ECDHE and non-AEAD cipher suites. DHE is excluded due to bad\r\n# DH params often found on servers (see RFC 7919). Sequence matches or is\r\n# similar to Firefox 68 ESR with weak cipher suites disabled via about:config.\r\n# $1 must be openssl or gnutls.\r\nget_strong_ciphersuites_for() {\r\n    if [ \"$1\" = \"openssl\" ]; then\r\n        # OpenSSL is forgiving of unknown values, no problems with TLS 1.3 values on versions that don't support it yet.\r\n        echo \"TLS_AES_128_GCM_SHA256:TLS_CHACHA20_POLY1305_SHA256:TLS_AES_256_GCM_SHA384:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384\"\r\n    elif [ \"$1\" = \"gnutls\" ]; then\r\n        # GnuTLS isn't forgiving of unknown values, so this may require a GnuTLS version that supports TLS 1.3 even if wget doesn't.\r\n        # Begin with SECURE128 (and higher) then remove/add to build cipher suites. Produces same 9 cipher suites as OpenSSL but in slightly different order.\r\n        echo \"SECURE128:-VERS-SSL3.0:-VERS-TLS1.0:-VERS-TLS1.1:-VERS-DTLS-ALL:-CIPHER-ALL:-MAC-ALL:-KX-ALL:+AEAD:+ECDHE-ECDSA:+ECDHE-RSA:+AES-128-GCM:+CHACHA20-POLY1305:+AES-256-GCM\"\r\n    fi\r\n}\r\n\r\nmain \"$@\" || exit 1\r\ncurl: (6) Could not resolve host: |\r\ncurl: (6) Could not resolve host: sh", "stdout_lines": ["#!/bin/sh", "# shellcheck shell=dash", "", "# This is just a little script that can be downloaded from the internet to", "# install rustup. It just does platform detection, downloads the installer", "# and runs it.", "", "# It runs on Unix shells like {a,ba,da,k,z}sh. It uses the common `local`", "# extension. Note: Most shells limit `local` to 1 var per line, contra bash.", "", "if [ \"$KSH_VERSION\" = 'Version JM 93t+ 2010-03-05' ]; then", "    # The version of ksh93 that ships with many illumos systems does not", "    # support the \"local\" extension.  Print a message rather than fail in", "    # subtle ways later on:", "    echo 'rustup does not work with this ksh93 version; please try bash!' >&2", "    exit 1", "fi", "", "", "set -u", "", "# If RUSTUP_UPDATE_ROOT is unset or empty, default it.", "RUSTUP_UPDATE_ROOT=\"${RUSTUP_UPDATE_ROOT:-https://static.rust-lang.org/rustup}\"", "", "#XXX: If you change anything here, please make the same changes in setup_mode.rs", "usage() {", "    cat 1>&2 <<EOF", "rustup-init 1.25.1 (48d233f65 2022-07-12)", "The installer for rustup", "", "USAGE:", "    rustup-init [FLAGS] [OPTIONS]", "", "FLAGS:", "    -v, --verbose           Enable verbose output", "    -q, --quiet             Disable progress output", "    -y                      Disable confirmation prompt.", "        --no-modify-path    Don't configure the PATH environment variable", "    -h, --help              Prints help information", "    -V, --version           Prints version information", "", "OPTIONS:", "        --default-host <default-host>              Choose a default host triple", "        --default-toolchain <default-toolchain>    Choose a default toolchain to install", "        --default-toolchain none                   Do not install any toolchains", "        --profile [minimal|default|complete]       Choose a profile", "    -c, --component <components>...                Component name to also install", "    -t, --target <targets>...                      Target name to also install", "EOF", "}", "", "main() {", "    downloader --check", "    need_cmd uname", "    need_cmd mktemp", "    need_cmd chmod", "    need_cmd mkdir", "    need_cmd rm", "    need_cmd rmdir", "", "    get_architecture || return 1", "    local _arch=\"$RETVAL\"", "    assert_nz \"$_arch\" \"arch\"", "", "    local _ext=\"\"", "    case \"$_arch\" in", "        *windows*)", "            _ext=\".exe\"", "            ;;", "    esac", "", "    local _url=\"${RUSTUP_UPDATE_ROOT}/dist/${_arch}/rustup-init${_ext}\"", "", "    local _dir", "    _dir=\"$(ensure mktemp -d)\"", "    local _file=\"${_dir}/rustup-init${_ext}\"", "", "    local _ansi_escapes_are_valid=false", "    if [ -t 2 ]; then", "        if [ \"${TERM+set}\" = 'set' ]; then", "            case \"$TERM\" in", "                xterm*|rxvt*|urxvt*|linux*|vt*)", "                    _ansi_escapes_are_valid=true", "                ;;", "            esac", "        fi", "    fi", "", "    # check if we have to use /dev/tty to prompt the user", "    local need_tty=yes", "    for arg in \"$@\"; do", "        case \"$arg\" in", "            --help)", "                usage", "                exit 0", "                ;;", "            *)", "                OPTIND=1", "                if [ \"${arg%%--*}\" = \"\" ]; then", "                    # Long option (other than --help);", "                    # don't attempt to interpret it.", "                    continue", "                fi", "                while getopts :hy sub_arg \"$arg\"; do", "                    case \"$sub_arg\" in", "                        h)", "                            usage", "                            exit 0", "                            ;;", "                        y)", "                            # user wants to skip the prompt --", "                            # we don't need /dev/tty", "                            need_tty=no", "                            ;;", "                        *)", "                            ;;", "                        esac", "                done", "                ;;", "        esac", "    done", "", "    if $_ansi_escapes_are_valid; then", "        printf \"\\33[1minfo:\\33[0m downloading installer\\n\" 1>&2", "    else", "        printf '%s\\n' 'info: downloading installer' 1>&2", "    fi", "", "    ensure mkdir -p \"$_dir\"", "    ensure downloader \"$_url\" \"$_file\" \"$_arch\"", "    ensure chmod u+x \"$_file\"", "    if [ ! -x \"$_file\" ]; then", "        printf '%s\\n' \"Cannot execute $_file (likely because of mounting /tmp as noexec).\" 1>&2", "        printf '%s\\n' \"Please copy the file to a location where you can execute binaries and run ./rustup-init${_ext}.\" 1>&2", "        exit 1", "    fi", "", "    if [ \"$need_tty\" = \"yes\" ] && [ ! -t 0 ]; then", "        # The installer is going to want to ask for confirmation by", "        # reading stdin.  This script was piped into `sh` though and", "        # doesn't have stdin to pass to its children. Instead we're going", "        # to explicitly connect /dev/tty to the installer's stdin.", "        if [ ! -t 1 ]; then", "            err \"Unable to run interactively. Run with -y to accept defaults, --help for additional options\"", "        fi", "", "        ignore \"$_file\" \"$@\" < /dev/tty", "    else", "        ignore \"$_file\" \"$@\"", "    fi", "", "    local _retval=$?", "", "    ignore rm \"$_file\"", "    ignore rmdir \"$_dir\"", "", "    return \"$_retval\"", "}", "", "check_proc() {", "    # Check for /proc by looking for the /proc/self/exe link", "    # This is only run on Linux", "    if ! test -L /proc/self/exe ; then", "        err \"fatal: Unable to find /proc/self/exe.  Is /proc mounted?  Installation cannot proceed without /proc.\"", "    fi", "}", "", "get_bitness() {", "    need_cmd head", "    # Architecture detection without dependencies beyond coreutils.", "    # ELF files start out \"\\x7fELF\", and the following byte is", "    #   0x01 for 32-bit and", "    #   0x02 for 64-bit.", "    # The printf builtin on some shells like dash only supports octal", "    # escape sequences, so we use those.", "    local _current_exe_head", "    _current_exe_head=$(head -c 5 /proc/self/exe )", "    if [ \"$_current_exe_head\" = \"$(printf '\\177ELF\\001')\" ]; then", "        echo 32", "    elif [ \"$_current_exe_head\" = \"$(printf '\\177ELF\\002')\" ]; then", "        echo 64", "    else", "        err \"unknown platform bitness\"", "    fi", "}", "", "is_host_amd64_elf() {", "    need_cmd head", "    need_cmd tail", "    # ELF e_machine detection without dependencies beyond coreutils.", "    # Two-byte field at offset 0x12 indicates the CPU,", "    # but we're interested in it being 0x3E to indicate amd64, or not that.", "    local _current_exe_machine", "    _current_exe_machine=$(head -c 19 /proc/self/exe | tail -c 1)", "    [ \"$_current_exe_machine\" = \"$(printf '\\076')\" ]", "}", "", "get_endianness() {", "    local cputype=$1", "    local suffix_eb=$2", "    local suffix_el=$3", "", "    # detect endianness without od/hexdump, like get_bitness() does.", "    need_cmd head", "    need_cmd tail", "", "    local _current_exe_endianness", "    _current_exe_endianness=\"$(head -c 6 /proc/self/exe | tail -c 1)\"", "    if [ \"$_current_exe_endianness\" = \"$(printf '\\001')\" ]; then", "        echo \"${cputype}${suffix_el}\"", "    elif [ \"$_current_exe_endianness\" = \"$(printf '\\002')\" ]; then", "        echo \"${cputype}${suffix_eb}\"", "    else", "        err \"unknown platform endianness\"", "    fi", "}", "", "get_architecture() {", "    local _ostype _cputype _bitness _arch _clibtype", "    _ostype=\"$(uname -s)\"", "    _cputype=\"$(uname -m)\"", "    _clibtype=\"gnu\"", "", "    if [ \"$_ostype\" = Linux ]; then", "        if [ \"$(uname -o)\" = Android ]; then", "            _ostype=Android", "        fi", "        if ldd --version 2>&1 | grep -q 'musl'; then", "            _clibtype=\"musl\"", "        fi", "    fi", "", "    if [ \"$_ostype\" = Darwin ] && [ \"$_cputype\" = i386 ]; then", "        # Darwin `uname -m` lies", "        if sysctl hw.optional.x86_64 | grep -q ': 1'; then", "            _cputype=x86_64", "        fi", "    fi", "", "    if [ \"$_ostype\" = SunOS ]; then", "        # Both Solaris and illumos presently announce as \"SunOS\" in \"uname -s\"", "        # so use \"uname -o\" to disambiguate.  We use the full path to the", "        # system uname in case the user has coreutils uname first in PATH,", "        # which has historically sometimes printed the wrong value here.", "        if [ \"$(/usr/bin/uname -o)\" = illumos ]; then", "            _ostype=illumos", "        fi", "", "        # illumos systems have multi-arch userlands, and \"uname -m\" reports the", "        # machine hardware name; e.g., \"i86pc\" on both 32- and 64-bit x86", "        # systems.  Check for the native (widest) instruction set on the", "        # running kernel:", "        if [ \"$_cputype\" = i86pc ]; then", "            _cputype=\"$(isainfo -n)\"", "        fi", "    fi", "", "    case \"$_ostype\" in", "", "        Android)", "            _ostype=linux-android", "            ;;", "", "        Linux)", "            check_proc", "            _ostype=unknown-linux-$_clibtype", "            _bitness=$(get_bitness)", "            ;;", "", "        FreeBSD)", "            _ostype=unknown-freebsd", "            ;;", "", "        NetBSD)", "            _ostype=unknown-netbsd", "            ;;", "", "        DragonFly)", "            _ostype=unknown-dragonfly", "            ;;", "", "        Darwin)", "            _ostype=apple-darwin", "            ;;", "", "        illumos)", "            _ostype=unknown-illumos", "            ;;", "", "        MINGW* | MSYS* | CYGWIN* | Windows_NT)", "            _ostype=pc-windows-gnu", "            ;;", "", "        *)", "            err \"unrecognized OS type: $_ostype\"", "            ;;", "", "    esac", "", "    case \"$_cputype\" in", "", "        i386 | i486 | i686 | i786 | x86)", "            _cputype=i686", "            ;;", "", "        xscale | arm)", "            _cputype=arm", "            if [ \"$_ostype\" = \"linux-android\" ]; then", "                _ostype=linux-androideabi", "            fi", "            ;;", "", "        armv6l)", "            _cputype=arm", "            if [ \"$_ostype\" = \"linux-android\" ]; then", "                _ostype=linux-androideabi", "            else", "                _ostype=\"${_ostype}eabihf\"", "            fi", "            ;;", "", "        armv7l | armv8l)", "            _cputype=armv7", "            if [ \"$_ostype\" = \"linux-android\" ]; then", "                _ostype=linux-androideabi", "            else", "                _ostype=\"${_ostype}eabihf\"", "            fi", "            ;;", "", "        aarch64 | arm64)", "            _cputype=aarch64", "            ;;", "", "        x86_64 | x86-64 | x64 | amd64)", "            _cputype=x86_64", "            ;;", "", "        mips)", "            _cputype=$(get_endianness mips '' el)", "            ;;", "", "        mips64)", "            if [ \"$_bitness\" -eq 64 ]; then", "                # only n64 ABI is supported for now", "                _ostype=\"${_ostype}abi64\"", "                _cputype=$(get_endianness mips64 '' el)", "            fi", "            ;;", "", "        ppc)", "            _cputype=powerpc", "            ;;", "", "        ppc64)", "            _cputype=powerpc64", "            ;;", "", "        ppc64le)", "            _cputype=powerpc64le", "            ;;", "", "        s390x)", "            _cputype=s390x", "            ;;", "        riscv64)", "            _cputype=riscv64gc", "            ;;", "        *)", "            err \"unknown CPU type: $_cputype\"", "", "    esac", "", "    # Detect 64-bit linux with 32-bit userland", "    if [ \"${_ostype}\" = unknown-linux-gnu ] && [ \"${_bitness}\" -eq 32 ]; then", "        case $_cputype in", "            x86_64)", "                if [ -n \"${RUSTUP_CPUTYPE:-}\" ]; then", "                    _cputype=\"$RUSTUP_CPUTYPE\"", "                else {", "                    # 32-bit executable for amd64 = x32", "                    if is_host_amd64_elf; then {", "                         echo \"This host is running an x32 userland; as it stands, x32 support is poor,\" 1>&2", "                         echo \"and there isn't a native toolchain -- you will have to install\" 1>&2", "                         echo \"multiarch compatibility with i686 and/or amd64, then select one\" 1>&2", "                         echo \"by re-running this script with the RUSTUP_CPUTYPE environment variable\" 1>&2", "                         echo \"set to i686 or x86_64, respectively.\" 1>&2", "                         echo 1>&2", "                         echo \"You will be able to add an x32 target after installation by running\" 1>&2", "                         echo \"  rustup target add x86_64-unknown-linux-gnux32\" 1>&2", "                         exit 1", "                    }; else", "                        _cputype=i686", "                    fi", "                }; fi", "                ;;", "            mips64)", "                _cputype=$(get_endianness mips '' el)", "                ;;", "            powerpc64)", "                _cputype=powerpc", "                ;;", "            aarch64)", "                _cputype=armv7", "                if [ \"$_ostype\" = \"linux-android\" ]; then", "                    _ostype=linux-androideabi", "                else", "                    _ostype=\"${_ostype}eabihf\"", "                fi", "                ;;", "            riscv64gc)", "                err \"riscv64 with 32-bit userland unsupported\"", "                ;;", "        esac", "    fi", "", "    # Detect armv7 but without the CPU features Rust needs in that build,", "    # and fall back to arm.", "    # See https://github.com/rust-lang/rustup.rs/issues/587.", "    if [ \"$_ostype\" = \"unknown-linux-gnueabihf\" ] && [ \"$_cputype\" = armv7 ]; then", "        if ensure grep '^Features' /proc/cpuinfo | grep -q -v neon; then", "            # At least one processor does not have NEON.", "            _cputype=arm", "        fi", "    fi", "", "    _arch=\"${_cputype}-${_ostype}\"", "", "    RETVAL=\"$_arch\"", "}", "", "say() {", "    printf 'rustup: %s\\n' \"$1\"", "}", "", "err() {", "    say \"$1\" >&2", "    exit 1", "}", "", "need_cmd() {", "    if ! check_cmd \"$1\"; then", "        err \"need '$1' (command not found)\"", "    fi", "}", "", "check_cmd() {", "    command -v \"$1\" > /dev/null 2>&1", "}", "", "assert_nz() {", "    if [ -z \"$1\" ]; then err \"assert_nz $2\"; fi", "}", "", "# Run a command that should never fail. If the command fails execution", "# will immediately terminate with an error showing the failing", "# command.", "ensure() {", "    if ! \"$@\"; then err \"command failed: $*\"; fi", "}", "", "# This is just for indicating that commands' results are being", "# intentionally ignored. Usually, because it's being executed", "# as part of error handling.", "ignore() {", "    \"$@\"", "}", "", "# This wraps curl or wget. Try curl first, if not installed,", "# use wget instead.", "downloader() {", "    local _dld", "    local _ciphersuites", "    local _err", "    local _status", "    local _retry", "    if check_cmd curl; then", "        _dld=curl", "    elif check_cmd wget; then", "        _dld=wget", "    else", "        _dld='curl or wget' # to be used in error message of need_cmd", "    fi", "", "    if [ \"$1\" = --check ]; then", "        need_cmd \"$_dld\"", "    elif [ \"$_dld\" = curl ]; then", "        check_curl_for_retry_support", "        _retry=\"$RETVAL\"", "        get_ciphersuites_for_curl", "        _ciphersuites=\"$RETVAL\"", "        if [ -n \"$_ciphersuites\" ]; then", "            _err=$(curl $_retry --proto '=https' --tlsv1.2 --ciphers \"$_ciphersuites\" --silent --show-error --fail --location \"$1\" --output \"$2\" 2>&1)", "            _status=$?", "        else", "            echo \"Warning: Not enforcing strong cipher suites for TLS, this is potentially less secure\"", "            if ! check_help_for \"$3\" curl --proto --tlsv1.2; then", "                echo \"Warning: Not enforcing TLS v1.2, this is potentially less secure\"", "                _err=$(curl $_retry --silent --show-error --fail --location \"$1\" --output \"$2\" 2>&1)", "                _status=$?", "            else", "                _err=$(curl $_retry --proto '=https' --tlsv1.2 --silent --show-error --fail --location \"$1\" --output \"$2\" 2>&1)", "                _status=$?", "            fi", "        fi", "        if [ -n \"$_err\" ]; then", "            echo \"$_err\" >&2", "            if echo \"$_err\" | grep -q 404$; then", "                err \"installer for platform '$3' not found, this may be unsupported\"", "            fi", "        fi", "        return $_status", "    elif [ \"$_dld\" = wget ]; then", "        if [ \"$(wget -V 2>&1|head -2|tail -1|cut -f1 -d\" \")\" = \"BusyBox\" ]; then", "            echo \"Warning: using the BusyBox version of wget.  Not enforcing strong cipher suites for TLS or TLS v1.2, this is potentially less secure\"", "            _err=$(wget \"$1\" -O \"$2\" 2>&1)", "            _status=$?", "        else", "            get_ciphersuites_for_wget", "            _ciphersuites=\"$RETVAL\"", "            if [ -n \"$_ciphersuites\" ]; then", "                _err=$(wget --https-only --secure-protocol=TLSv1_2 --ciphers \"$_ciphersuites\" \"$1\" -O \"$2\" 2>&1)", "                _status=$?", "            else", "                echo \"Warning: Not enforcing strong cipher suites for TLS, this is potentially less secure\"", "                if ! check_help_for \"$3\" wget --https-only --secure-protocol; then", "                    echo \"Warning: Not enforcing TLS v1.2, this is potentially less secure\"", "                    _err=$(wget \"$1\" -O \"$2\" 2>&1)", "                    _status=$?", "                else", "                    _err=$(wget --https-only --secure-protocol=TLSv1_2 \"$1\" -O \"$2\" 2>&1)", "                    _status=$?", "                fi", "            fi", "        fi", "        if [ -n \"$_err\" ]; then", "            echo \"$_err\" >&2", "            if echo \"$_err\" | grep -q ' 404 Not Found$'; then", "                err \"installer for platform '$3' not found, this may be unsupported\"", "            fi", "        fi", "        return $_status", "    else", "        err \"Unknown downloader\"   # should not reach here", "    fi", "}", "", "check_help_for() {", "    local _arch", "    local _cmd", "    local _arg", "    _arch=\"$1\"", "    shift", "    _cmd=\"$1\"", "    shift", "", "    local _category", "    if \"$_cmd\" --help | grep -q 'For all options use the manual or \"--help all\".'; then", "      _category=\"all\"", "    else", "      _category=\"\"", "    fi", "", "    case \"$_arch\" in", "", "        *darwin*)", "        if check_cmd sw_vers; then", "            case $(sw_vers -productVersion) in", "                10.*)", "                    # If we're running on macOS, older than 10.13, then we always", "                    # fail to find these options to force fallback", "                    if [ \"$(sw_vers -productVersion | cut -d. -f2)\" -lt 13 ]; then", "                        # Older than 10.13", "                        echo \"Warning: Detected macOS platform older than 10.13\"", "                        return 1", "                    fi", "                    ;;", "                11.*)", "                    # We assume Big Sur will be OK for now", "                    ;;", "                *)", "                    # Unknown product version, warn and continue", "                    echo \"Warning: Detected unknown macOS major version: $(sw_vers -productVersion)\"", "                    echo \"Warning TLS capabilities detection may fail\"", "                    ;;", "            esac", "        fi", "        ;;", "", "    esac", "", "    for _arg in \"$@\"; do", "        if ! \"$_cmd\" --help $_category | grep -q -- \"$_arg\"; then", "            return 1", "        fi", "    done", "", "    true # not strictly needed", "}", "", "# Check if curl supports the --retry flag, then pass it to the curl invocation.", "check_curl_for_retry_support() {", "  local _retry_supported=\"\"", "  # \"unspecified\" is for arch, allows for possibility old OS using macports, homebrew, etc.", "  if check_help_for \"notspecified\" \"curl\" \"--retry\"; then", "    _retry_supported=\"--retry 3\"", "  fi", "", "  RETVAL=\"$_retry_supported\"", "", "}", "", "# Return cipher suite string specified by user, otherwise return strong TLS 1.2-1.3 cipher suites", "# if support by local tools is detected. Detection currently supports these curl backends:", "# GnuTLS and OpenSSL (possibly also LibreSSL and BoringSSL). Return value can be empty.", "get_ciphersuites_for_curl() {", "    if [ -n \"${RUSTUP_TLS_CIPHERSUITES-}\" ]; then", "        # user specified custom cipher suites, assume they know what they're doing", "        RETVAL=\"$RUSTUP_TLS_CIPHERSUITES\"", "        return", "    fi", "", "    local _openssl_syntax=\"no\"", "    local _gnutls_syntax=\"no\"", "    local _backend_supported=\"yes\"", "    if curl -V | grep -q ' OpenSSL/'; then", "        _openssl_syntax=\"yes\"", "    elif curl -V | grep -iq ' LibreSSL/'; then", "        _openssl_syntax=\"yes\"", "    elif curl -V | grep -iq ' BoringSSL/'; then", "        _openssl_syntax=\"yes\"", "    elif curl -V | grep -iq ' GnuTLS/'; then", "        _gnutls_syntax=\"yes\"", "    else", "        _backend_supported=\"no\"", "    fi", "", "    local _args_supported=\"no\"", "    if [ \"$_backend_supported\" = \"yes\" ]; then", "        # \"unspecified\" is for arch, allows for possibility old OS using macports, homebrew, etc.", "        if check_help_for \"notspecified\" \"curl\" \"--tlsv1.2\" \"--ciphers\" \"--proto\"; then", "            _args_supported=\"yes\"", "        fi", "    fi", "", "    local _cs=\"\"", "    if [ \"$_args_supported\" = \"yes\" ]; then", "        if [ \"$_openssl_syntax\" = \"yes\" ]; then", "            _cs=$(get_strong_ciphersuites_for \"openssl\")", "        elif [ \"$_gnutls_syntax\" = \"yes\" ]; then", "            _cs=$(get_strong_ciphersuites_for \"gnutls\")", "        fi", "    fi", "", "    RETVAL=\"$_cs\"", "}", "", "# Return cipher suite string specified by user, otherwise return strong TLS 1.2-1.3 cipher suites", "# if support by local tools is detected. Detection currently supports these wget backends:", "# GnuTLS and OpenSSL (possibly also LibreSSL and BoringSSL). Return value can be empty.", "get_ciphersuites_for_wget() {", "    if [ -n \"${RUSTUP_TLS_CIPHERSUITES-}\" ]; then", "        # user specified custom cipher suites, assume they know what they're doing", "        RETVAL=\"$RUSTUP_TLS_CIPHERSUITES\"", "        return", "    fi", "", "    local _cs=\"\"", "    if wget -V | grep -q '\\-DHAVE_LIBSSL'; then", "        # \"unspecified\" is for arch, allows for possibility old OS using macports, homebrew, etc.", "        if check_help_for \"notspecified\" \"wget\" \"TLSv1_2\" \"--ciphers\" \"--https-only\" \"--secure-protocol\"; then", "            _cs=$(get_strong_ciphersuites_for \"openssl\")", "        fi", "    elif wget -V | grep -q '\\-DHAVE_LIBGNUTLS'; then", "        # \"unspecified\" is for arch, allows for possibility old OS using macports, homebrew, etc.", "        if check_help_for \"notspecified\" \"wget\" \"TLSv1_2\" \"--ciphers\" \"--https-only\" \"--secure-protocol\"; then", "            _cs=$(get_strong_ciphersuites_for \"gnutls\")", "        fi", "    fi", "", "    RETVAL=\"$_cs\"", "}", "", "# Return strong TLS 1.2-1.3 cipher suites in OpenSSL or GnuTLS syntax. TLS 1.2", "# excludes non-ECDHE and non-AEAD cipher suites. DHE is excluded due to bad", "# DH params often found on servers (see RFC 7919). Sequence matches or is", "# similar to Firefox 68 ESR with weak cipher suites disabled via about:config.", "# $1 must be openssl or gnutls.", "get_strong_ciphersuites_for() {", "    if [ \"$1\" = \"openssl\" ]; then", "        # OpenSSL is forgiving of unknown values, no problems with TLS 1.3 values on versions that don't support it yet.", "        echo \"TLS_AES_128_GCM_SHA256:TLS_CHACHA20_POLY1305_SHA256:TLS_AES_256_GCM_SHA384:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384\"", "    elif [ \"$1\" = \"gnutls\" ]; then", "        # GnuTLS isn't forgiving of unknown values, so this may require a GnuTLS version that supports TLS 1.3 even if wget doesn't.", "        # Begin with SECURE128 (and higher) then remove/add to build cipher suites. Produces same 9 cipher suites as OpenSSL but in slightly different order.", "        echo \"SECURE128:-VERS-SSL3.0:-VERS-TLS1.0:-VERS-TLS1.1:-VERS-DTLS-ALL:-CIPHER-ALL:-MAC-ALL:-KX-ALL:+AEAD:+ECDHE-ECDSA:+ECDHE-RSA:+AES-128-GCM:+CHACHA20-POLY1305:+AES-256-GCM\"", "    fi", "}", "", "main \"$@\" || exit 1", "curl: (6) Could not resolve host: |", "curl: (6) Could not resolve host: sh"]}
2022-12-30 00:12:00,785 p=91007 u=kal n=ansible | PLAY RECAP *******************************************************************************************************************************************
2022-12-30 00:12:00,785 p=91007 u=kal n=ansible | krpz                       : ok=1    changed=0    unreachable=0    failed=1    skipped=0    rescued=0    ignored=0   
2022-12-30 00:12:23,708 p=91217 u=kal n=ansible | PLAY [localhost] *************************************************************************************************************************************
2022-12-30 00:12:23,715 p=91217 u=kal n=ansible | TASK [Gathering Facts] *******************************************************************************************************************************
2022-12-30 00:12:27,664 p=91217 u=kal n=ansible | ok: [krpz]
2022-12-30 00:12:27,688 p=91217 u=kal n=ansible | TASK [Install Rust] **********************************************************************************************************************************
2022-12-30 00:12:29,835 p=91217 u=kal n=ansible | fatal: [krpz]: FAILED! => {"changed": true, "cmd": "curl https://sh.rustup.rs | sh", "delta": "0:00:01.957002", "end": "2022-12-30 00:12:29.805055", "msg": "non-zero return code", "rc": 6, "start": "2022-12-30 00:12:27.848053", "stdout": "#!/bin/sh\r\n# shellcheck shell=dash\r\n\r\n# This is just a little script that can be downloaded from the internet to\r\n# install rustup. It just does platform detection, downloads the installer\r\n# and runs it.\r\n\r\n# It runs on Unix shells like {a,ba,da,k,z}sh. It uses the common `local`\r\n# extension. Note: Most shells limit `local` to 1 var per line, contra bash.\r\n\r\nif [ \"$KSH_VERSION\" = 'Version JM 93t+ 2010-03-05' ]; then\r\n    # The version of ksh93 that ships with many illumos systems does not\r\n    # support the \"local\" extension.  Print a message rather than fail in\r\n    # subtle ways later on:\r\n    echo 'rustup does not work with this ksh93 version; please try bash!' >&2\r\n    exit 1\r\nfi\r\n\r\n\r\nset -u\r\n\r\n# If RUSTUP_UPDATE_ROOT is unset or empty, default it.\r\nRUSTUP_UPDATE_ROOT=\"${RUSTUP_UPDATE_ROOT:-https://static.rust-lang.org/rustup}\"\r\n\r\n#XXX: If you change anything here, please make the same changes in setup_mode.rs\r\nusage() {\r\n    cat 1>&2 <<EOF\r\nrustup-init 1.25.1 (48d233f65 2022-07-12)\r\nThe installer for rustup\r\n\r\nUSAGE:\r\n    rustup-init [FLAGS] [OPTIONS]\r\n\r\nFLAGS:\r\n    -v, --verbose           Enable verbose output\r\n    -q, --quiet             Disable progress output\r\n    -y                      Disable confirmation prompt.\r\n        --no-modify-path    Don't configure the PATH environment variable\r\n    -h, --help              Prints help information\r\n    -V, --version           Prints version information\r\n\r\nOPTIONS:\r\n        --default-host <default-host>              Choose a default host triple\r\n        --default-toolchain <default-toolchain>    Choose a default toolchain to install\r\n        --default-toolchain none                   Do not install any toolchains\r\n        --profile [minimal|default|complete]       Choose a profile\r\n    -c, --component <components>...                Component name to also install\r\n    -t, --target <targets>...                      Target name to also install\r\nEOF\r\n}\r\n\r\nmain() {\r\n    downloader --check\r\n    need_cmd uname\r\n    need_cmd mktemp\r\n    need_cmd chmod\r\n    need_cmd mkdir\r\n    need_cmd rm\r\n    need_cmd rmdir\r\n\r\n    get_architecture || return 1\r\n    local _arch=\"$RETVAL\"\r\n    assert_nz \"$_arch\" \"arch\"\r\n\r\n    local _ext=\"\"\r\n    case \"$_arch\" in\r\n        *windows*)\r\n            _ext=\".exe\"\r\n            ;;\r\n    esac\r\n\r\n    local _url=\"${RUSTUP_UPDATE_ROOT}/dist/${_arch}/rustup-init${_ext}\"\r\n\r\n    local _dir\r\n    _dir=\"$(ensure mktemp -d)\"\r\n    local _file=\"${_dir}/rustup-init${_ext}\"\r\n\r\n    local _ansi_escapes_are_valid=false\r\n    if [ -t 2 ]; then\r\n        if [ \"${TERM+set}\" = 'set' ]; then\r\n            case \"$TERM\" in\r\n                xterm*|rxvt*|urxvt*|linux*|vt*)\r\n                    _ansi_escapes_are_valid=true\r\n                ;;\r\n            esac\r\n        fi\r\n    fi\r\n\r\n    # check if we have to use /dev/tty to prompt the user\r\n    local need_tty=yes\r\n    for arg in \"$@\"; do\r\n        case \"$arg\" in\r\n            --help)\r\n                usage\r\n                exit 0\r\n                ;;\r\n            *)\r\n                OPTIND=1\r\n                if [ \"${arg%%--*}\" = \"\" ]; then\r\n                    # Long option (other than --help);\r\n                    # don't attempt to interpret it.\r\n                    continue\r\n                fi\r\n                while getopts :hy sub_arg \"$arg\"; do\r\n                    case \"$sub_arg\" in\r\n                        h)\r\n                            usage\r\n                            exit 0\r\n                            ;;\r\n                        y)\r\n                            # user wants to skip the prompt --\r\n                            # we don't need /dev/tty\r\n                            need_tty=no\r\n                            ;;\r\n                        *)\r\n                            ;;\r\n                        esac\r\n                done\r\n                ;;\r\n        esac\r\n    done\r\n\r\n    if $_ansi_escapes_are_valid; then\r\n        printf \"\\33[1minfo:\\33[0m downloading installer\\n\" 1>&2\r\n    else\r\n        printf '%s\\n' 'info: downloading installer' 1>&2\r\n    fi\r\n\r\n    ensure mkdir -p \"$_dir\"\r\n    ensure downloader \"$_url\" \"$_file\" \"$_arch\"\r\n    ensure chmod u+x \"$_file\"\r\n    if [ ! -x \"$_file\" ]; then\r\n        printf '%s\\n' \"Cannot execute $_file (likely because of mounting /tmp as noexec).\" 1>&2\r\n        printf '%s\\n' \"Please copy the file to a location where you can execute binaries and run ./rustup-init${_ext}.\" 1>&2\r\n        exit 1\r\n    fi\r\n\r\n    if [ \"$need_tty\" = \"yes\" ] && [ ! -t 0 ]; then\r\n        # The installer is going to want to ask for confirmation by\r\n        # reading stdin.  This script was piped into `sh` though and\r\n        # doesn't have stdin to pass to its children. Instead we're going\r\n        # to explicitly connect /dev/tty to the installer's stdin.\r\n        if [ ! -t 1 ]; then\r\n            err \"Unable to run interactively. Run with -y to accept defaults, --help for additional options\"\r\n        fi\r\n\r\n        ignore \"$_file\" \"$@\" < /dev/tty\r\n    else\r\n        ignore \"$_file\" \"$@\"\r\n    fi\r\n\r\n    local _retval=$?\r\n\r\n    ignore rm \"$_file\"\r\n    ignore rmdir \"$_dir\"\r\n\r\n    return \"$_retval\"\r\n}\r\n\r\ncheck_proc() {\r\n    # Check for /proc by looking for the /proc/self/exe link\r\n    # This is only run on Linux\r\n    if ! test -L /proc/self/exe ; then\r\n        err \"fatal: Unable to find /proc/self/exe.  Is /proc mounted?  Installation cannot proceed without /proc.\"\r\n    fi\r\n}\r\n\r\nget_bitness() {\r\n    need_cmd head\r\n    # Architecture detection without dependencies beyond coreutils.\r\n    # ELF files start out \"\\x7fELF\", and the following byte is\r\n    #   0x01 for 32-bit and\r\n    #   0x02 for 64-bit.\r\n    # The printf builtin on some shells like dash only supports octal\r\n    # escape sequences, so we use those.\r\n    local _current_exe_head\r\n    _current_exe_head=$(head -c 5 /proc/self/exe )\r\n    if [ \"$_current_exe_head\" = \"$(printf '\\177ELF\\001')\" ]; then\r\n        echo 32\r\n    elif [ \"$_current_exe_head\" = \"$(printf '\\177ELF\\002')\" ]; then\r\n        echo 64\r\n    else\r\n        err \"unknown platform bitness\"\r\n    fi\r\n}\r\n\r\nis_host_amd64_elf() {\r\n    need_cmd head\r\n    need_cmd tail\r\n    # ELF e_machine detection without dependencies beyond coreutils.\r\n    # Two-byte field at offset 0x12 indicates the CPU,\r\n    # but we're interested in it being 0x3E to indicate amd64, or not that.\r\n    local _current_exe_machine\r\n    _current_exe_machine=$(head -c 19 /proc/self/exe | tail -c 1)\r\n    [ \"$_current_exe_machine\" = \"$(printf '\\076')\" ]\r\n}\r\n\r\nget_endianness() {\r\n    local cputype=$1\r\n    local suffix_eb=$2\r\n    local suffix_el=$3\r\n\r\n    # detect endianness without od/hexdump, like get_bitness() does.\r\n    need_cmd head\r\n    need_cmd tail\r\n\r\n    local _current_exe_endianness\r\n    _current_exe_endianness=\"$(head -c 6 /proc/self/exe | tail -c 1)\"\r\n    if [ \"$_current_exe_endianness\" = \"$(printf '\\001')\" ]; then\r\n        echo \"${cputype}${suffix_el}\"\r\n    elif [ \"$_current_exe_endianness\" = \"$(printf '\\002')\" ]; then\r\n        echo \"${cputype}${suffix_eb}\"\r\n    else\r\n        err \"unknown platform endianness\"\r\n    fi\r\n}\r\n\r\nget_architecture() {\r\n    local _ostype _cputype _bitness _arch _clibtype\r\n    _ostype=\"$(uname -s)\"\r\n    _cputype=\"$(uname -m)\"\r\n    _clibtype=\"gnu\"\r\n\r\n    if [ \"$_ostype\" = Linux ]; then\r\n        if [ \"$(uname -o)\" = Android ]; then\r\n            _ostype=Android\r\n        fi\r\n        if ldd --version 2>&1 | grep -q 'musl'; then\r\n            _clibtype=\"musl\"\r\n        fi\r\n    fi\r\n\r\n    if [ \"$_ostype\" = Darwin ] && [ \"$_cputype\" = i386 ]; then\r\n        # Darwin `uname -m` lies\r\n        if sysctl hw.optional.x86_64 | grep -q ': 1'; then\r\n            _cputype=x86_64\r\n        fi\r\n    fi\r\n\r\n    if [ \"$_ostype\" = SunOS ]; then\r\n        # Both Solaris and illumos presently announce as \"SunOS\" in \"uname -s\"\r\n        # so use \"uname -o\" to disambiguate.  We use the full path to the\r\n        # system uname in case the user has coreutils uname first in PATH,\r\n        # which has historically sometimes printed the wrong value here.\r\n        if [ \"$(/usr/bin/uname -o)\" = illumos ]; then\r\n            _ostype=illumos\r\n        fi\r\n\r\n        # illumos systems have multi-arch userlands, and \"uname -m\" reports the\r\n        # machine hardware name; e.g., \"i86pc\" on both 32- and 64-bit x86\r\n        # systems.  Check for the native (widest) instruction set on the\r\n        # running kernel:\r\n        if [ \"$_cputype\" = i86pc ]; then\r\n            _cputype=\"$(isainfo -n)\"\r\n        fi\r\n    fi\r\n\r\n    case \"$_ostype\" in\r\n\r\n        Android)\r\n            _ostype=linux-android\r\n            ;;\r\n\r\n        Linux)\r\n            check_proc\r\n            _ostype=unknown-linux-$_clibtype\r\n            _bitness=$(get_bitness)\r\n            ;;\r\n\r\n        FreeBSD)\r\n            _ostype=unknown-freebsd\r\n            ;;\r\n\r\n        NetBSD)\r\n            _ostype=unknown-netbsd\r\n            ;;\r\n\r\n        DragonFly)\r\n            _ostype=unknown-dragonfly\r\n            ;;\r\n\r\n        Darwin)\r\n            _ostype=apple-darwin\r\n            ;;\r\n\r\n        illumos)\r\n            _ostype=unknown-illumos\r\n            ;;\r\n\r\n        MINGW* | MSYS* | CYGWIN* | Windows_NT)\r\n            _ostype=pc-windows-gnu\r\n            ;;\r\n\r\n        *)\r\n            err \"unrecognized OS type: $_ostype\"\r\n            ;;\r\n\r\n    esac\r\n\r\n    case \"$_cputype\" in\r\n\r\n        i386 | i486 | i686 | i786 | x86)\r\n            _cputype=i686\r\n            ;;\r\n\r\n        xscale | arm)\r\n            _cputype=arm\r\n            if [ \"$_ostype\" = \"linux-android\" ]; then\r\n                _ostype=linux-androideabi\r\n            fi\r\n            ;;\r\n\r\n        armv6l)\r\n            _cputype=arm\r\n            if [ \"$_ostype\" = \"linux-android\" ]; then\r\n                _ostype=linux-androideabi\r\n            else\r\n                _ostype=\"${_ostype}eabihf\"\r\n            fi\r\n            ;;\r\n\r\n        armv7l | armv8l)\r\n            _cputype=armv7\r\n            if [ \"$_ostype\" = \"linux-android\" ]; then\r\n                _ostype=linux-androideabi\r\n            else\r\n                _ostype=\"${_ostype}eabihf\"\r\n            fi\r\n            ;;\r\n\r\n        aarch64 | arm64)\r\n            _cputype=aarch64\r\n            ;;\r\n\r\n        x86_64 | x86-64 | x64 | amd64)\r\n            _cputype=x86_64\r\n            ;;\r\n\r\n        mips)\r\n            _cputype=$(get_endianness mips '' el)\r\n            ;;\r\n\r\n        mips64)\r\n            if [ \"$_bitness\" -eq 64 ]; then\r\n                # only n64 ABI is supported for now\r\n                _ostype=\"${_ostype}abi64\"\r\n                _cputype=$(get_endianness mips64 '' el)\r\n            fi\r\n            ;;\r\n\r\n        ppc)\r\n            _cputype=powerpc\r\n            ;;\r\n\r\n        ppc64)\r\n            _cputype=powerpc64\r\n            ;;\r\n\r\n        ppc64le)\r\n            _cputype=powerpc64le\r\n            ;;\r\n\r\n        s390x)\r\n            _cputype=s390x\r\n            ;;\r\n        riscv64)\r\n            _cputype=riscv64gc\r\n            ;;\r\n        *)\r\n            err \"unknown CPU type: $_cputype\"\r\n\r\n    esac\r\n\r\n    # Detect 64-bit linux with 32-bit userland\r\n    if [ \"${_ostype}\" = unknown-linux-gnu ] && [ \"${_bitness}\" -eq 32 ]; then\r\n        case $_cputype in\r\n            x86_64)\r\n                if [ -n \"${RUSTUP_CPUTYPE:-}\" ]; then\r\n                    _cputype=\"$RUSTUP_CPUTYPE\"\r\n                else {\r\n                    # 32-bit executable for amd64 = x32\r\n                    if is_host_amd64_elf; then {\r\n                         echo \"This host is running an x32 userland; as it stands, x32 support is poor,\" 1>&2\r\n                         echo \"and there isn't a native toolchain -- you will have to install\" 1>&2\r\n                         echo \"multiarch compatibility with i686 and/or amd64, then select one\" 1>&2\r\n                         echo \"by re-running this script with the RUSTUP_CPUTYPE environment variable\" 1>&2\r\n                         echo \"set to i686 or x86_64, respectively.\" 1>&2\r\n                         echo 1>&2\r\n                         echo \"You will be able to add an x32 target after installation by running\" 1>&2\r\n                         echo \"  rustup target add x86_64-unknown-linux-gnux32\" 1>&2\r\n                         exit 1\r\n                    }; else\r\n                        _cputype=i686\r\n                    fi\r\n                }; fi\r\n                ;;\r\n            mips64)\r\n                _cputype=$(get_endianness mips '' el)\r\n                ;;\r\n            powerpc64)\r\n                _cputype=powerpc\r\n                ;;\r\n            aarch64)\r\n                _cputype=armv7\r\n                if [ \"$_ostype\" = \"linux-android\" ]; then\r\n                    _ostype=linux-androideabi\r\n                else\r\n                    _ostype=\"${_ostype}eabihf\"\r\n                fi\r\n                ;;\r\n            riscv64gc)\r\n                err \"riscv64 with 32-bit userland unsupported\"\r\n                ;;\r\n        esac\r\n    fi\r\n\r\n    # Detect armv7 but without the CPU features Rust needs in that build,\r\n    # and fall back to arm.\r\n    # See https://github.com/rust-lang/rustup.rs/issues/587.\r\n    if [ \"$_ostype\" = \"unknown-linux-gnueabihf\" ] && [ \"$_cputype\" = armv7 ]; then\r\n        if ensure grep '^Features' /proc/cpuinfo | grep -q -v neon; then\r\n            # At least one processor does not have NEON.\r\n            _cputype=arm\r\n        fi\r\n    fi\r\n\r\n    _arch=\"${_cputype}-${_ostype}\"\r\n\r\n    RETVAL=\"$_arch\"\r\n}\r\n\r\nsay() {\r\n    printf 'rustup: %s\\n' \"$1\"\r\n}\r\n\r\nerr() {\r\n    say \"$1\" >&2\r\n    exit 1\r\n}\r\n\r\nneed_cmd() {\r\n    if ! check_cmd \"$1\"; then\r\n        err \"need '$1' (command not found)\"\r\n    fi\r\n}\r\n\r\ncheck_cmd() {\r\n    command -v \"$1\" > /dev/null 2>&1\r\n}\r\n\r\nassert_nz() {\r\n    if [ -z \"$1\" ]; then err \"assert_nz $2\"; fi\r\n}\r\n\r\n# Run a command that should never fail. If the command fails execution\r\n# will immediately terminate with an error showing the failing\r\n# command.\r\nensure() {\r\n    if ! \"$@\"; then err \"command failed: $*\"; fi\r\n}\r\n\r\n# This is just for indicating that commands' results are being\r\n# intentionally ignored. Usually, because it's being executed\r\n# as part of error handling.\r\nignore() {\r\n    \"$@\"\r\n}\r\n\r\n# This wraps curl or wget. Try curl first, if not installed,\r\n# use wget instead.\r\ndownloader() {\r\n    local _dld\r\n    local _ciphersuites\r\n    local _err\r\n    local _status\r\n    local _retry\r\n    if check_cmd curl; then\r\n        _dld=curl\r\n    elif check_cmd wget; then\r\n        _dld=wget\r\n    else\r\n        _dld='curl or wget' # to be used in error message of need_cmd\r\n    fi\r\n\r\n    if [ \"$1\" = --check ]; then\r\n        need_cmd \"$_dld\"\r\n    elif [ \"$_dld\" = curl ]; then\r\n        check_curl_for_retry_support\r\n        _retry=\"$RETVAL\"\r\n        get_ciphersuites_for_curl\r\n        _ciphersuites=\"$RETVAL\"\r\n        if [ -n \"$_ciphersuites\" ]; then\r\n            _err=$(curl $_retry --proto '=https' --tlsv1.2 --ciphers \"$_ciphersuites\" --silent --show-error --fail --location \"$1\" --output \"$2\" 2>&1)\r\n            _status=$?\r\n        else\r\n            echo \"Warning: Not enforcing strong cipher suites for TLS, this is potentially less secure\"\r\n            if ! check_help_for \"$3\" curl --proto --tlsv1.2; then\r\n                echo \"Warning: Not enforcing TLS v1.2, this is potentially less secure\"\r\n                _err=$(curl $_retry --silent --show-error --fail --location \"$1\" --output \"$2\" 2>&1)\r\n                _status=$?\r\n            else\r\n                _err=$(curl $_retry --proto '=https' --tlsv1.2 --silent --show-error --fail --location \"$1\" --output \"$2\" 2>&1)\r\n                _status=$?\r\n            fi\r\n        fi\r\n        if [ -n \"$_err\" ]; then\r\n            echo \"$_err\" >&2\r\n            if echo \"$_err\" | grep -q 404$; then\r\n                err \"installer for platform '$3' not found, this may be unsupported\"\r\n            fi\r\n        fi\r\n        return $_status\r\n    elif [ \"$_dld\" = wget ]; then\r\n        if [ \"$(wget -V 2>&1|head -2|tail -1|cut -f1 -d\" \")\" = \"BusyBox\" ]; then\r\n            echo \"Warning: using the BusyBox version of wget.  Not enforcing strong cipher suites for TLS or TLS v1.2, this is potentially less secure\"\r\n            _err=$(wget \"$1\" -O \"$2\" 2>&1)\r\n            _status=$?\r\n        else\r\n            get_ciphersuites_for_wget\r\n            _ciphersuites=\"$RETVAL\"\r\n            if [ -n \"$_ciphersuites\" ]; then\r\n                _err=$(wget --https-only --secure-protocol=TLSv1_2 --ciphers \"$_ciphersuites\" \"$1\" -O \"$2\" 2>&1)\r\n                _status=$?\r\n            else\r\n                echo \"Warning: Not enforcing strong cipher suites for TLS, this is potentially less secure\"\r\n                if ! check_help_for \"$3\" wget --https-only --secure-protocol; then\r\n                    echo \"Warning: Not enforcing TLS v1.2, this is potentially less secure\"\r\n                    _err=$(wget \"$1\" -O \"$2\" 2>&1)\r\n                    _status=$?\r\n                else\r\n                    _err=$(wget --https-only --secure-protocol=TLSv1_2 \"$1\" -O \"$2\" 2>&1)\r\n                    _status=$?\r\n                fi\r\n            fi\r\n        fi\r\n        if [ -n \"$_err\" ]; then\r\n            echo \"$_err\" >&2\r\n            if echo \"$_err\" | grep -q ' 404 Not Found$'; then\r\n                err \"installer for platform '$3' not found, this may be unsupported\"\r\n            fi\r\n        fi\r\n        return $_status\r\n    else\r\n        err \"Unknown downloader\"   # should not reach here\r\n    fi\r\n}\r\n\r\ncheck_help_for() {\r\n    local _arch\r\n    local _cmd\r\n    local _arg\r\n    _arch=\"$1\"\r\n    shift\r\n    _cmd=\"$1\"\r\n    shift\r\n\r\n    local _category\r\n    if \"$_cmd\" --help | grep -q 'For all options use the manual or \"--help all\".'; then\r\n      _category=\"all\"\r\n    else\r\n      _category=\"\"\r\n    fi\r\n\r\n    case \"$_arch\" in\r\n\r\n        *darwin*)\r\n        if check_cmd sw_vers; then\r\n            case $(sw_vers -productVersion) in\r\n                10.*)\r\n                    # If we're running on macOS, older than 10.13, then we always\r\n                    # fail to find these options to force fallback\r\n                    if [ \"$(sw_vers -productVersion | cut -d. -f2)\" -lt 13 ]; then\r\n                        # Older than 10.13\r\n                        echo \"Warning: Detected macOS platform older than 10.13\"\r\n                        return 1\r\n                    fi\r\n                    ;;\r\n                11.*)\r\n                    # We assume Big Sur will be OK for now\r\n                    ;;\r\n                *)\r\n                    # Unknown product version, warn and continue\r\n                    echo \"Warning: Detected unknown macOS major version: $(sw_vers -productVersion)\"\r\n                    echo \"Warning TLS capabilities detection may fail\"\r\n                    ;;\r\n            esac\r\n        fi\r\n        ;;\r\n\r\n    esac\r\n\r\n    for _arg in \"$@\"; do\r\n        if ! \"$_cmd\" --help $_category | grep -q -- \"$_arg\"; then\r\n            return 1\r\n        fi\r\n    done\r\n\r\n    true # not strictly needed\r\n}\r\n\r\n# Check if curl supports the --retry flag, then pass it to the curl invocation.\r\ncheck_curl_for_retry_support() {\r\n  local _retry_supported=\"\"\r\n  # \"unspecified\" is for arch, allows for possibility old OS using macports, homebrew, etc.\r\n  if check_help_for \"notspecified\" \"curl\" \"--retry\"; then\r\n    _retry_supported=\"--retry 3\"\r\n  fi\r\n\r\n  RETVAL=\"$_retry_supported\"\r\n\r\n}\r\n\r\n# Return cipher suite string specified by user, otherwise return strong TLS 1.2-1.3 cipher suites\r\n# if support by local tools is detected. Detection currently supports these curl backends:\r\n# GnuTLS and OpenSSL (possibly also LibreSSL and BoringSSL). Return value can be empty.\r\nget_ciphersuites_for_curl() {\r\n    if [ -n \"${RUSTUP_TLS_CIPHERSUITES-}\" ]; then\r\n        # user specified custom cipher suites, assume they know what they're doing\r\n        RETVAL=\"$RUSTUP_TLS_CIPHERSUITES\"\r\n        return\r\n    fi\r\n\r\n    local _openssl_syntax=\"no\"\r\n    local _gnutls_syntax=\"no\"\r\n    local _backend_supported=\"yes\"\r\n    if curl -V | grep -q ' OpenSSL/'; then\r\n        _openssl_syntax=\"yes\"\r\n    elif curl -V | grep -iq ' LibreSSL/'; then\r\n        _openssl_syntax=\"yes\"\r\n    elif curl -V | grep -iq ' BoringSSL/'; then\r\n        _openssl_syntax=\"yes\"\r\n    elif curl -V | grep -iq ' GnuTLS/'; then\r\n        _gnutls_syntax=\"yes\"\r\n    else\r\n        _backend_supported=\"no\"\r\n    fi\r\n\r\n    local _args_supported=\"no\"\r\n    if [ \"$_backend_supported\" = \"yes\" ]; then\r\n        # \"unspecified\" is for arch, allows for possibility old OS using macports, homebrew, etc.\r\n        if check_help_for \"notspecified\" \"curl\" \"--tlsv1.2\" \"--ciphers\" \"--proto\"; then\r\n            _args_supported=\"yes\"\r\n        fi\r\n    fi\r\n\r\n    local _cs=\"\"\r\n    if [ \"$_args_supported\" = \"yes\" ]; then\r\n        if [ \"$_openssl_syntax\" = \"yes\" ]; then\r\n            _cs=$(get_strong_ciphersuites_for \"openssl\")\r\n        elif [ \"$_gnutls_syntax\" = \"yes\" ]; then\r\n            _cs=$(get_strong_ciphersuites_for \"gnutls\")\r\n        fi\r\n    fi\r\n\r\n    RETVAL=\"$_cs\"\r\n}\r\n\r\n# Return cipher suite string specified by user, otherwise return strong TLS 1.2-1.3 cipher suites\r\n# if support by local tools is detected. Detection currently supports these wget backends:\r\n# GnuTLS and OpenSSL (possibly also LibreSSL and BoringSSL). Return value can be empty.\r\nget_ciphersuites_for_wget() {\r\n    if [ -n \"${RUSTUP_TLS_CIPHERSUITES-}\" ]; then\r\n        # user specified custom cipher suites, assume they know what they're doing\r\n        RETVAL=\"$RUSTUP_TLS_CIPHERSUITES\"\r\n        return\r\n    fi\r\n\r\n    local _cs=\"\"\r\n    if wget -V | grep -q '\\-DHAVE_LIBSSL'; then\r\n        # \"unspecified\" is for arch, allows for possibility old OS using macports, homebrew, etc.\r\n        if check_help_for \"notspecified\" \"wget\" \"TLSv1_2\" \"--ciphers\" \"--https-only\" \"--secure-protocol\"; then\r\n            _cs=$(get_strong_ciphersuites_for \"openssl\")\r\n        fi\r\n    elif wget -V | grep -q '\\-DHAVE_LIBGNUTLS'; then\r\n        # \"unspecified\" is for arch, allows for possibility old OS using macports, homebrew, etc.\r\n        if check_help_for \"notspecified\" \"wget\" \"TLSv1_2\" \"--ciphers\" \"--https-only\" \"--secure-protocol\"; then\r\n            _cs=$(get_strong_ciphersuites_for \"gnutls\")\r\n        fi\r\n    fi\r\n\r\n    RETVAL=\"$_cs\"\r\n}\r\n\r\n# Return strong TLS 1.2-1.3 cipher suites in OpenSSL or GnuTLS syntax. TLS 1.2\r\n# excludes non-ECDHE and non-AEAD cipher suites. DHE is excluded due to bad\r\n# DH params often found on servers (see RFC 7919). Sequence matches or is\r\n# similar to Firefox 68 ESR with weak cipher suites disabled via about:config.\r\n# $1 must be openssl or gnutls.\r\nget_strong_ciphersuites_for() {\r\n    if [ \"$1\" = \"openssl\" ]; then\r\n        # OpenSSL is forgiving of unknown values, no problems with TLS 1.3 values on versions that don't support it yet.\r\n        echo \"TLS_AES_128_GCM_SHA256:TLS_CHACHA20_POLY1305_SHA256:TLS_AES_256_GCM_SHA384:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384\"\r\n    elif [ \"$1\" = \"gnutls\" ]; then\r\n        # GnuTLS isn't forgiving of unknown values, so this may require a GnuTLS version that supports TLS 1.3 even if wget doesn't.\r\n        # Begin with SECURE128 (and higher) then remove/add to build cipher suites. Produces same 9 cipher suites as OpenSSL but in slightly different order.\r\n        echo \"SECURE128:-VERS-SSL3.0:-VERS-TLS1.0:-VERS-TLS1.1:-VERS-DTLS-ALL:-CIPHER-ALL:-MAC-ALL:-KX-ALL:+AEAD:+ECDHE-ECDSA:+ECDHE-RSA:+AES-128-GCM:+CHACHA20-POLY1305:+AES-256-GCM\"\r\n    fi\r\n}\r\n\r\nmain \"$@\" || exit 1\r\ncurl: (6) Could not resolve host: |\r\ncurl: (6) Could not resolve host: sh", "stdout_lines": ["#!/bin/sh", "# shellcheck shell=dash", "", "# This is just a little script that can be downloaded from the internet to", "# install rustup. It just does platform detection, downloads the installer", "# and runs it.", "", "# It runs on Unix shells like {a,ba,da,k,z}sh. It uses the common `local`", "# extension. Note: Most shells limit `local` to 1 var per line, contra bash.", "", "if [ \"$KSH_VERSION\" = 'Version JM 93t+ 2010-03-05' ]; then", "    # The version of ksh93 that ships with many illumos systems does not", "    # support the \"local\" extension.  Print a message rather than fail in", "    # subtle ways later on:", "    echo 'rustup does not work with this ksh93 version; please try bash!' >&2", "    exit 1", "fi", "", "", "set -u", "", "# If RUSTUP_UPDATE_ROOT is unset or empty, default it.", "RUSTUP_UPDATE_ROOT=\"${RUSTUP_UPDATE_ROOT:-https://static.rust-lang.org/rustup}\"", "", "#XXX: If you change anything here, please make the same changes in setup_mode.rs", "usage() {", "    cat 1>&2 <<EOF", "rustup-init 1.25.1 (48d233f65 2022-07-12)", "The installer for rustup", "", "USAGE:", "    rustup-init [FLAGS] [OPTIONS]", "", "FLAGS:", "    -v, --verbose           Enable verbose output", "    -q, --quiet             Disable progress output", "    -y                      Disable confirmation prompt.", "        --no-modify-path    Don't configure the PATH environment variable", "    -h, --help              Prints help information", "    -V, --version           Prints version information", "", "OPTIONS:", "        --default-host <default-host>              Choose a default host triple", "        --default-toolchain <default-toolchain>    Choose a default toolchain to install", "        --default-toolchain none                   Do not install any toolchains", "        --profile [minimal|default|complete]       Choose a profile", "    -c, --component <components>...                Component name to also install", "    -t, --target <targets>...                      Target name to also install", "EOF", "}", "", "main() {", "    downloader --check", "    need_cmd uname", "    need_cmd mktemp", "    need_cmd chmod", "    need_cmd mkdir", "    need_cmd rm", "    need_cmd rmdir", "", "    get_architecture || return 1", "    local _arch=\"$RETVAL\"", "    assert_nz \"$_arch\" \"arch\"", "", "    local _ext=\"\"", "    case \"$_arch\" in", "        *windows*)", "            _ext=\".exe\"", "            ;;", "    esac", "", "    local _url=\"${RUSTUP_UPDATE_ROOT}/dist/${_arch}/rustup-init${_ext}\"", "", "    local _dir", "    _dir=\"$(ensure mktemp -d)\"", "    local _file=\"${_dir}/rustup-init${_ext}\"", "", "    local _ansi_escapes_are_valid=false", "    if [ -t 2 ]; then", "        if [ \"${TERM+set}\" = 'set' ]; then", "            case \"$TERM\" in", "                xterm*|rxvt*|urxvt*|linux*|vt*)", "                    _ansi_escapes_are_valid=true", "                ;;", "            esac", "        fi", "    fi", "", "    # check if we have to use /dev/tty to prompt the user", "    local need_tty=yes", "    for arg in \"$@\"; do", "        case \"$arg\" in", "            --help)", "                usage", "                exit 0", "                ;;", "            *)", "                OPTIND=1", "                if [ \"${arg%%--*}\" = \"\" ]; then", "                    # Long option (other than --help);", "                    # don't attempt to interpret it.", "                    continue", "                fi", "                while getopts :hy sub_arg \"$arg\"; do", "                    case \"$sub_arg\" in", "                        h)", "                            usage", "                            exit 0", "                            ;;", "                        y)", "                            # user wants to skip the prompt --", "                            # we don't need /dev/tty", "                            need_tty=no", "                            ;;", "                        *)", "                            ;;", "                        esac", "                done", "                ;;", "        esac", "    done", "", "    if $_ansi_escapes_are_valid; then", "        printf \"\\33[1minfo:\\33[0m downloading installer\\n\" 1>&2", "    else", "        printf '%s\\n' 'info: downloading installer' 1>&2", "    fi", "", "    ensure mkdir -p \"$_dir\"", "    ensure downloader \"$_url\" \"$_file\" \"$_arch\"", "    ensure chmod u+x \"$_file\"", "    if [ ! -x \"$_file\" ]; then", "        printf '%s\\n' \"Cannot execute $_file (likely because of mounting /tmp as noexec).\" 1>&2", "        printf '%s\\n' \"Please copy the file to a location where you can execute binaries and run ./rustup-init${_ext}.\" 1>&2", "        exit 1", "    fi", "", "    if [ \"$need_tty\" = \"yes\" ] && [ ! -t 0 ]; then", "        # The installer is going to want to ask for confirmation by", "        # reading stdin.  This script was piped into `sh` though and", "        # doesn't have stdin to pass to its children. Instead we're going", "        # to explicitly connect /dev/tty to the installer's stdin.", "        if [ ! -t 1 ]; then", "            err \"Unable to run interactively. Run with -y to accept defaults, --help for additional options\"", "        fi", "", "        ignore \"$_file\" \"$@\" < /dev/tty", "    else", "        ignore \"$_file\" \"$@\"", "    fi", "", "    local _retval=$?", "", "    ignore rm \"$_file\"", "    ignore rmdir \"$_dir\"", "", "    return \"$_retval\"", "}", "", "check_proc() {", "    # Check for /proc by looking for the /proc/self/exe link", "    # This is only run on Linux", "    if ! test -L /proc/self/exe ; then", "        err \"fatal: Unable to find /proc/self/exe.  Is /proc mounted?  Installation cannot proceed without /proc.\"", "    fi", "}", "", "get_bitness() {", "    need_cmd head", "    # Architecture detection without dependencies beyond coreutils.", "    # ELF files start out \"\\x7fELF\", and the following byte is", "    #   0x01 for 32-bit and", "    #   0x02 for 64-bit.", "    # The printf builtin on some shells like dash only supports octal", "    # escape sequences, so we use those.", "    local _current_exe_head", "    _current_exe_head=$(head -c 5 /proc/self/exe )", "    if [ \"$_current_exe_head\" = \"$(printf '\\177ELF\\001')\" ]; then", "        echo 32", "    elif [ \"$_current_exe_head\" = \"$(printf '\\177ELF\\002')\" ]; then", "        echo 64", "    else", "        err \"unknown platform bitness\"", "    fi", "}", "", "is_host_amd64_elf() {", "    need_cmd head", "    need_cmd tail", "    # ELF e_machine detection without dependencies beyond coreutils.", "    # Two-byte field at offset 0x12 indicates the CPU,", "    # but we're interested in it being 0x3E to indicate amd64, or not that.", "    local _current_exe_machine", "    _current_exe_machine=$(head -c 19 /proc/self/exe | tail -c 1)", "    [ \"$_current_exe_machine\" = \"$(printf '\\076')\" ]", "}", "", "get_endianness() {", "    local cputype=$1", "    local suffix_eb=$2", "    local suffix_el=$3", "", "    # detect endianness without od/hexdump, like get_bitness() does.", "    need_cmd head", "    need_cmd tail", "", "    local _current_exe_endianness", "    _current_exe_endianness=\"$(head -c 6 /proc/self/exe | tail -c 1)\"", "    if [ \"$_current_exe_endianness\" = \"$(printf '\\001')\" ]; then", "        echo \"${cputype}${suffix_el}\"", "    elif [ \"$_current_exe_endianness\" = \"$(printf '\\002')\" ]; then", "        echo \"${cputype}${suffix_eb}\"", "    else", "        err \"unknown platform endianness\"", "    fi", "}", "", "get_architecture() {", "    local _ostype _cputype _bitness _arch _clibtype", "    _ostype=\"$(uname -s)\"", "    _cputype=\"$(uname -m)\"", "    _clibtype=\"gnu\"", "", "    if [ \"$_ostype\" = Linux ]; then", "        if [ \"$(uname -o)\" = Android ]; then", "            _ostype=Android", "        fi", "        if ldd --version 2>&1 | grep -q 'musl'; then", "            _clibtype=\"musl\"", "        fi", "    fi", "", "    if [ \"$_ostype\" = Darwin ] && [ \"$_cputype\" = i386 ]; then", "        # Darwin `uname -m` lies", "        if sysctl hw.optional.x86_64 | grep -q ': 1'; then", "            _cputype=x86_64", "        fi", "    fi", "", "    if [ \"$_ostype\" = SunOS ]; then", "        # Both Solaris and illumos presently announce as \"SunOS\" in \"uname -s\"", "        # so use \"uname -o\" to disambiguate.  We use the full path to the", "        # system uname in case the user has coreutils uname first in PATH,", "        # which has historically sometimes printed the wrong value here.", "        if [ \"$(/usr/bin/uname -o)\" = illumos ]; then", "            _ostype=illumos", "        fi", "", "        # illumos systems have multi-arch userlands, and \"uname -m\" reports the", "        # machine hardware name; e.g., \"i86pc\" on both 32- and 64-bit x86", "        # systems.  Check for the native (widest) instruction set on the", "        # running kernel:", "        if [ \"$_cputype\" = i86pc ]; then", "            _cputype=\"$(isainfo -n)\"", "        fi", "    fi", "", "    case \"$_ostype\" in", "", "        Android)", "            _ostype=linux-android", "            ;;", "", "        Linux)", "            check_proc", "            _ostype=unknown-linux-$_clibtype", "            _bitness=$(get_bitness)", "            ;;", "", "        FreeBSD)", "            _ostype=unknown-freebsd", "            ;;", "", "        NetBSD)", "            _ostype=unknown-netbsd", "            ;;", "", "        DragonFly)", "            _ostype=unknown-dragonfly", "            ;;", "", "        Darwin)", "            _ostype=apple-darwin", "            ;;", "", "        illumos)", "            _ostype=unknown-illumos", "            ;;", "", "        MINGW* | MSYS* | CYGWIN* | Windows_NT)", "            _ostype=pc-windows-gnu", "            ;;", "", "        *)", "            err \"unrecognized OS type: $_ostype\"", "            ;;", "", "    esac", "", "    case \"$_cputype\" in", "", "        i386 | i486 | i686 | i786 | x86)", "            _cputype=i686", "            ;;", "", "        xscale | arm)", "            _cputype=arm", "            if [ \"$_ostype\" = \"linux-android\" ]; then", "                _ostype=linux-androideabi", "            fi", "            ;;", "", "        armv6l)", "            _cputype=arm", "            if [ \"$_ostype\" = \"linux-android\" ]; then", "                _ostype=linux-androideabi", "            else", "                _ostype=\"${_ostype}eabihf\"", "            fi", "            ;;", "", "        armv7l | armv8l)", "            _cputype=armv7", "            if [ \"$_ostype\" = \"linux-android\" ]; then", "                _ostype=linux-androideabi", "            else", "                _ostype=\"${_ostype}eabihf\"", "            fi", "            ;;", "", "        aarch64 | arm64)", "            _cputype=aarch64", "            ;;", "", "        x86_64 | x86-64 | x64 | amd64)", "            _cputype=x86_64", "            ;;", "", "        mips)", "            _cputype=$(get_endianness mips '' el)", "            ;;", "", "        mips64)", "            if [ \"$_bitness\" -eq 64 ]; then", "                # only n64 ABI is supported for now", "                _ostype=\"${_ostype}abi64\"", "                _cputype=$(get_endianness mips64 '' el)", "            fi", "            ;;", "", "        ppc)", "            _cputype=powerpc", "            ;;", "", "        ppc64)", "            _cputype=powerpc64", "            ;;", "", "        ppc64le)", "            _cputype=powerpc64le", "            ;;", "", "        s390x)", "            _cputype=s390x", "            ;;", "        riscv64)", "            _cputype=riscv64gc", "            ;;", "        *)", "            err \"unknown CPU type: $_cputype\"", "", "    esac", "", "    # Detect 64-bit linux with 32-bit userland", "    if [ \"${_ostype}\" = unknown-linux-gnu ] && [ \"${_bitness}\" -eq 32 ]; then", "        case $_cputype in", "            x86_64)", "                if [ -n \"${RUSTUP_CPUTYPE:-}\" ]; then", "                    _cputype=\"$RUSTUP_CPUTYPE\"", "                else {", "                    # 32-bit executable for amd64 = x32", "                    if is_host_amd64_elf; then {", "                         echo \"This host is running an x32 userland; as it stands, x32 support is poor,\" 1>&2", "                         echo \"and there isn't a native toolchain -- you will have to install\" 1>&2", "                         echo \"multiarch compatibility with i686 and/or amd64, then select one\" 1>&2", "                         echo \"by re-running this script with the RUSTUP_CPUTYPE environment variable\" 1>&2", "                         echo \"set to i686 or x86_64, respectively.\" 1>&2", "                         echo 1>&2", "                         echo \"You will be able to add an x32 target after installation by running\" 1>&2", "                         echo \"  rustup target add x86_64-unknown-linux-gnux32\" 1>&2", "                         exit 1", "                    }; else", "                        _cputype=i686", "                    fi", "                }; fi", "                ;;", "            mips64)", "                _cputype=$(get_endianness mips '' el)", "                ;;", "            powerpc64)", "                _cputype=powerpc", "                ;;", "            aarch64)", "                _cputype=armv7", "                if [ \"$_ostype\" = \"linux-android\" ]; then", "                    _ostype=linux-androideabi", "                else", "                    _ostype=\"${_ostype}eabihf\"", "                fi", "                ;;", "            riscv64gc)", "                err \"riscv64 with 32-bit userland unsupported\"", "                ;;", "        esac", "    fi", "", "    # Detect armv7 but without the CPU features Rust needs in that build,", "    # and fall back to arm.", "    # See https://github.com/rust-lang/rustup.rs/issues/587.", "    if [ \"$_ostype\" = \"unknown-linux-gnueabihf\" ] && [ \"$_cputype\" = armv7 ]; then", "        if ensure grep '^Features' /proc/cpuinfo | grep -q -v neon; then", "            # At least one processor does not have NEON.", "            _cputype=arm", "        fi", "    fi", "", "    _arch=\"${_cputype}-${_ostype}\"", "", "    RETVAL=\"$_arch\"", "}", "", "say() {", "    printf 'rustup: %s\\n' \"$1\"", "}", "", "err() {", "    say \"$1\" >&2", "    exit 1", "}", "", "need_cmd() {", "    if ! check_cmd \"$1\"; then", "        err \"need '$1' (command not found)\"", "    fi", "}", "", "check_cmd() {", "    command -v \"$1\" > /dev/null 2>&1", "}", "", "assert_nz() {", "    if [ -z \"$1\" ]; then err \"assert_nz $2\"; fi", "}", "", "# Run a command that should never fail. If the command fails execution", "# will immediately terminate with an error showing the failing", "# command.", "ensure() {", "    if ! \"$@\"; then err \"command failed: $*\"; fi", "}", "", "# This is just for indicating that commands' results are being", "# intentionally ignored. Usually, because it's being executed", "# as part of error handling.", "ignore() {", "    \"$@\"", "}", "", "# This wraps curl or wget. Try curl first, if not installed,", "# use wget instead.", "downloader() {", "    local _dld", "    local _ciphersuites", "    local _err", "    local _status", "    local _retry", "    if check_cmd curl; then", "        _dld=curl", "    elif check_cmd wget; then", "        _dld=wget", "    else", "        _dld='curl or wget' # to be used in error message of need_cmd", "    fi", "", "    if [ \"$1\" = --check ]; then", "        need_cmd \"$_dld\"", "    elif [ \"$_dld\" = curl ]; then", "        check_curl_for_retry_support", "        _retry=\"$RETVAL\"", "        get_ciphersuites_for_curl", "        _ciphersuites=\"$RETVAL\"", "        if [ -n \"$_ciphersuites\" ]; then", "            _err=$(curl $_retry --proto '=https' --tlsv1.2 --ciphers \"$_ciphersuites\" --silent --show-error --fail --location \"$1\" --output \"$2\" 2>&1)", "            _status=$?", "        else", "            echo \"Warning: Not enforcing strong cipher suites for TLS, this is potentially less secure\"", "            if ! check_help_for \"$3\" curl --proto --tlsv1.2; then", "                echo \"Warning: Not enforcing TLS v1.2, this is potentially less secure\"", "                _err=$(curl $_retry --silent --show-error --fail --location \"$1\" --output \"$2\" 2>&1)", "                _status=$?", "            else", "                _err=$(curl $_retry --proto '=https' --tlsv1.2 --silent --show-error --fail --location \"$1\" --output \"$2\" 2>&1)", "                _status=$?", "            fi", "        fi", "        if [ -n \"$_err\" ]; then", "            echo \"$_err\" >&2", "            if echo \"$_err\" | grep -q 404$; then", "                err \"installer for platform '$3' not found, this may be unsupported\"", "            fi", "        fi", "        return $_status", "    elif [ \"$_dld\" = wget ]; then", "        if [ \"$(wget -V 2>&1|head -2|tail -1|cut -f1 -d\" \")\" = \"BusyBox\" ]; then", "            echo \"Warning: using the BusyBox version of wget.  Not enforcing strong cipher suites for TLS or TLS v1.2, this is potentially less secure\"", "            _err=$(wget \"$1\" -O \"$2\" 2>&1)", "            _status=$?", "        else", "            get_ciphersuites_for_wget", "            _ciphersuites=\"$RETVAL\"", "            if [ -n \"$_ciphersuites\" ]; then", "                _err=$(wget --https-only --secure-protocol=TLSv1_2 --ciphers \"$_ciphersuites\" \"$1\" -O \"$2\" 2>&1)", "                _status=$?", "            else", "                echo \"Warning: Not enforcing strong cipher suites for TLS, this is potentially less secure\"", "                if ! check_help_for \"$3\" wget --https-only --secure-protocol; then", "                    echo \"Warning: Not enforcing TLS v1.2, this is potentially less secure\"", "                    _err=$(wget \"$1\" -O \"$2\" 2>&1)", "                    _status=$?", "                else", "                    _err=$(wget --https-only --secure-protocol=TLSv1_2 \"$1\" -O \"$2\" 2>&1)", "                    _status=$?", "                fi", "            fi", "        fi", "        if [ -n \"$_err\" ]; then", "            echo \"$_err\" >&2", "            if echo \"$_err\" | grep -q ' 404 Not Found$'; then", "                err \"installer for platform '$3' not found, this may be unsupported\"", "            fi", "        fi", "        return $_status", "    else", "        err \"Unknown downloader\"   # should not reach here", "    fi", "}", "", "check_help_for() {", "    local _arch", "    local _cmd", "    local _arg", "    _arch=\"$1\"", "    shift", "    _cmd=\"$1\"", "    shift", "", "    local _category", "    if \"$_cmd\" --help | grep -q 'For all options use the manual or \"--help all\".'; then", "      _category=\"all\"", "    else", "      _category=\"\"", "    fi", "", "    case \"$_arch\" in", "", "        *darwin*)", "        if check_cmd sw_vers; then", "            case $(sw_vers -productVersion) in", "                10.*)", "                    # If we're running on macOS, older than 10.13, then we always", "                    # fail to find these options to force fallback", "                    if [ \"$(sw_vers -productVersion | cut -d. -f2)\" -lt 13 ]; then", "                        # Older than 10.13", "                        echo \"Warning: Detected macOS platform older than 10.13\"", "                        return 1", "                    fi", "                    ;;", "                11.*)", "                    # We assume Big Sur will be OK for now", "                    ;;", "                *)", "                    # Unknown product version, warn and continue", "                    echo \"Warning: Detected unknown macOS major version: $(sw_vers -productVersion)\"", "                    echo \"Warning TLS capabilities detection may fail\"", "                    ;;", "            esac", "        fi", "        ;;", "", "    esac", "", "    for _arg in \"$@\"; do", "        if ! \"$_cmd\" --help $_category | grep -q -- \"$_arg\"; then", "            return 1", "        fi", "    done", "", "    true # not strictly needed", "}", "", "# Check if curl supports the --retry flag, then pass it to the curl invocation.", "check_curl_for_retry_support() {", "  local _retry_supported=\"\"", "  # \"unspecified\" is for arch, allows for possibility old OS using macports, homebrew, etc.", "  if check_help_for \"notspecified\" \"curl\" \"--retry\"; then", "    _retry_supported=\"--retry 3\"", "  fi", "", "  RETVAL=\"$_retry_supported\"", "", "}", "", "# Return cipher suite string specified by user, otherwise return strong TLS 1.2-1.3 cipher suites", "# if support by local tools is detected. Detection currently supports these curl backends:", "# GnuTLS and OpenSSL (possibly also LibreSSL and BoringSSL). Return value can be empty.", "get_ciphersuites_for_curl() {", "    if [ -n \"${RUSTUP_TLS_CIPHERSUITES-}\" ]; then", "        # user specified custom cipher suites, assume they know what they're doing", "        RETVAL=\"$RUSTUP_TLS_CIPHERSUITES\"", "        return", "    fi", "", "    local _openssl_syntax=\"no\"", "    local _gnutls_syntax=\"no\"", "    local _backend_supported=\"yes\"", "    if curl -V | grep -q ' OpenSSL/'; then", "        _openssl_syntax=\"yes\"", "    elif curl -V | grep -iq ' LibreSSL/'; then", "        _openssl_syntax=\"yes\"", "    elif curl -V | grep -iq ' BoringSSL/'; then", "        _openssl_syntax=\"yes\"", "    elif curl -V | grep -iq ' GnuTLS/'; then", "        _gnutls_syntax=\"yes\"", "    else", "        _backend_supported=\"no\"", "    fi", "", "    local _args_supported=\"no\"", "    if [ \"$_backend_supported\" = \"yes\" ]; then", "        # \"unspecified\" is for arch, allows for possibility old OS using macports, homebrew, etc.", "        if check_help_for \"notspecified\" \"curl\" \"--tlsv1.2\" \"--ciphers\" \"--proto\"; then", "            _args_supported=\"yes\"", "        fi", "    fi", "", "    local _cs=\"\"", "    if [ \"$_args_supported\" = \"yes\" ]; then", "        if [ \"$_openssl_syntax\" = \"yes\" ]; then", "            _cs=$(get_strong_ciphersuites_for \"openssl\")", "        elif [ \"$_gnutls_syntax\" = \"yes\" ]; then", "            _cs=$(get_strong_ciphersuites_for \"gnutls\")", "        fi", "    fi", "", "    RETVAL=\"$_cs\"", "}", "", "# Return cipher suite string specified by user, otherwise return strong TLS 1.2-1.3 cipher suites", "# if support by local tools is detected. Detection currently supports these wget backends:", "# GnuTLS and OpenSSL (possibly also LibreSSL and BoringSSL). Return value can be empty.", "get_ciphersuites_for_wget() {", "    if [ -n \"${RUSTUP_TLS_CIPHERSUITES-}\" ]; then", "        # user specified custom cipher suites, assume they know what they're doing", "        RETVAL=\"$RUSTUP_TLS_CIPHERSUITES\"", "        return", "    fi", "", "    local _cs=\"\"", "    if wget -V | grep -q '\\-DHAVE_LIBSSL'; then", "        # \"unspecified\" is for arch, allows for possibility old OS using macports, homebrew, etc.", "        if check_help_for \"notspecified\" \"wget\" \"TLSv1_2\" \"--ciphers\" \"--https-only\" \"--secure-protocol\"; then", "            _cs=$(get_strong_ciphersuites_for \"openssl\")", "        fi", "    elif wget -V | grep -q '\\-DHAVE_LIBGNUTLS'; then", "        # \"unspecified\" is for arch, allows for possibility old OS using macports, homebrew, etc.", "        if check_help_for \"notspecified\" \"wget\" \"TLSv1_2\" \"--ciphers\" \"--https-only\" \"--secure-protocol\"; then", "            _cs=$(get_strong_ciphersuites_for \"gnutls\")", "        fi", "    fi", "", "    RETVAL=\"$_cs\"", "}", "", "# Return strong TLS 1.2-1.3 cipher suites in OpenSSL or GnuTLS syntax. TLS 1.2", "# excludes non-ECDHE and non-AEAD cipher suites. DHE is excluded due to bad", "# DH params often found on servers (see RFC 7919). Sequence matches or is", "# similar to Firefox 68 ESR with weak cipher suites disabled via about:config.", "# $1 must be openssl or gnutls.", "get_strong_ciphersuites_for() {", "    if [ \"$1\" = \"openssl\" ]; then", "        # OpenSSL is forgiving of unknown values, no problems with TLS 1.3 values on versions that don't support it yet.", "        echo \"TLS_AES_128_GCM_SHA256:TLS_CHACHA20_POLY1305_SHA256:TLS_AES_256_GCM_SHA384:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384\"", "    elif [ \"$1\" = \"gnutls\" ]; then", "        # GnuTLS isn't forgiving of unknown values, so this may require a GnuTLS version that supports TLS 1.3 even if wget doesn't.", "        # Begin with SECURE128 (and higher) then remove/add to build cipher suites. Produces same 9 cipher suites as OpenSSL but in slightly different order.", "        echo \"SECURE128:-VERS-SSL3.0:-VERS-TLS1.0:-VERS-TLS1.1:-VERS-DTLS-ALL:-CIPHER-ALL:-MAC-ALL:-KX-ALL:+AEAD:+ECDHE-ECDSA:+ECDHE-RSA:+AES-128-GCM:+CHACHA20-POLY1305:+AES-256-GCM\"", "    fi", "}", "", "main \"$@\" || exit 1", "curl: (6) Could not resolve host: |", "curl: (6) Could not resolve host: sh"]}
2022-12-30 00:12:29,837 p=91217 u=kal n=ansible | PLAY RECAP *******************************************************************************************************************************************
2022-12-30 00:12:29,837 p=91217 u=kal n=ansible | krpz                       : ok=1    changed=0    unreachable=0    failed=1    skipped=0    rescued=0    ignored=0   
2022-12-30 00:13:24,357 p=91432 u=kal n=ansible | PLAY [localhost] *************************************************************************************************************************************
2022-12-30 00:13:24,363 p=91432 u=kal n=ansible | TASK [Gathering Facts] *******************************************************************************************************************************
2022-12-30 00:13:28,325 p=91432 u=kal n=ansible | ok: [krpz]
2022-12-30 00:13:28,357 p=91432 u=kal n=ansible | TASK [Install Rust] **********************************************************************************************************************************
2022-12-30 00:13:28,892 p=91432 u=kal n=ansible | fatal: [krpz]: FAILED! => {"changed": true, "cmd": "curl https://sh.rustup.rs | sh", "delta": "0:00:00.333975", "end": "2022-12-30 00:13:28.851904", "msg": "non-zero return code", "rc": 6, "start": "2022-12-30 00:13:28.517929", "stdout": "#!/bin/sh\r\n# shellcheck shell=dash\r\n\r\n# This is just a little script that can be downloaded from the internet to\r\n# install rustup. It just does platform detection, downloads the installer\r\n# and runs it.\r\n\r\n# It runs on Unix shells like {a,ba,da,k,z}sh. It uses the common `local`\r\n# extension. Note: Most shells limit `local` to 1 var per line, contra bash.\r\n\r\nif [ \"$KSH_VERSION\" = 'Version JM 93t+ 2010-03-05' ]; then\r\n    # The version of ksh93 that ships with many illumos systems does not\r\n    # support the \"local\" extension.  Print a message rather than fail in\r\n    # subtle ways later on:\r\n    echo 'rustup does not work with this ksh93 version; please try bash!' >&2\r\n    exit 1\r\nfi\r\n\r\n\r\nset -u\r\n\r\n# If RUSTUP_UPDATE_ROOT is unset or empty, default it.\r\nRUSTUP_UPDATE_ROOT=\"${RUSTUP_UPDATE_ROOT:-https://static.rust-lang.org/rustup}\"\r\n\r\n#XXX: If you change anything here, please make the same changes in setup_mode.rs\r\nusage() {\r\n    cat 1>&2 <<EOF\r\nrustup-init 1.25.1 (48d233f65 2022-07-12)\r\nThe installer for rustup\r\n\r\nUSAGE:\r\n    rustup-init [FLAGS] [OPTIONS]\r\n\r\nFLAGS:\r\n    -v, --verbose           Enable verbose output\r\n    -q, --quiet             Disable progress output\r\n    -y                      Disable confirmation prompt.\r\n        --no-modify-path    Don't configure the PATH environment variable\r\n    -h, --help              Prints help information\r\n    -V, --version           Prints version information\r\n\r\nOPTIONS:\r\n        --default-host <default-host>              Choose a default host triple\r\n        --default-toolchain <default-toolchain>    Choose a default toolchain to install\r\n        --default-toolchain none                   Do not install any toolchains\r\n        --profile [minimal|default|complete]       Choose a profile\r\n    -c, --component <components>...                Component name to also install\r\n    -t, --target <targets>...                      Target name to also install\r\nEOF\r\n}\r\n\r\nmain() {\r\n    downloader --check\r\n    need_cmd uname\r\n    need_cmd mktemp\r\n    need_cmd chmod\r\n    need_cmd mkdir\r\n    need_cmd rm\r\n    need_cmd rmdir\r\n\r\n    get_architecture || return 1\r\n    local _arch=\"$RETVAL\"\r\n    assert_nz \"$_arch\" \"arch\"\r\n\r\n    local _ext=\"\"\r\n    case \"$_arch\" in\r\n        *windows*)\r\n            _ext=\".exe\"\r\n            ;;\r\n    esac\r\n\r\n    local _url=\"${RUSTUP_UPDATE_ROOT}/dist/${_arch}/rustup-init${_ext}\"\r\n\r\n    local _dir\r\n    _dir=\"$(ensure mktemp -d)\"\r\n    local _file=\"${_dir}/rustup-init${_ext}\"\r\n\r\n    local _ansi_escapes_are_valid=false\r\n    if [ -t 2 ]; then\r\n        if [ \"${TERM+set}\" = 'set' ]; then\r\n            case \"$TERM\" in\r\n                xterm*|rxvt*|urxvt*|linux*|vt*)\r\n                    _ansi_escapes_are_valid=true\r\n                ;;\r\n            esac\r\n        fi\r\n    fi\r\n\r\n    # check if we have to use /dev/tty to prompt the user\r\n    local need_tty=yes\r\n    for arg in \"$@\"; do\r\n        case \"$arg\" in\r\n            --help)\r\n                usage\r\n                exit 0\r\n                ;;\r\n            *)\r\n                OPTIND=1\r\n                if [ \"${arg%%--*}\" = \"\" ]; then\r\n                    # Long option (other than --help);\r\n                    # don't attempt to interpret it.\r\n                    continue\r\n                fi\r\n                while getopts :hy sub_arg \"$arg\"; do\r\n                    case \"$sub_arg\" in\r\n                        h)\r\n                            usage\r\n                            exit 0\r\n                            ;;\r\n                        y)\r\n                            # user wants to skip the prompt --\r\n                            # we don't need /dev/tty\r\n                            need_tty=no\r\n                            ;;\r\n                        *)\r\n                            ;;\r\n                        esac\r\n                done\r\n                ;;\r\n        esac\r\n    done\r\n\r\n    if $_ansi_escapes_are_valid; then\r\n        printf \"\\33[1minfo:\\33[0m downloading installer\\n\" 1>&2\r\n    else\r\n        printf '%s\\n' 'info: downloading installer' 1>&2\r\n    fi\r\n\r\n    ensure mkdir -p \"$_dir\"\r\n    ensure downloader \"$_url\" \"$_file\" \"$_arch\"\r\n    ensure chmod u+x \"$_file\"\r\n    if [ ! -x \"$_file\" ]; then\r\n        printf '%s\\n' \"Cannot execute $_file (likely because of mounting /tmp as noexec).\" 1>&2\r\n        printf '%s\\n' \"Please copy the file to a location where you can execute binaries and run ./rustup-init${_ext}.\" 1>&2\r\n        exit 1\r\n    fi\r\n\r\n    if [ \"$need_tty\" = \"yes\" ] && [ ! -t 0 ]; then\r\n        # The installer is going to want to ask for confirmation by\r\n        # reading stdin.  This script was piped into `sh` though and\r\n        # doesn't have stdin to pass to its children. Instead we're going\r\n        # to explicitly connect /dev/tty to the installer's stdin.\r\n        if [ ! -t 1 ]; then\r\n            err \"Unable to run interactively. Run with -y to accept defaults, --help for additional options\"\r\n        fi\r\n\r\n        ignore \"$_file\" \"$@\" < /dev/tty\r\n    else\r\n        ignore \"$_file\" \"$@\"\r\n    fi\r\n\r\n    local _retval=$?\r\n\r\n    ignore rm \"$_file\"\r\n    ignore rmdir \"$_dir\"\r\n\r\n    return \"$_retval\"\r\n}\r\n\r\ncheck_proc() {\r\n    # Check for /proc by looking for the /proc/self/exe link\r\n    # This is only run on Linux\r\n    if ! test -L /proc/self/exe ; then\r\n        err \"fatal: Unable to find /proc/self/exe.  Is /proc mounted?  Installation cannot proceed without /proc.\"\r\n    fi\r\n}\r\n\r\nget_bitness() {\r\n    need_cmd head\r\n    # Architecture detection without dependencies beyond coreutils.\r\n    # ELF files start out \"\\x7fELF\", and the following byte is\r\n    #   0x01 for 32-bit and\r\n    #   0x02 for 64-bit.\r\n    # The printf builtin on some shells like dash only supports octal\r\n    # escape sequences, so we use those.\r\n    local _current_exe_head\r\n    _current_exe_head=$(head -c 5 /proc/self/exe )\r\n    if [ \"$_current_exe_head\" = \"$(printf '\\177ELF\\001')\" ]; then\r\n        echo 32\r\n    elif [ \"$_current_exe_head\" = \"$(printf '\\177ELF\\002')\" ]; then\r\n        echo 64\r\n    else\r\n        err \"unknown platform bitness\"\r\n    fi\r\n}\r\n\r\nis_host_amd64_elf() {\r\n    need_cmd head\r\n    need_cmd tail\r\n    # ELF e_machine detection without dependencies beyond coreutils.\r\n    # Two-byte field at offset 0x12 indicates the CPU,\r\n    # but we're interested in it being 0x3E to indicate amd64, or not that.\r\n    local _current_exe_machine\r\n    _current_exe_machine=$(head -c 19 /proc/self/exe | tail -c 1)\r\n    [ \"$_current_exe_machine\" = \"$(printf '\\076')\" ]\r\n}\r\n\r\nget_endianness() {\r\n    local cputype=$1\r\n    local suffix_eb=$2\r\n    local suffix_el=$3\r\n\r\n    # detect endianness without od/hexdump, like get_bitness() does.\r\n    need_cmd head\r\n    need_cmd tail\r\n\r\n    local _current_exe_endianness\r\n    _current_exe_endianness=\"$(head -c 6 /proc/self/exe | tail -c 1)\"\r\n    if [ \"$_current_exe_endianness\" = \"$(printf '\\001')\" ]; then\r\n        echo \"${cputype}${suffix_el}\"\r\n    elif [ \"$_current_exe_endianness\" = \"$(printf '\\002')\" ]; then\r\n        echo \"${cputype}${suffix_eb}\"\r\n    else\r\n        err \"unknown platform endianness\"\r\n    fi\r\n}\r\n\r\nget_architecture() {\r\n    local _ostype _cputype _bitness _arch _clibtype\r\n    _ostype=\"$(uname -s)\"\r\n    _cputype=\"$(uname -m)\"\r\n    _clibtype=\"gnu\"\r\n\r\n    if [ \"$_ostype\" = Linux ]; then\r\n        if [ \"$(uname -o)\" = Android ]; then\r\n            _ostype=Android\r\n        fi\r\n        if ldd --version 2>&1 | grep -q 'musl'; then\r\n            _clibtype=\"musl\"\r\n        fi\r\n    fi\r\n\r\n    if [ \"$_ostype\" = Darwin ] && [ \"$_cputype\" = i386 ]; then\r\n        # Darwin `uname -m` lies\r\n        if sysctl hw.optional.x86_64 | grep -q ': 1'; then\r\n            _cputype=x86_64\r\n        fi\r\n    fi\r\n\r\n    if [ \"$_ostype\" = SunOS ]; then\r\n        # Both Solaris and illumos presently announce as \"SunOS\" in \"uname -s\"\r\n        # so use \"uname -o\" to disambiguate.  We use the full path to the\r\n        # system uname in case the user has coreutils uname first in PATH,\r\n        # which has historically sometimes printed the wrong value here.\r\n        if [ \"$(/usr/bin/uname -o)\" = illumos ]; then\r\n            _ostype=illumos\r\n        fi\r\n\r\n        # illumos systems have multi-arch userlands, and \"uname -m\" reports the\r\n        # machine hardware name; e.g., \"i86pc\" on both 32- and 64-bit x86\r\n        # systems.  Check for the native (widest) instruction set on the\r\n        # running kernel:\r\n        if [ \"$_cputype\" = i86pc ]; then\r\n            _cputype=\"$(isainfo -n)\"\r\n        fi\r\n    fi\r\n\r\n    case \"$_ostype\" in\r\n\r\n        Android)\r\n            _ostype=linux-android\r\n            ;;\r\n\r\n        Linux)\r\n            check_proc\r\n            _ostype=unknown-linux-$_clibtype\r\n            _bitness=$(get_bitness)\r\n            ;;\r\n\r\n        FreeBSD)\r\n            _ostype=unknown-freebsd\r\n            ;;\r\n\r\n        NetBSD)\r\n            _ostype=unknown-netbsd\r\n            ;;\r\n\r\n        DragonFly)\r\n            _ostype=unknown-dragonfly\r\n            ;;\r\n\r\n        Darwin)\r\n            _ostype=apple-darwin\r\n            ;;\r\n\r\n        illumos)\r\n            _ostype=unknown-illumos\r\n            ;;\r\n\r\n        MINGW* | MSYS* | CYGWIN* | Windows_NT)\r\n            _ostype=pc-windows-gnu\r\n            ;;\r\n\r\n        *)\r\n            err \"unrecognized OS type: $_ostype\"\r\n            ;;\r\n\r\n    esac\r\n\r\n    case \"$_cputype\" in\r\n\r\n        i386 | i486 | i686 | i786 | x86)\r\n            _cputype=i686\r\n            ;;\r\n\r\n        xscale | arm)\r\n            _cputype=arm\r\n            if [ \"$_ostype\" = \"linux-android\" ]; then\r\n                _ostype=linux-androideabi\r\n            fi\r\n            ;;\r\n\r\n        armv6l)\r\n            _cputype=arm\r\n            if [ \"$_ostype\" = \"linux-android\" ]; then\r\n                _ostype=linux-androideabi\r\n            else\r\n                _ostype=\"${_ostype}eabihf\"\r\n            fi\r\n            ;;\r\n\r\n        armv7l | armv8l)\r\n            _cputype=armv7\r\n            if [ \"$_ostype\" = \"linux-android\" ]; then\r\n                _ostype=linux-androideabi\r\n            else\r\n                _ostype=\"${_ostype}eabihf\"\r\n            fi\r\n            ;;\r\n\r\n        aarch64 | arm64)\r\n            _cputype=aarch64\r\n            ;;\r\n\r\n        x86_64 | x86-64 | x64 | amd64)\r\n            _cputype=x86_64\r\n            ;;\r\n\r\n        mips)\r\n            _cputype=$(get_endianness mips '' el)\r\n            ;;\r\n\r\n        mips64)\r\n            if [ \"$_bitness\" -eq 64 ]; then\r\n                # only n64 ABI is supported for now\r\n                _ostype=\"${_ostype}abi64\"\r\n                _cputype=$(get_endianness mips64 '' el)\r\n            fi\r\n            ;;\r\n\r\n        ppc)\r\n            _cputype=powerpc\r\n            ;;\r\n\r\n        ppc64)\r\n            _cputype=powerpc64\r\n            ;;\r\n\r\n        ppc64le)\r\n            _cputype=powerpc64le\r\n            ;;\r\n\r\n        s390x)\r\n            _cputype=s390x\r\n            ;;\r\n        riscv64)\r\n            _cputype=riscv64gc\r\n            ;;\r\n        *)\r\n            err \"unknown CPU type: $_cputype\"\r\n\r\n    esac\r\n\r\n    # Detect 64-bit linux with 32-bit userland\r\n    if [ \"${_ostype}\" = unknown-linux-gnu ] && [ \"${_bitness}\" -eq 32 ]; then\r\n        case $_cputype in\r\n            x86_64)\r\n                if [ -n \"${RUSTUP_CPUTYPE:-}\" ]; then\r\n                    _cputype=\"$RUSTUP_CPUTYPE\"\r\n                else {\r\n                    # 32-bit executable for amd64 = x32\r\n                    if is_host_amd64_elf; then {\r\n                         echo \"This host is running an x32 userland; as it stands, x32 support is poor,\" 1>&2\r\n                         echo \"and there isn't a native toolchain -- you will have to install\" 1>&2\r\n                         echo \"multiarch compatibility with i686 and/or amd64, then select one\" 1>&2\r\n                         echo \"by re-running this script with the RUSTUP_CPUTYPE environment variable\" 1>&2\r\n                         echo \"set to i686 or x86_64, respectively.\" 1>&2\r\n                         echo 1>&2\r\n                         echo \"You will be able to add an x32 target after installation by running\" 1>&2\r\n                         echo \"  rustup target add x86_64-unknown-linux-gnux32\" 1>&2\r\n                         exit 1\r\n                    }; else\r\n                        _cputype=i686\r\n                    fi\r\n                }; fi\r\n                ;;\r\n            mips64)\r\n                _cputype=$(get_endianness mips '' el)\r\n                ;;\r\n            powerpc64)\r\n                _cputype=powerpc\r\n                ;;\r\n            aarch64)\r\n                _cputype=armv7\r\n                if [ \"$_ostype\" = \"linux-android\" ]; then\r\n                    _ostype=linux-androideabi\r\n                else\r\n                    _ostype=\"${_ostype}eabihf\"\r\n                fi\r\n                ;;\r\n            riscv64gc)\r\n                err \"riscv64 with 32-bit userland unsupported\"\r\n                ;;\r\n        esac\r\n    fi\r\n\r\n    # Detect armv7 but without the CPU features Rust needs in that build,\r\n    # and fall back to arm.\r\n    # See https://github.com/rust-lang/rustup.rs/issues/587.\r\n    if [ \"$_ostype\" = \"unknown-linux-gnueabihf\" ] && [ \"$_cputype\" = armv7 ]; then\r\n        if ensure grep '^Features' /proc/cpuinfo | grep -q -v neon; then\r\n            # At least one processor does not have NEON.\r\n            _cputype=arm\r\n        fi\r\n    fi\r\n\r\n    _arch=\"${_cputype}-${_ostype}\"\r\n\r\n    RETVAL=\"$_arch\"\r\n}\r\n\r\nsay() {\r\n    printf 'rustup: %s\\n' \"$1\"\r\n}\r\n\r\nerr() {\r\n    say \"$1\" >&2\r\n    exit 1\r\n}\r\n\r\nneed_cmd() {\r\n    if ! check_cmd \"$1\"; then\r\n        err \"need '$1' (command not found)\"\r\n    fi\r\n}\r\n\r\ncheck_cmd() {\r\n    command -v \"$1\" > /dev/null 2>&1\r\n}\r\n\r\nassert_nz() {\r\n    if [ -z \"$1\" ]; then err \"assert_nz $2\"; fi\r\n}\r\n\r\n# Run a command that should never fail. If the command fails execution\r\n# will immediately terminate with an error showing the failing\r\n# command.\r\nensure() {\r\n    if ! \"$@\"; then err \"command failed: $*\"; fi\r\n}\r\n\r\n# This is just for indicating that commands' results are being\r\n# intentionally ignored. Usually, because it's being executed\r\n# as part of error handling.\r\nignore() {\r\n    \"$@\"\r\n}\r\n\r\n# This wraps curl or wget. Try curl first, if not installed,\r\n# use wget instead.\r\ndownloader() {\r\n    local _dld\r\n    local _ciphersuites\r\n    local _err\r\n    local _status\r\n    local _retry\r\n    if check_cmd curl; then\r\n        _dld=curl\r\n    elif check_cmd wget; then\r\n        _dld=wget\r\n    else\r\n        _dld='curl or wget' # to be used in error message of need_cmd\r\n    fi\r\n\r\n    if [ \"$1\" = --check ]; then\r\n        need_cmd \"$_dld\"\r\n    elif [ \"$_dld\" = curl ]; then\r\n        check_curl_for_retry_support\r\n        _retry=\"$RETVAL\"\r\n        get_ciphersuites_for_curl\r\n        _ciphersuites=\"$RETVAL\"\r\n        if [ -n \"$_ciphersuites\" ]; then\r\n            _err=$(curl $_retry --proto '=https' --tlsv1.2 --ciphers \"$_ciphersuites\" --silent --show-error --fail --location \"$1\" --output \"$2\" 2>&1)\r\n            _status=$?\r\n        else\r\n            echo \"Warning: Not enforcing strong cipher suites for TLS, this is potentially less secure\"\r\n            if ! check_help_for \"$3\" curl --proto --tlsv1.2; then\r\n                echo \"Warning: Not enforcing TLS v1.2, this is potentially less secure\"\r\n                _err=$(curl $_retry --silent --show-error --fail --location \"$1\" --output \"$2\" 2>&1)\r\n                _status=$?\r\n            else\r\n                _err=$(curl $_retry --proto '=https' --tlsv1.2 --silent --show-error --fail --location \"$1\" --output \"$2\" 2>&1)\r\n                _status=$?\r\n            fi\r\n        fi\r\n        if [ -n \"$_err\" ]; then\r\n            echo \"$_err\" >&2\r\n            if echo \"$_err\" | grep -q 404$; then\r\n                err \"installer for platform '$3' not found, this may be unsupported\"\r\n            fi\r\n        fi\r\n        return $_status\r\n    elif [ \"$_dld\" = wget ]; then\r\n        if [ \"$(wget -V 2>&1|head -2|tail -1|cut -f1 -d\" \")\" = \"BusyBox\" ]; then\r\n            echo \"Warning: using the BusyBox version of wget.  Not enforcing strong cipher suites for TLS or TLS v1.2, this is potentially less secure\"\r\n            _err=$(wget \"$1\" -O \"$2\" 2>&1)\r\n            _status=$?\r\n        else\r\n            get_ciphersuites_for_wget\r\n            _ciphersuites=\"$RETVAL\"\r\n            if [ -n \"$_ciphersuites\" ]; then\r\n                _err=$(wget --https-only --secure-protocol=TLSv1_2 --ciphers \"$_ciphersuites\" \"$1\" -O \"$2\" 2>&1)\r\n                _status=$?\r\n            else\r\n                echo \"Warning: Not enforcing strong cipher suites for TLS, this is potentially less secure\"\r\n                if ! check_help_for \"$3\" wget --https-only --secure-protocol; then\r\n                    echo \"Warning: Not enforcing TLS v1.2, this is potentially less secure\"\r\n                    _err=$(wget \"$1\" -O \"$2\" 2>&1)\r\n                    _status=$?\r\n                else\r\n                    _err=$(wget --https-only --secure-protocol=TLSv1_2 \"$1\" -O \"$2\" 2>&1)\r\n                    _status=$?\r\n                fi\r\n            fi\r\n        fi\r\n        if [ -n \"$_err\" ]; then\r\n            echo \"$_err\" >&2\r\n            if echo \"$_err\" | grep -q ' 404 Not Found$'; then\r\n                err \"installer for platform '$3' not found, this may be unsupported\"\r\n            fi\r\n        fi\r\n        return $_status\r\n    else\r\n        err \"Unknown downloader\"   # should not reach here\r\n    fi\r\n}\r\n\r\ncheck_help_for() {\r\n    local _arch\r\n    local _cmd\r\n    local _arg\r\n    _arch=\"$1\"\r\n    shift\r\n    _cmd=\"$1\"\r\n    shift\r\n\r\n    local _category\r\n    if \"$_cmd\" --help | grep -q 'For all options use the manual or \"--help all\".'; then\r\n      _category=\"all\"\r\n    else\r\n      _category=\"\"\r\n    fi\r\n\r\n    case \"$_arch\" in\r\n\r\n        *darwin*)\r\n        if check_cmd sw_vers; then\r\n            case $(sw_vers -productVersion) in\r\n                10.*)\r\n                    # If we're running on macOS, older than 10.13, then we always\r\n                    # fail to find these options to force fallback\r\n                    if [ \"$(sw_vers -productVersion | cut -d. -f2)\" -lt 13 ]; then\r\n                        # Older than 10.13\r\n                        echo \"Warning: Detected macOS platform older than 10.13\"\r\n                        return 1\r\n                    fi\r\n                    ;;\r\n                11.*)\r\n                    # We assume Big Sur will be OK for now\r\n                    ;;\r\n                *)\r\n                    # Unknown product version, warn and continue\r\n                    echo \"Warning: Detected unknown macOS major version: $(sw_vers -productVersion)\"\r\n                    echo \"Warning TLS capabilities detection may fail\"\r\n                    ;;\r\n            esac\r\n        fi\r\n        ;;\r\n\r\n    esac\r\n\r\n    for _arg in \"$@\"; do\r\n        if ! \"$_cmd\" --help $_category | grep -q -- \"$_arg\"; then\r\n            return 1\r\n        fi\r\n    done\r\n\r\n    true # not strictly needed\r\n}\r\n\r\n# Check if curl supports the --retry flag, then pass it to the curl invocation.\r\ncheck_curl_for_retry_support() {\r\n  local _retry_supported=\"\"\r\n  # \"unspecified\" is for arch, allows for possibility old OS using macports, homebrew, etc.\r\n  if check_help_for \"notspecified\" \"curl\" \"--retry\"; then\r\n    _retry_supported=\"--retry 3\"\r\n  fi\r\n\r\n  RETVAL=\"$_retry_supported\"\r\n\r\n}\r\n\r\n# Return cipher suite string specified by user, otherwise return strong TLS 1.2-1.3 cipher suites\r\n# if support by local tools is detected. Detection currently supports these curl backends:\r\n# GnuTLS and OpenSSL (possibly also LibreSSL and BoringSSL). Return value can be empty.\r\nget_ciphersuites_for_curl() {\r\n    if [ -n \"${RUSTUP_TLS_CIPHERSUITES-}\" ]; then\r\n        # user specified custom cipher suites, assume they know what they're doing\r\n        RETVAL=\"$RUSTUP_TLS_CIPHERSUITES\"\r\n        return\r\n    fi\r\n\r\n    local _openssl_syntax=\"no\"\r\n    local _gnutls_syntax=\"no\"\r\n    local _backend_supported=\"yes\"\r\n    if curl -V | grep -q ' OpenSSL/'; then\r\n        _openssl_syntax=\"yes\"\r\n    elif curl -V | grep -iq ' LibreSSL/'; then\r\n        _openssl_syntax=\"yes\"\r\n    elif curl -V | grep -iq ' BoringSSL/'; then\r\n        _openssl_syntax=\"yes\"\r\n    elif curl -V | grep -iq ' GnuTLS/'; then\r\n        _gnutls_syntax=\"yes\"\r\n    else\r\n        _backend_supported=\"no\"\r\n    fi\r\n\r\n    local _args_supported=\"no\"\r\n    if [ \"$_backend_supported\" = \"yes\" ]; then\r\n        # \"unspecified\" is for arch, allows for possibility old OS using macports, homebrew, etc.\r\n        if check_help_for \"notspecified\" \"curl\" \"--tlsv1.2\" \"--ciphers\" \"--proto\"; then\r\n            _args_supported=\"yes\"\r\n        fi\r\n    fi\r\n\r\n    local _cs=\"\"\r\n    if [ \"$_args_supported\" = \"yes\" ]; then\r\n        if [ \"$_openssl_syntax\" = \"yes\" ]; then\r\n            _cs=$(get_strong_ciphersuites_for \"openssl\")\r\n        elif [ \"$_gnutls_syntax\" = \"yes\" ]; then\r\n            _cs=$(get_strong_ciphersuites_for \"gnutls\")\r\n        fi\r\n    fi\r\n\r\n    RETVAL=\"$_cs\"\r\n}\r\n\r\n# Return cipher suite string specified by user, otherwise return strong TLS 1.2-1.3 cipher suites\r\n# if support by local tools is detected. Detection currently supports these wget backends:\r\n# GnuTLS and OpenSSL (possibly also LibreSSL and BoringSSL). Return value can be empty.\r\nget_ciphersuites_for_wget() {\r\n    if [ -n \"${RUSTUP_TLS_CIPHERSUITES-}\" ]; then\r\n        # user specified custom cipher suites, assume they know what they're doing\r\n        RETVAL=\"$RUSTUP_TLS_CIPHERSUITES\"\r\n        return\r\n    fi\r\n\r\n    local _cs=\"\"\r\n    if wget -V | grep -q '\\-DHAVE_LIBSSL'; then\r\n        # \"unspecified\" is for arch, allows for possibility old OS using macports, homebrew, etc.\r\n        if check_help_for \"notspecified\" \"wget\" \"TLSv1_2\" \"--ciphers\" \"--https-only\" \"--secure-protocol\"; then\r\n            _cs=$(get_strong_ciphersuites_for \"openssl\")\r\n        fi\r\n    elif wget -V | grep -q '\\-DHAVE_LIBGNUTLS'; then\r\n        # \"unspecified\" is for arch, allows for possibility old OS using macports, homebrew, etc.\r\n        if check_help_for \"notspecified\" \"wget\" \"TLSv1_2\" \"--ciphers\" \"--https-only\" \"--secure-protocol\"; then\r\n            _cs=$(get_strong_ciphersuites_for \"gnutls\")\r\n        fi\r\n    fi\r\n\r\n    RETVAL=\"$_cs\"\r\n}\r\n\r\n# Return strong TLS 1.2-1.3 cipher suites in OpenSSL or GnuTLS syntax. TLS 1.2\r\n# excludes non-ECDHE and non-AEAD cipher suites. DHE is excluded due to bad\r\n# DH params often found on servers (see RFC 7919). Sequence matches or is\r\n# similar to Firefox 68 ESR with weak cipher suites disabled via about:config.\r\n# $1 must be openssl or gnutls.\r\nget_strong_ciphersuites_for() {\r\n    if [ \"$1\" = \"openssl\" ]; then\r\n        # OpenSSL is forgiving of unknown values, no problems with TLS 1.3 values on versions that don't support it yet.\r\n        echo \"TLS_AES_128_GCM_SHA256:TLS_CHACHA20_POLY1305_SHA256:TLS_AES_256_GCM_SHA384:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384\"\r\n    elif [ \"$1\" = \"gnutls\" ]; then\r\n        # GnuTLS isn't forgiving of unknown values, so this may require a GnuTLS version that supports TLS 1.3 even if wget doesn't.\r\n        # Begin with SECURE128 (and higher) then remove/add to build cipher suites. Produces same 9 cipher suites as OpenSSL but in slightly different order.\r\n        echo \"SECURE128:-VERS-SSL3.0:-VERS-TLS1.0:-VERS-TLS1.1:-VERS-DTLS-ALL:-CIPHER-ALL:-MAC-ALL:-KX-ALL:+AEAD:+ECDHE-ECDSA:+ECDHE-RSA:+AES-128-GCM:+CHACHA20-POLY1305:+AES-256-GCM\"\r\n    fi\r\n}\r\n\r\nmain \"$@\" || exit 1\r\ncurl: (6) Could not resolve host: |\r\ncurl: (6) Could not resolve host: sh", "stdout_lines": ["#!/bin/sh", "# shellcheck shell=dash", "", "# This is just a little script that can be downloaded from the internet to", "# install rustup. It just does platform detection, downloads the installer", "# and runs it.", "", "# It runs on Unix shells like {a,ba,da,k,z}sh. It uses the common `local`", "# extension. Note: Most shells limit `local` to 1 var per line, contra bash.", "", "if [ \"$KSH_VERSION\" = 'Version JM 93t+ 2010-03-05' ]; then", "    # The version of ksh93 that ships with many illumos systems does not", "    # support the \"local\" extension.  Print a message rather than fail in", "    # subtle ways later on:", "    echo 'rustup does not work with this ksh93 version; please try bash!' >&2", "    exit 1", "fi", "", "", "set -u", "", "# If RUSTUP_UPDATE_ROOT is unset or empty, default it.", "RUSTUP_UPDATE_ROOT=\"${RUSTUP_UPDATE_ROOT:-https://static.rust-lang.org/rustup}\"", "", "#XXX: If you change anything here, please make the same changes in setup_mode.rs", "usage() {", "    cat 1>&2 <<EOF", "rustup-init 1.25.1 (48d233f65 2022-07-12)", "The installer for rustup", "", "USAGE:", "    rustup-init [FLAGS] [OPTIONS]", "", "FLAGS:", "    -v, --verbose           Enable verbose output", "    -q, --quiet             Disable progress output", "    -y                      Disable confirmation prompt.", "        --no-modify-path    Don't configure the PATH environment variable", "    -h, --help              Prints help information", "    -V, --version           Prints version information", "", "OPTIONS:", "        --default-host <default-host>              Choose a default host triple", "        --default-toolchain <default-toolchain>    Choose a default toolchain to install", "        --default-toolchain none                   Do not install any toolchains", "        --profile [minimal|default|complete]       Choose a profile", "    -c, --component <components>...                Component name to also install", "    -t, --target <targets>...                      Target name to also install", "EOF", "}", "", "main() {", "    downloader --check", "    need_cmd uname", "    need_cmd mktemp", "    need_cmd chmod", "    need_cmd mkdir", "    need_cmd rm", "    need_cmd rmdir", "", "    get_architecture || return 1", "    local _arch=\"$RETVAL\"", "    assert_nz \"$_arch\" \"arch\"", "", "    local _ext=\"\"", "    case \"$_arch\" in", "        *windows*)", "            _ext=\".exe\"", "            ;;", "    esac", "", "    local _url=\"${RUSTUP_UPDATE_ROOT}/dist/${_arch}/rustup-init${_ext}\"", "", "    local _dir", "    _dir=\"$(ensure mktemp -d)\"", "    local _file=\"${_dir}/rustup-init${_ext}\"", "", "    local _ansi_escapes_are_valid=false", "    if [ -t 2 ]; then", "        if [ \"${TERM+set}\" = 'set' ]; then", "            case \"$TERM\" in", "                xterm*|rxvt*|urxvt*|linux*|vt*)", "                    _ansi_escapes_are_valid=true", "                ;;", "            esac", "        fi", "    fi", "", "    # check if we have to use /dev/tty to prompt the user", "    local need_tty=yes", "    for arg in \"$@\"; do", "        case \"$arg\" in", "            --help)", "                usage", "                exit 0", "                ;;", "            *)", "                OPTIND=1", "                if [ \"${arg%%--*}\" = \"\" ]; then", "                    # Long option (other than --help);", "                    # don't attempt to interpret it.", "                    continue", "                fi", "                while getopts :hy sub_arg \"$arg\"; do", "                    case \"$sub_arg\" in", "                        h)", "                            usage", "                            exit 0", "                            ;;", "                        y)", "                            # user wants to skip the prompt --", "                            # we don't need /dev/tty", "                            need_tty=no", "                            ;;", "                        *)", "                            ;;", "                        esac", "                done", "                ;;", "        esac", "    done", "", "    if $_ansi_escapes_are_valid; then", "        printf \"\\33[1minfo:\\33[0m downloading installer\\n\" 1>&2", "    else", "        printf '%s\\n' 'info: downloading installer' 1>&2", "    fi", "", "    ensure mkdir -p \"$_dir\"", "    ensure downloader \"$_url\" \"$_file\" \"$_arch\"", "    ensure chmod u+x \"$_file\"", "    if [ ! -x \"$_file\" ]; then", "        printf '%s\\n' \"Cannot execute $_file (likely because of mounting /tmp as noexec).\" 1>&2", "        printf '%s\\n' \"Please copy the file to a location where you can execute binaries and run ./rustup-init${_ext}.\" 1>&2", "        exit 1", "    fi", "", "    if [ \"$need_tty\" = \"yes\" ] && [ ! -t 0 ]; then", "        # The installer is going to want to ask for confirmation by", "        # reading stdin.  This script was piped into `sh` though and", "        # doesn't have stdin to pass to its children. Instead we're going", "        # to explicitly connect /dev/tty to the installer's stdin.", "        if [ ! -t 1 ]; then", "            err \"Unable to run interactively. Run with -y to accept defaults, --help for additional options\"", "        fi", "", "        ignore \"$_file\" \"$@\" < /dev/tty", "    else", "        ignore \"$_file\" \"$@\"", "    fi", "", "    local _retval=$?", "", "    ignore rm \"$_file\"", "    ignore rmdir \"$_dir\"", "", "    return \"$_retval\"", "}", "", "check_proc() {", "    # Check for /proc by looking for the /proc/self/exe link", "    # This is only run on Linux", "    if ! test -L /proc/self/exe ; then", "        err \"fatal: Unable to find /proc/self/exe.  Is /proc mounted?  Installation cannot proceed without /proc.\"", "    fi", "}", "", "get_bitness() {", "    need_cmd head", "    # Architecture detection without dependencies beyond coreutils.", "    # ELF files start out \"\\x7fELF\", and the following byte is", "    #   0x01 for 32-bit and", "    #   0x02 for 64-bit.", "    # The printf builtin on some shells like dash only supports octal", "    # escape sequences, so we use those.", "    local _current_exe_head", "    _current_exe_head=$(head -c 5 /proc/self/exe )", "    if [ \"$_current_exe_head\" = \"$(printf '\\177ELF\\001')\" ]; then", "        echo 32", "    elif [ \"$_current_exe_head\" = \"$(printf '\\177ELF\\002')\" ]; then", "        echo 64", "    else", "        err \"unknown platform bitness\"", "    fi", "}", "", "is_host_amd64_elf() {", "    need_cmd head", "    need_cmd tail", "    # ELF e_machine detection without dependencies beyond coreutils.", "    # Two-byte field at offset 0x12 indicates the CPU,", "    # but we're interested in it being 0x3E to indicate amd64, or not that.", "    local _current_exe_machine", "    _current_exe_machine=$(head -c 19 /proc/self/exe | tail -c 1)", "    [ \"$_current_exe_machine\" = \"$(printf '\\076')\" ]", "}", "", "get_endianness() {", "    local cputype=$1", "    local suffix_eb=$2", "    local suffix_el=$3", "", "    # detect endianness without od/hexdump, like get_bitness() does.", "    need_cmd head", "    need_cmd tail", "", "    local _current_exe_endianness", "    _current_exe_endianness=\"$(head -c 6 /proc/self/exe | tail -c 1)\"", "    if [ \"$_current_exe_endianness\" = \"$(printf '\\001')\" ]; then", "        echo \"${cputype}${suffix_el}\"", "    elif [ \"$_current_exe_endianness\" = \"$(printf '\\002')\" ]; then", "        echo \"${cputype}${suffix_eb}\"", "    else", "        err \"unknown platform endianness\"", "    fi", "}", "", "get_architecture() {", "    local _ostype _cputype _bitness _arch _clibtype", "    _ostype=\"$(uname -s)\"", "    _cputype=\"$(uname -m)\"", "    _clibtype=\"gnu\"", "", "    if [ \"$_ostype\" = Linux ]; then", "        if [ \"$(uname -o)\" = Android ]; then", "            _ostype=Android", "        fi", "        if ldd --version 2>&1 | grep -q 'musl'; then", "            _clibtype=\"musl\"", "        fi", "    fi", "", "    if [ \"$_ostype\" = Darwin ] && [ \"$_cputype\" = i386 ]; then", "        # Darwin `uname -m` lies", "        if sysctl hw.optional.x86_64 | grep -q ': 1'; then", "            _cputype=x86_64", "        fi", "    fi", "", "    if [ \"$_ostype\" = SunOS ]; then", "        # Both Solaris and illumos presently announce as \"SunOS\" in \"uname -s\"", "        # so use \"uname -o\" to disambiguate.  We use the full path to the", "        # system uname in case the user has coreutils uname first in PATH,", "        # which has historically sometimes printed the wrong value here.", "        if [ \"$(/usr/bin/uname -o)\" = illumos ]; then", "            _ostype=illumos", "        fi", "", "        # illumos systems have multi-arch userlands, and \"uname -m\" reports the", "        # machine hardware name; e.g., \"i86pc\" on both 32- and 64-bit x86", "        # systems.  Check for the native (widest) instruction set on the", "        # running kernel:", "        if [ \"$_cputype\" = i86pc ]; then", "            _cputype=\"$(isainfo -n)\"", "        fi", "    fi", "", "    case \"$_ostype\" in", "", "        Android)", "            _ostype=linux-android", "            ;;", "", "        Linux)", "            check_proc", "            _ostype=unknown-linux-$_clibtype", "            _bitness=$(get_bitness)", "            ;;", "", "        FreeBSD)", "            _ostype=unknown-freebsd", "            ;;", "", "        NetBSD)", "            _ostype=unknown-netbsd", "            ;;", "", "        DragonFly)", "            _ostype=unknown-dragonfly", "            ;;", "", "        Darwin)", "            _ostype=apple-darwin", "            ;;", "", "        illumos)", "            _ostype=unknown-illumos", "            ;;", "", "        MINGW* | MSYS* | CYGWIN* | Windows_NT)", "            _ostype=pc-windows-gnu", "            ;;", "", "        *)", "            err \"unrecognized OS type: $_ostype\"", "            ;;", "", "    esac", "", "    case \"$_cputype\" in", "", "        i386 | i486 | i686 | i786 | x86)", "            _cputype=i686", "            ;;", "", "        xscale | arm)", "            _cputype=arm", "            if [ \"$_ostype\" = \"linux-android\" ]; then", "                _ostype=linux-androideabi", "            fi", "            ;;", "", "        armv6l)", "            _cputype=arm", "            if [ \"$_ostype\" = \"linux-android\" ]; then", "                _ostype=linux-androideabi", "            else", "                _ostype=\"${_ostype}eabihf\"", "            fi", "            ;;", "", "        armv7l | armv8l)", "            _cputype=armv7", "            if [ \"$_ostype\" = \"linux-android\" ]; then", "                _ostype=linux-androideabi", "            else", "                _ostype=\"${_ostype}eabihf\"", "            fi", "            ;;", "", "        aarch64 | arm64)", "            _cputype=aarch64", "            ;;", "", "        x86_64 | x86-64 | x64 | amd64)", "            _cputype=x86_64", "            ;;", "", "        mips)", "            _cputype=$(get_endianness mips '' el)", "            ;;", "", "        mips64)", "            if [ \"$_bitness\" -eq 64 ]; then", "                # only n64 ABI is supported for now", "                _ostype=\"${_ostype}abi64\"", "                _cputype=$(get_endianness mips64 '' el)", "            fi", "            ;;", "", "        ppc)", "            _cputype=powerpc", "            ;;", "", "        ppc64)", "            _cputype=powerpc64", "            ;;", "", "        ppc64le)", "            _cputype=powerpc64le", "            ;;", "", "        s390x)", "            _cputype=s390x", "            ;;", "        riscv64)", "            _cputype=riscv64gc", "            ;;", "        *)", "            err \"unknown CPU type: $_cputype\"", "", "    esac", "", "    # Detect 64-bit linux with 32-bit userland", "    if [ \"${_ostype}\" = unknown-linux-gnu ] && [ \"${_bitness}\" -eq 32 ]; then", "        case $_cputype in", "            x86_64)", "                if [ -n \"${RUSTUP_CPUTYPE:-}\" ]; then", "                    _cputype=\"$RUSTUP_CPUTYPE\"", "                else {", "                    # 32-bit executable for amd64 = x32", "                    if is_host_amd64_elf; then {", "                         echo \"This host is running an x32 userland; as it stands, x32 support is poor,\" 1>&2", "                         echo \"and there isn't a native toolchain -- you will have to install\" 1>&2", "                         echo \"multiarch compatibility with i686 and/or amd64, then select one\" 1>&2", "                         echo \"by re-running this script with the RUSTUP_CPUTYPE environment variable\" 1>&2", "                         echo \"set to i686 or x86_64, respectively.\" 1>&2", "                         echo 1>&2", "                         echo \"You will be able to add an x32 target after installation by running\" 1>&2", "                         echo \"  rustup target add x86_64-unknown-linux-gnux32\" 1>&2", "                         exit 1", "                    }; else", "                        _cputype=i686", "                    fi", "                }; fi", "                ;;", "            mips64)", "                _cputype=$(get_endianness mips '' el)", "                ;;", "            powerpc64)", "                _cputype=powerpc", "                ;;", "            aarch64)", "                _cputype=armv7", "                if [ \"$_ostype\" = \"linux-android\" ]; then", "                    _ostype=linux-androideabi", "                else", "                    _ostype=\"${_ostype}eabihf\"", "                fi", "                ;;", "            riscv64gc)", "                err \"riscv64 with 32-bit userland unsupported\"", "                ;;", "        esac", "    fi", "", "    # Detect armv7 but without the CPU features Rust needs in that build,", "    # and fall back to arm.", "    # See https://github.com/rust-lang/rustup.rs/issues/587.", "    if [ \"$_ostype\" = \"unknown-linux-gnueabihf\" ] && [ \"$_cputype\" = armv7 ]; then", "        if ensure grep '^Features' /proc/cpuinfo | grep -q -v neon; then", "            # At least one processor does not have NEON.", "            _cputype=arm", "        fi", "    fi", "", "    _arch=\"${_cputype}-${_ostype}\"", "", "    RETVAL=\"$_arch\"", "}", "", "say() {", "    printf 'rustup: %s\\n' \"$1\"", "}", "", "err() {", "    say \"$1\" >&2", "    exit 1", "}", "", "need_cmd() {", "    if ! check_cmd \"$1\"; then", "        err \"need '$1' (command not found)\"", "    fi", "}", "", "check_cmd() {", "    command -v \"$1\" > /dev/null 2>&1", "}", "", "assert_nz() {", "    if [ -z \"$1\" ]; then err \"assert_nz $2\"; fi", "}", "", "# Run a command that should never fail. If the command fails execution", "# will immediately terminate with an error showing the failing", "# command.", "ensure() {", "    if ! \"$@\"; then err \"command failed: $*\"; fi", "}", "", "# This is just for indicating that commands' results are being", "# intentionally ignored. Usually, because it's being executed", "# as part of error handling.", "ignore() {", "    \"$@\"", "}", "", "# This wraps curl or wget. Try curl first, if not installed,", "# use wget instead.", "downloader() {", "    local _dld", "    local _ciphersuites", "    local _err", "    local _status", "    local _retry", "    if check_cmd curl; then", "        _dld=curl", "    elif check_cmd wget; then", "        _dld=wget", "    else", "        _dld='curl or wget' # to be used in error message of need_cmd", "    fi", "", "    if [ \"$1\" = --check ]; then", "        need_cmd \"$_dld\"", "    elif [ \"$_dld\" = curl ]; then", "        check_curl_for_retry_support", "        _retry=\"$RETVAL\"", "        get_ciphersuites_for_curl", "        _ciphersuites=\"$RETVAL\"", "        if [ -n \"$_ciphersuites\" ]; then", "            _err=$(curl $_retry --proto '=https' --tlsv1.2 --ciphers \"$_ciphersuites\" --silent --show-error --fail --location \"$1\" --output \"$2\" 2>&1)", "            _status=$?", "        else", "            echo \"Warning: Not enforcing strong cipher suites for TLS, this is potentially less secure\"", "            if ! check_help_for \"$3\" curl --proto --tlsv1.2; then", "                echo \"Warning: Not enforcing TLS v1.2, this is potentially less secure\"", "                _err=$(curl $_retry --silent --show-error --fail --location \"$1\" --output \"$2\" 2>&1)", "                _status=$?", "            else", "                _err=$(curl $_retry --proto '=https' --tlsv1.2 --silent --show-error --fail --location \"$1\" --output \"$2\" 2>&1)", "                _status=$?", "            fi", "        fi", "        if [ -n \"$_err\" ]; then", "            echo \"$_err\" >&2", "            if echo \"$_err\" | grep -q 404$; then", "                err \"installer for platform '$3' not found, this may be unsupported\"", "            fi", "        fi", "        return $_status", "    elif [ \"$_dld\" = wget ]; then", "        if [ \"$(wget -V 2>&1|head -2|tail -1|cut -f1 -d\" \")\" = \"BusyBox\" ]; then", "            echo \"Warning: using the BusyBox version of wget.  Not enforcing strong cipher suites for TLS or TLS v1.2, this is potentially less secure\"", "            _err=$(wget \"$1\" -O \"$2\" 2>&1)", "            _status=$?", "        else", "            get_ciphersuites_for_wget", "            _ciphersuites=\"$RETVAL\"", "            if [ -n \"$_ciphersuites\" ]; then", "                _err=$(wget --https-only --secure-protocol=TLSv1_2 --ciphers \"$_ciphersuites\" \"$1\" -O \"$2\" 2>&1)", "                _status=$?", "            else", "                echo \"Warning: Not enforcing strong cipher suites for TLS, this is potentially less secure\"", "                if ! check_help_for \"$3\" wget --https-only --secure-protocol; then", "                    echo \"Warning: Not enforcing TLS v1.2, this is potentially less secure\"", "                    _err=$(wget \"$1\" -O \"$2\" 2>&1)", "                    _status=$?", "                else", "                    _err=$(wget --https-only --secure-protocol=TLSv1_2 \"$1\" -O \"$2\" 2>&1)", "                    _status=$?", "                fi", "            fi", "        fi", "        if [ -n \"$_err\" ]; then", "            echo \"$_err\" >&2", "            if echo \"$_err\" | grep -q ' 404 Not Found$'; then", "                err \"installer for platform '$3' not found, this may be unsupported\"", "            fi", "        fi", "        return $_status", "    else", "        err \"Unknown downloader\"   # should not reach here", "    fi", "}", "", "check_help_for() {", "    local _arch", "    local _cmd", "    local _arg", "    _arch=\"$1\"", "    shift", "    _cmd=\"$1\"", "    shift", "", "    local _category", "    if \"$_cmd\" --help | grep -q 'For all options use the manual or \"--help all\".'; then", "      _category=\"all\"", "    else", "      _category=\"\"", "    fi", "", "    case \"$_arch\" in", "", "        *darwin*)", "        if check_cmd sw_vers; then", "            case $(sw_vers -productVersion) in", "                10.*)", "                    # If we're running on macOS, older than 10.13, then we always", "                    # fail to find these options to force fallback", "                    if [ \"$(sw_vers -productVersion | cut -d. -f2)\" -lt 13 ]; then", "                        # Older than 10.13", "                        echo \"Warning: Detected macOS platform older than 10.13\"", "                        return 1", "                    fi", "                    ;;", "                11.*)", "                    # We assume Big Sur will be OK for now", "                    ;;", "                *)", "                    # Unknown product version, warn and continue", "                    echo \"Warning: Detected unknown macOS major version: $(sw_vers -productVersion)\"", "                    echo \"Warning TLS capabilities detection may fail\"", "                    ;;", "            esac", "        fi", "        ;;", "", "    esac", "", "    for _arg in \"$@\"; do", "        if ! \"$_cmd\" --help $_category | grep -q -- \"$_arg\"; then", "            return 1", "        fi", "    done", "", "    true # not strictly needed", "}", "", "# Check if curl supports the --retry flag, then pass it to the curl invocation.", "check_curl_for_retry_support() {", "  local _retry_supported=\"\"", "  # \"unspecified\" is for arch, allows for possibility old OS using macports, homebrew, etc.", "  if check_help_for \"notspecified\" \"curl\" \"--retry\"; then", "    _retry_supported=\"--retry 3\"", "  fi", "", "  RETVAL=\"$_retry_supported\"", "", "}", "", "# Return cipher suite string specified by user, otherwise return strong TLS 1.2-1.3 cipher suites", "# if support by local tools is detected. Detection currently supports these curl backends:", "# GnuTLS and OpenSSL (possibly also LibreSSL and BoringSSL). Return value can be empty.", "get_ciphersuites_for_curl() {", "    if [ -n \"${RUSTUP_TLS_CIPHERSUITES-}\" ]; then", "        # user specified custom cipher suites, assume they know what they're doing", "        RETVAL=\"$RUSTUP_TLS_CIPHERSUITES\"", "        return", "    fi", "", "    local _openssl_syntax=\"no\"", "    local _gnutls_syntax=\"no\"", "    local _backend_supported=\"yes\"", "    if curl -V | grep -q ' OpenSSL/'; then", "        _openssl_syntax=\"yes\"", "    elif curl -V | grep -iq ' LibreSSL/'; then", "        _openssl_syntax=\"yes\"", "    elif curl -V | grep -iq ' BoringSSL/'; then", "        _openssl_syntax=\"yes\"", "    elif curl -V | grep -iq ' GnuTLS/'; then", "        _gnutls_syntax=\"yes\"", "    else", "        _backend_supported=\"no\"", "    fi", "", "    local _args_supported=\"no\"", "    if [ \"$_backend_supported\" = \"yes\" ]; then", "        # \"unspecified\" is for arch, allows for possibility old OS using macports, homebrew, etc.", "        if check_help_for \"notspecified\" \"curl\" \"--tlsv1.2\" \"--ciphers\" \"--proto\"; then", "            _args_supported=\"yes\"", "        fi", "    fi", "", "    local _cs=\"\"", "    if [ \"$_args_supported\" = \"yes\" ]; then", "        if [ \"$_openssl_syntax\" = \"yes\" ]; then", "            _cs=$(get_strong_ciphersuites_for \"openssl\")", "        elif [ \"$_gnutls_syntax\" = \"yes\" ]; then", "            _cs=$(get_strong_ciphersuites_for \"gnutls\")", "        fi", "    fi", "", "    RETVAL=\"$_cs\"", "}", "", "# Return cipher suite string specified by user, otherwise return strong TLS 1.2-1.3 cipher suites", "# if support by local tools is detected. Detection currently supports these wget backends:", "# GnuTLS and OpenSSL (possibly also LibreSSL and BoringSSL). Return value can be empty.", "get_ciphersuites_for_wget() {", "    if [ -n \"${RUSTUP_TLS_CIPHERSUITES-}\" ]; then", "        # user specified custom cipher suites, assume they know what they're doing", "        RETVAL=\"$RUSTUP_TLS_CIPHERSUITES\"", "        return", "    fi", "", "    local _cs=\"\"", "    if wget -V | grep -q '\\-DHAVE_LIBSSL'; then", "        # \"unspecified\" is for arch, allows for possibility old OS using macports, homebrew, etc.", "        if check_help_for \"notspecified\" \"wget\" \"TLSv1_2\" \"--ciphers\" \"--https-only\" \"--secure-protocol\"; then", "            _cs=$(get_strong_ciphersuites_for \"openssl\")", "        fi", "    elif wget -V | grep -q '\\-DHAVE_LIBGNUTLS'; then", "        # \"unspecified\" is for arch, allows for possibility old OS using macports, homebrew, etc.", "        if check_help_for \"notspecified\" \"wget\" \"TLSv1_2\" \"--ciphers\" \"--https-only\" \"--secure-protocol\"; then", "            _cs=$(get_strong_ciphersuites_for \"gnutls\")", "        fi", "    fi", "", "    RETVAL=\"$_cs\"", "}", "", "# Return strong TLS 1.2-1.3 cipher suites in OpenSSL or GnuTLS syntax. TLS 1.2", "# excludes non-ECDHE and non-AEAD cipher suites. DHE is excluded due to bad", "# DH params often found on servers (see RFC 7919). Sequence matches or is", "# similar to Firefox 68 ESR with weak cipher suites disabled via about:config.", "# $1 must be openssl or gnutls.", "get_strong_ciphersuites_for() {", "    if [ \"$1\" = \"openssl\" ]; then", "        # OpenSSL is forgiving of unknown values, no problems with TLS 1.3 values on versions that don't support it yet.", "        echo \"TLS_AES_128_GCM_SHA256:TLS_CHACHA20_POLY1305_SHA256:TLS_AES_256_GCM_SHA384:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384\"", "    elif [ \"$1\" = \"gnutls\" ]; then", "        # GnuTLS isn't forgiving of unknown values, so this may require a GnuTLS version that supports TLS 1.3 even if wget doesn't.", "        # Begin with SECURE128 (and higher) then remove/add to build cipher suites. Produces same 9 cipher suites as OpenSSL but in slightly different order.", "        echo \"SECURE128:-VERS-SSL3.0:-VERS-TLS1.0:-VERS-TLS1.1:-VERS-DTLS-ALL:-CIPHER-ALL:-MAC-ALL:-KX-ALL:+AEAD:+ECDHE-ECDSA:+ECDHE-RSA:+AES-128-GCM:+CHACHA20-POLY1305:+AES-256-GCM\"", "    fi", "}", "", "main \"$@\" || exit 1", "curl: (6) Could not resolve host: |", "curl: (6) Could not resolve host: sh"]}
2022-12-30 00:13:28,893 p=91432 u=kal n=ansible | PLAY RECAP *******************************************************************************************************************************************
2022-12-30 00:13:28,893 p=91432 u=kal n=ansible | krpz                       : ok=1    changed=0    unreachable=0    failed=1    skipped=0    rescued=0    ignored=0   
2022-12-30 00:13:46,971 p=91629 u=kal n=ansible | PLAY [localhost] *************************************************************************************************************************************
2022-12-30 00:13:46,978 p=91629 u=kal n=ansible | TASK [Gathering Facts] *******************************************************************************************************************************
2022-12-30 00:13:50,929 p=91629 u=kal n=ansible | ok: [krpz]
2022-12-30 00:13:50,951 p=91629 u=kal n=ansible | TASK [Install Rust] **********************************************************************************************************************************
2022-12-30 00:13:51,443 p=91629 u=kal n=ansible | fatal: [krpz]: FAILED! => {"changed": true, "cmd": "curl https://sh.rustup.rs | localhost", "delta": "0:00:00.282218", "end": "2022-12-30 00:13:51.394421", "msg": "non-zero return code", "rc": 7, "start": "2022-12-30 00:13:51.112203", "stdout": "#!/bin/sh\r\n# shellcheck shell=dash\r\n\r\n# This is just a little script that can be downloaded from the internet to\r\n# install rustup. It just does platform detection, downloads the installer\r\n# and runs it.\r\n\r\n# It runs on Unix shells like {a,ba,da,k,z}sh. It uses the common `local`\r\n# extension. Note: Most shells limit `local` to 1 var per line, contra bash.\r\n\r\nif [ \"$KSH_VERSION\" = 'Version JM 93t+ 2010-03-05' ]; then\r\n    # The version of ksh93 that ships with many illumos systems does not\r\n    # support the \"local\" extension.  Print a message rather than fail in\r\n    # subtle ways later on:\r\n    echo 'rustup does not work with this ksh93 version; please try bash!' >&2\r\n    exit 1\r\nfi\r\n\r\n\r\nset -u\r\n\r\n# If RUSTUP_UPDATE_ROOT is unset or empty, default it.\r\nRUSTUP_UPDATE_ROOT=\"${RUSTUP_UPDATE_ROOT:-https://static.rust-lang.org/rustup}\"\r\n\r\n#XXX: If you change anything here, please make the same changes in setup_mode.rs\r\nusage() {\r\n    cat 1>&2 <<EOF\r\nrustup-init 1.25.1 (48d233f65 2022-07-12)\r\nThe installer for rustup\r\n\r\nUSAGE:\r\n    rustup-init [FLAGS] [OPTIONS]\r\n\r\nFLAGS:\r\n    -v, --verbose           Enable verbose output\r\n    -q, --quiet             Disable progress output\r\n    -y                      Disable confirmation prompt.\r\n        --no-modify-path    Don't configure the PATH environment variable\r\n    -h, --help              Prints help information\r\n    -V, --version           Prints version information\r\n\r\nOPTIONS:\r\n        --default-host <default-host>              Choose a default host triple\r\n        --default-toolchain <default-toolchain>    Choose a default toolchain to install\r\n        --default-toolchain none                   Do not install any toolchains\r\n        --profile [minimal|default|complete]       Choose a profile\r\n    -c, --component <components>...                Component name to also install\r\n    -t, --target <targets>...                      Target name to also install\r\nEOF\r\n}\r\n\r\nmain() {\r\n    downloader --check\r\n    need_cmd uname\r\n    need_cmd mktemp\r\n    need_cmd chmod\r\n    need_cmd mkdir\r\n    need_cmd rm\r\n    need_cmd rmdir\r\n\r\n    get_architecture || return 1\r\n    local _arch=\"$RETVAL\"\r\n    assert_nz \"$_arch\" \"arch\"\r\n\r\n    local _ext=\"\"\r\n    case \"$_arch\" in\r\n        *windows*)\r\n            _ext=\".exe\"\r\n            ;;\r\n    esac\r\n\r\n    local _url=\"${RUSTUP_UPDATE_ROOT}/dist/${_arch}/rustup-init${_ext}\"\r\n\r\n    local _dir\r\n    _dir=\"$(ensure mktemp -d)\"\r\n    local _file=\"${_dir}/rustup-init${_ext}\"\r\n\r\n    local _ansi_escapes_are_valid=false\r\n    if [ -t 2 ]; then\r\n        if [ \"${TERM+set}\" = 'set' ]; then\r\n            case \"$TERM\" in\r\n                xterm*|rxvt*|urxvt*|linux*|vt*)\r\n                    _ansi_escapes_are_valid=true\r\n                ;;\r\n            esac\r\n        fi\r\n    fi\r\n\r\n    # check if we have to use /dev/tty to prompt the user\r\n    local need_tty=yes\r\n    for arg in \"$@\"; do\r\n        case \"$arg\" in\r\n            --help)\r\n                usage\r\n                exit 0\r\n                ;;\r\n            *)\r\n                OPTIND=1\r\n                if [ \"${arg%%--*}\" = \"\" ]; then\r\n                    # Long option (other than --help);\r\n                    # don't attempt to interpret it.\r\n                    continue\r\n                fi\r\n                while getopts :hy sub_arg \"$arg\"; do\r\n                    case \"$sub_arg\" in\r\n                        h)\r\n                            usage\r\n                            exit 0\r\n                            ;;\r\n                        y)\r\n                            # user wants to skip the prompt --\r\n                            # we don't need /dev/tty\r\n                            need_tty=no\r\n                            ;;\r\n                        *)\r\n                            ;;\r\n                        esac\r\n                done\r\n                ;;\r\n        esac\r\n    done\r\n\r\n    if $_ansi_escapes_are_valid; then\r\n        printf \"\\33[1minfo:\\33[0m downloading installer\\n\" 1>&2\r\n    else\r\n        printf '%s\\n' 'info: downloading installer' 1>&2\r\n    fi\r\n\r\n    ensure mkdir -p \"$_dir\"\r\n    ensure downloader \"$_url\" \"$_file\" \"$_arch\"\r\n    ensure chmod u+x \"$_file\"\r\n    if [ ! -x \"$_file\" ]; then\r\n        printf '%s\\n' \"Cannot execute $_file (likely because of mounting /tmp as noexec).\" 1>&2\r\n        printf '%s\\n' \"Please copy the file to a location where you can execute binaries and run ./rustup-init${_ext}.\" 1>&2\r\n        exit 1\r\n    fi\r\n\r\n    if [ \"$need_tty\" = \"yes\" ] && [ ! -t 0 ]; then\r\n        # The installer is going to want to ask for confirmation by\r\n        # reading stdin.  This script was piped into `sh` though and\r\n        # doesn't have stdin to pass to its children. Instead we're going\r\n        # to explicitly connect /dev/tty to the installer's stdin.\r\n        if [ ! -t 1 ]; then\r\n            err \"Unable to run interactively. Run with -y to accept defaults, --help for additional options\"\r\n        fi\r\n\r\n        ignore \"$_file\" \"$@\" < /dev/tty\r\n    else\r\n        ignore \"$_file\" \"$@\"\r\n    fi\r\n\r\n    local _retval=$?\r\n\r\n    ignore rm \"$_file\"\r\n    ignore rmdir \"$_dir\"\r\n\r\n    return \"$_retval\"\r\n}\r\n\r\ncheck_proc() {\r\n    # Check for /proc by looking for the /proc/self/exe link\r\n    # This is only run on Linux\r\n    if ! test -L /proc/self/exe ; then\r\n        err \"fatal: Unable to find /proc/self/exe.  Is /proc mounted?  Installation cannot proceed without /proc.\"\r\n    fi\r\n}\r\n\r\nget_bitness() {\r\n    need_cmd head\r\n    # Architecture detection without dependencies beyond coreutils.\r\n    # ELF files start out \"\\x7fELF\", and the following byte is\r\n    #   0x01 for 32-bit and\r\n    #   0x02 for 64-bit.\r\n    # The printf builtin on some shells like dash only supports octal\r\n    # escape sequences, so we use those.\r\n    local _current_exe_head\r\n    _current_exe_head=$(head -c 5 /proc/self/exe )\r\n    if [ \"$_current_exe_head\" = \"$(printf '\\177ELF\\001')\" ]; then\r\n        echo 32\r\n    elif [ \"$_current_exe_head\" = \"$(printf '\\177ELF\\002')\" ]; then\r\n        echo 64\r\n    else\r\n        err \"unknown platform bitness\"\r\n    fi\r\n}\r\n\r\nis_host_amd64_elf() {\r\n    need_cmd head\r\n    need_cmd tail\r\n    # ELF e_machine detection without dependencies beyond coreutils.\r\n    # Two-byte field at offset 0x12 indicates the CPU,\r\n    # but we're interested in it being 0x3E to indicate amd64, or not that.\r\n    local _current_exe_machine\r\n    _current_exe_machine=$(head -c 19 /proc/self/exe | tail -c 1)\r\n    [ \"$_current_exe_machine\" = \"$(printf '\\076')\" ]\r\n}\r\n\r\nget_endianness() {\r\n    local cputype=$1\r\n    local suffix_eb=$2\r\n    local suffix_el=$3\r\n\r\n    # detect endianness without od/hexdump, like get_bitness() does.\r\n    need_cmd head\r\n    need_cmd tail\r\n\r\n    local _current_exe_endianness\r\n    _current_exe_endianness=\"$(head -c 6 /proc/self/exe | tail -c 1)\"\r\n    if [ \"$_current_exe_endianness\" = \"$(printf '\\001')\" ]; then\r\n        echo \"${cputype}${suffix_el}\"\r\n    elif [ \"$_current_exe_endianness\" = \"$(printf '\\002')\" ]; then\r\n        echo \"${cputype}${suffix_eb}\"\r\n    else\r\n        err \"unknown platform endianness\"\r\n    fi\r\n}\r\n\r\nget_architecture() {\r\n    local _ostype _cputype _bitness _arch _clibtype\r\n    _ostype=\"$(uname -s)\"\r\n    _cputype=\"$(uname -m)\"\r\n    _clibtype=\"gnu\"\r\n\r\n    if [ \"$_ostype\" = Linux ]; then\r\n        if [ \"$(uname -o)\" = Android ]; then\r\n            _ostype=Android\r\n        fi\r\n        if ldd --version 2>&1 | grep -q 'musl'; then\r\n            _clibtype=\"musl\"\r\n        fi\r\n    fi\r\n\r\n    if [ \"$_ostype\" = Darwin ] && [ \"$_cputype\" = i386 ]; then\r\n        # Darwin `uname -m` lies\r\n        if sysctl hw.optional.x86_64 | grep -q ': 1'; then\r\n            _cputype=x86_64\r\n        fi\r\n    fi\r\n\r\n    if [ \"$_ostype\" = SunOS ]; then\r\n        # Both Solaris and illumos presently announce as \"SunOS\" in \"uname -s\"\r\n        # so use \"uname -o\" to disambiguate.  We use the full path to the\r\n        # system uname in case the user has coreutils uname first in PATH,\r\n        # which has historically sometimes printed the wrong value here.\r\n        if [ \"$(/usr/bin/uname -o)\" = illumos ]; then\r\n            _ostype=illumos\r\n        fi\r\n\r\n        # illumos systems have multi-arch userlands, and \"uname -m\" reports the\r\n        # machine hardware name; e.g., \"i86pc\" on both 32- and 64-bit x86\r\n        # systems.  Check for the native (widest) instruction set on the\r\n        # running kernel:\r\n        if [ \"$_cputype\" = i86pc ]; then\r\n            _cputype=\"$(isainfo -n)\"\r\n        fi\r\n    fi\r\n\r\n    case \"$_ostype\" in\r\n\r\n        Android)\r\n            _ostype=linux-android\r\n            ;;\r\n\r\n        Linux)\r\n            check_proc\r\n            _ostype=unknown-linux-$_clibtype\r\n            _bitness=$(get_bitness)\r\n            ;;\r\n\r\n        FreeBSD)\r\n            _ostype=unknown-freebsd\r\n            ;;\r\n\r\n        NetBSD)\r\n            _ostype=unknown-netbsd\r\n            ;;\r\n\r\n        DragonFly)\r\n            _ostype=unknown-dragonfly\r\n            ;;\r\n\r\n        Darwin)\r\n            _ostype=apple-darwin\r\n            ;;\r\n\r\n        illumos)\r\n            _ostype=unknown-illumos\r\n            ;;\r\n\r\n        MINGW* | MSYS* | CYGWIN* | Windows_NT)\r\n            _ostype=pc-windows-gnu\r\n            ;;\r\n\r\n        *)\r\n            err \"unrecognized OS type: $_ostype\"\r\n            ;;\r\n\r\n    esac\r\n\r\n    case \"$_cputype\" in\r\n\r\n        i386 | i486 | i686 | i786 | x86)\r\n            _cputype=i686\r\n            ;;\r\n\r\n        xscale | arm)\r\n            _cputype=arm\r\n            if [ \"$_ostype\" = \"linux-android\" ]; then\r\n                _ostype=linux-androideabi\r\n            fi\r\n            ;;\r\n\r\n        armv6l)\r\n            _cputype=arm\r\n            if [ \"$_ostype\" = \"linux-android\" ]; then\r\n                _ostype=linux-androideabi\r\n            else\r\n                _ostype=\"${_ostype}eabihf\"\r\n            fi\r\n            ;;\r\n\r\n        armv7l | armv8l)\r\n            _cputype=armv7\r\n            if [ \"$_ostype\" = \"linux-android\" ]; then\r\n                _ostype=linux-androideabi\r\n            else\r\n                _ostype=\"${_ostype}eabihf\"\r\n            fi\r\n            ;;\r\n\r\n        aarch64 | arm64)\r\n            _cputype=aarch64\r\n            ;;\r\n\r\n        x86_64 | x86-64 | x64 | amd64)\r\n            _cputype=x86_64\r\n            ;;\r\n\r\n        mips)\r\n            _cputype=$(get_endianness mips '' el)\r\n            ;;\r\n\r\n        mips64)\r\n            if [ \"$_bitness\" -eq 64 ]; then\r\n                # only n64 ABI is supported for now\r\n                _ostype=\"${_ostype}abi64\"\r\n                _cputype=$(get_endianness mips64 '' el)\r\n            fi\r\n            ;;\r\n\r\n        ppc)\r\n            _cputype=powerpc\r\n            ;;\r\n\r\n        ppc64)\r\n            _cputype=powerpc64\r\n            ;;\r\n\r\n        ppc64le)\r\n            _cputype=powerpc64le\r\n            ;;\r\n\r\n        s390x)\r\n            _cputype=s390x\r\n            ;;\r\n        riscv64)\r\n            _cputype=riscv64gc\r\n            ;;\r\n        *)\r\n            err \"unknown CPU type: $_cputype\"\r\n\r\n    esac\r\n\r\n    # Detect 64-bit linux with 32-bit userland\r\n    if [ \"${_ostype}\" = unknown-linux-gnu ] && [ \"${_bitness}\" -eq 32 ]; then\r\n        case $_cputype in\r\n            x86_64)\r\n                if [ -n \"${RUSTUP_CPUTYPE:-}\" ]; then\r\n                    _cputype=\"$RUSTUP_CPUTYPE\"\r\n                else {\r\n                    # 32-bit executable for amd64 = x32\r\n                    if is_host_amd64_elf; then {\r\n                         echo \"This host is running an x32 userland; as it stands, x32 support is poor,\" 1>&2\r\n                         echo \"and there isn't a native toolchain -- you will have to install\" 1>&2\r\n                         echo \"multiarch compatibility with i686 and/or amd64, then select one\" 1>&2\r\n                         echo \"by re-running this script with the RUSTUP_CPUTYPE environment variable\" 1>&2\r\n                         echo \"set to i686 or x86_64, respectively.\" 1>&2\r\n                         echo 1>&2\r\n                         echo \"You will be able to add an x32 target after installation by running\" 1>&2\r\n                         echo \"  rustup target add x86_64-unknown-linux-gnux32\" 1>&2\r\n                         exit 1\r\n                    }; else\r\n                        _cputype=i686\r\n                    fi\r\n                }; fi\r\n                ;;\r\n            mips64)\r\n                _cputype=$(get_endianness mips '' el)\r\n                ;;\r\n            powerpc64)\r\n                _cputype=powerpc\r\n                ;;\r\n            aarch64)\r\n                _cputype=armv7\r\n                if [ \"$_ostype\" = \"linux-android\" ]; then\r\n                    _ostype=linux-androideabi\r\n                else\r\n                    _ostype=\"${_ostype}eabihf\"\r\n                fi\r\n                ;;\r\n            riscv64gc)\r\n                err \"riscv64 with 32-bit userland unsupported\"\r\n                ;;\r\n        esac\r\n    fi\r\n\r\n    # Detect armv7 but without the CPU features Rust needs in that build,\r\n    # and fall back to arm.\r\n    # See https://github.com/rust-lang/rustup.rs/issues/587.\r\n    if [ \"$_ostype\" = \"unknown-linux-gnueabihf\" ] && [ \"$_cputype\" = armv7 ]; then\r\n        if ensure grep '^Features' /proc/cpuinfo | grep -q -v neon; then\r\n            # At least one processor does not have NEON.\r\n            _cputype=arm\r\n        fi\r\n    fi\r\n\r\n    _arch=\"${_cputype}-${_ostype}\"\r\n\r\n    RETVAL=\"$_arch\"\r\n}\r\n\r\nsay() {\r\n    printf 'rustup: %s\\n' \"$1\"\r\n}\r\n\r\nerr() {\r\n    say \"$1\" >&2\r\n    exit 1\r\n}\r\n\r\nneed_cmd() {\r\n    if ! check_cmd \"$1\"; then\r\n        err \"need '$1' (command not found)\"\r\n    fi\r\n}\r\n\r\ncheck_cmd() {\r\n    command -v \"$1\" > /dev/null 2>&1\r\n}\r\n\r\nassert_nz() {\r\n    if [ -z \"$1\" ]; then err \"assert_nz $2\"; fi\r\n}\r\n\r\n# Run a command that should never fail. If the command fails execution\r\n# will immediately terminate with an error showing the failing\r\n# command.\r\nensure() {\r\n    if ! \"$@\"; then err \"command failed: $*\"; fi\r\n}\r\n\r\n# This is just for indicating that commands' results are being\r\n# intentionally ignored. Usually, because it's being executed\r\n# as part of error handling.\r\nignore() {\r\n    \"$@\"\r\n}\r\n\r\n# This wraps curl or wget. Try curl first, if not installed,\r\n# use wget instead.\r\ndownloader() {\r\n    local _dld\r\n    local _ciphersuites\r\n    local _err\r\n    local _status\r\n    local _retry\r\n    if check_cmd curl; then\r\n        _dld=curl\r\n    elif check_cmd wget; then\r\n        _dld=wget\r\n    else\r\n        _dld='curl or wget' # to be used in error message of need_cmd\r\n    fi\r\n\r\n    if [ \"$1\" = --check ]; then\r\n        need_cmd \"$_dld\"\r\n    elif [ \"$_dld\" = curl ]; then\r\n        check_curl_for_retry_support\r\n        _retry=\"$RETVAL\"\r\n        get_ciphersuites_for_curl\r\n        _ciphersuites=\"$RETVAL\"\r\n        if [ -n \"$_ciphersuites\" ]; then\r\n            _err=$(curl $_retry --proto '=https' --tlsv1.2 --ciphers \"$_ciphersuites\" --silent --show-error --fail --location \"$1\" --output \"$2\" 2>&1)\r\n            _status=$?\r\n        else\r\n            echo \"Warning: Not enforcing strong cipher suites for TLS, this is potentially less secure\"\r\n            if ! check_help_for \"$3\" curl --proto --tlsv1.2; then\r\n                echo \"Warning: Not enforcing TLS v1.2, this is potentially less secure\"\r\n                _err=$(curl $_retry --silent --show-error --fail --location \"$1\" --output \"$2\" 2>&1)\r\n                _status=$?\r\n            else\r\n                _err=$(curl $_retry --proto '=https' --tlsv1.2 --silent --show-error --fail --location \"$1\" --output \"$2\" 2>&1)\r\n                _status=$?\r\n            fi\r\n        fi\r\n        if [ -n \"$_err\" ]; then\r\n            echo \"$_err\" >&2\r\n            if echo \"$_err\" | grep -q 404$; then\r\n                err \"installer for platform '$3' not found, this may be unsupported\"\r\n            fi\r\n        fi\r\n        return $_status\r\n    elif [ \"$_dld\" = wget ]; then\r\n        if [ \"$(wget -V 2>&1|head -2|tail -1|cut -f1 -d\" \")\" = \"BusyBox\" ]; then\r\n            echo \"Warning: using the BusyBox version of wget.  Not enforcing strong cipher suites for TLS or TLS v1.2, this is potentially less secure\"\r\n            _err=$(wget \"$1\" -O \"$2\" 2>&1)\r\n            _status=$?\r\n        else\r\n            get_ciphersuites_for_wget\r\n            _ciphersuites=\"$RETVAL\"\r\n            if [ -n \"$_ciphersuites\" ]; then\r\n                _err=$(wget --https-only --secure-protocol=TLSv1_2 --ciphers \"$_ciphersuites\" \"$1\" -O \"$2\" 2>&1)\r\n                _status=$?\r\n            else\r\n                echo \"Warning: Not enforcing strong cipher suites for TLS, this is potentially less secure\"\r\n                if ! check_help_for \"$3\" wget --https-only --secure-protocol; then\r\n                    echo \"Warning: Not enforcing TLS v1.2, this is potentially less secure\"\r\n                    _err=$(wget \"$1\" -O \"$2\" 2>&1)\r\n                    _status=$?\r\n                else\r\n                    _err=$(wget --https-only --secure-protocol=TLSv1_2 \"$1\" -O \"$2\" 2>&1)\r\n                    _status=$?\r\n                fi\r\n            fi\r\n        fi\r\n        if [ -n \"$_err\" ]; then\r\n            echo \"$_err\" >&2\r\n            if echo \"$_err\" | grep -q ' 404 Not Found$'; then\r\n                err \"installer for platform '$3' not found, this may be unsupported\"\r\n            fi\r\n        fi\r\n        return $_status\r\n    else\r\n        err \"Unknown downloader\"   # should not reach here\r\n    fi\r\n}\r\n\r\ncheck_help_for() {\r\n    local _arch\r\n    local _cmd\r\n    local _arg\r\n    _arch=\"$1\"\r\n    shift\r\n    _cmd=\"$1\"\r\n    shift\r\n\r\n    local _category\r\n    if \"$_cmd\" --help | grep -q 'For all options use the manual or \"--help all\".'; then\r\n      _category=\"all\"\r\n    else\r\n      _category=\"\"\r\n    fi\r\n\r\n    case \"$_arch\" in\r\n\r\n        *darwin*)\r\n        if check_cmd sw_vers; then\r\n            case $(sw_vers -productVersion) in\r\n                10.*)\r\n                    # If we're running on macOS, older than 10.13, then we always\r\n                    # fail to find these options to force fallback\r\n                    if [ \"$(sw_vers -productVersion | cut -d. -f2)\" -lt 13 ]; then\r\n                        # Older than 10.13\r\n                        echo \"Warning: Detected macOS platform older than 10.13\"\r\n                        return 1\r\n                    fi\r\n                    ;;\r\n                11.*)\r\n                    # We assume Big Sur will be OK for now\r\n                    ;;\r\n                *)\r\n                    # Unknown product version, warn and continue\r\n                    echo \"Warning: Detected unknown macOS major version: $(sw_vers -productVersion)\"\r\n                    echo \"Warning TLS capabilities detection may fail\"\r\n                    ;;\r\n            esac\r\n        fi\r\n        ;;\r\n\r\n    esac\r\n\r\n    for _arg in \"$@\"; do\r\n        if ! \"$_cmd\" --help $_category | grep -q -- \"$_arg\"; then\r\n            return 1\r\n        fi\r\n    done\r\n\r\n    true # not strictly needed\r\n}\r\n\r\n# Check if curl supports the --retry flag, then pass it to the curl invocation.\r\ncheck_curl_for_retry_support() {\r\n  local _retry_supported=\"\"\r\n  # \"unspecified\" is for arch, allows for possibility old OS using macports, homebrew, etc.\r\n  if check_help_for \"notspecified\" \"curl\" \"--retry\"; then\r\n    _retry_supported=\"--retry 3\"\r\n  fi\r\n\r\n  RETVAL=\"$_retry_supported\"\r\n\r\n}\r\n\r\n# Return cipher suite string specified by user, otherwise return strong TLS 1.2-1.3 cipher suites\r\n# if support by local tools is detected. Detection currently supports these curl backends:\r\n# GnuTLS and OpenSSL (possibly also LibreSSL and BoringSSL). Return value can be empty.\r\nget_ciphersuites_for_curl() {\r\n    if [ -n \"${RUSTUP_TLS_CIPHERSUITES-}\" ]; then\r\n        # user specified custom cipher suites, assume they know what they're doing\r\n        RETVAL=\"$RUSTUP_TLS_CIPHERSUITES\"\r\n        return\r\n    fi\r\n\r\n    local _openssl_syntax=\"no\"\r\n    local _gnutls_syntax=\"no\"\r\n    local _backend_supported=\"yes\"\r\n    if curl -V | grep -q ' OpenSSL/'; then\r\n        _openssl_syntax=\"yes\"\r\n    elif curl -V | grep -iq ' LibreSSL/'; then\r\n        _openssl_syntax=\"yes\"\r\n    elif curl -V | grep -iq ' BoringSSL/'; then\r\n        _openssl_syntax=\"yes\"\r\n    elif curl -V | grep -iq ' GnuTLS/'; then\r\n        _gnutls_syntax=\"yes\"\r\n    else\r\n        _backend_supported=\"no\"\r\n    fi\r\n\r\n    local _args_supported=\"no\"\r\n    if [ \"$_backend_supported\" = \"yes\" ]; then\r\n        # \"unspecified\" is for arch, allows for possibility old OS using macports, homebrew, etc.\r\n        if check_help_for \"notspecified\" \"curl\" \"--tlsv1.2\" \"--ciphers\" \"--proto\"; then\r\n            _args_supported=\"yes\"\r\n        fi\r\n    fi\r\n\r\n    local _cs=\"\"\r\n    if [ \"$_args_supported\" = \"yes\" ]; then\r\n        if [ \"$_openssl_syntax\" = \"yes\" ]; then\r\n            _cs=$(get_strong_ciphersuites_for \"openssl\")\r\n        elif [ \"$_gnutls_syntax\" = \"yes\" ]; then\r\n            _cs=$(get_strong_ciphersuites_for \"gnutls\")\r\n        fi\r\n    fi\r\n\r\n    RETVAL=\"$_cs\"\r\n}\r\n\r\n# Return cipher suite string specified by user, otherwise return strong TLS 1.2-1.3 cipher suites\r\n# if support by local tools is detected. Detection currently supports these wget backends:\r\n# GnuTLS and OpenSSL (possibly also LibreSSL and BoringSSL). Return value can be empty.\r\nget_ciphersuites_for_wget() {\r\n    if [ -n \"${RUSTUP_TLS_CIPHERSUITES-}\" ]; then\r\n        # user specified custom cipher suites, assume they know what they're doing\r\n        RETVAL=\"$RUSTUP_TLS_CIPHERSUITES\"\r\n        return\r\n    fi\r\n\r\n    local _cs=\"\"\r\n    if wget -V | grep -q '\\-DHAVE_LIBSSL'; then\r\n        # \"unspecified\" is for arch, allows for possibility old OS using macports, homebrew, etc.\r\n        if check_help_for \"notspecified\" \"wget\" \"TLSv1_2\" \"--ciphers\" \"--https-only\" \"--secure-protocol\"; then\r\n            _cs=$(get_strong_ciphersuites_for \"openssl\")\r\n        fi\r\n    elif wget -V | grep -q '\\-DHAVE_LIBGNUTLS'; then\r\n        # \"unspecified\" is for arch, allows for possibility old OS using macports, homebrew, etc.\r\n        if check_help_for \"notspecified\" \"wget\" \"TLSv1_2\" \"--ciphers\" \"--https-only\" \"--secure-protocol\"; then\r\n            _cs=$(get_strong_ciphersuites_for \"gnutls\")\r\n        fi\r\n    fi\r\n\r\n    RETVAL=\"$_cs\"\r\n}\r\n\r\n# Return strong TLS 1.2-1.3 cipher suites in OpenSSL or GnuTLS syntax. TLS 1.2\r\n# excludes non-ECDHE and non-AEAD cipher suites. DHE is excluded due to bad\r\n# DH params often found on servers (see RFC 7919). Sequence matches or is\r\n# similar to Firefox 68 ESR with weak cipher suites disabled via about:config.\r\n# $1 must be openssl or gnutls.\r\nget_strong_ciphersuites_for() {\r\n    if [ \"$1\" = \"openssl\" ]; then\r\n        # OpenSSL is forgiving of unknown values, no problems with TLS 1.3 values on versions that don't support it yet.\r\n        echo \"TLS_AES_128_GCM_SHA256:TLS_CHACHA20_POLY1305_SHA256:TLS_AES_256_GCM_SHA384:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384\"\r\n    elif [ \"$1\" = \"gnutls\" ]; then\r\n        # GnuTLS isn't forgiving of unknown values, so this may require a GnuTLS version that supports TLS 1.3 even if wget doesn't.\r\n        # Begin with SECURE128 (and higher) then remove/add to build cipher suites. Produces same 9 cipher suites as OpenSSL but in slightly different order.\r\n        echo \"SECURE128:-VERS-SSL3.0:-VERS-TLS1.0:-VERS-TLS1.1:-VERS-DTLS-ALL:-CIPHER-ALL:-MAC-ALL:-KX-ALL:+AEAD:+ECDHE-ECDSA:+ECDHE-RSA:+AES-128-GCM:+CHACHA20-POLY1305:+AES-256-GCM\"\r\n    fi\r\n}\r\n\r\nmain \"$@\" || exit 1\r\ncurl: (6) Could not resolve host: |\r\ncurl: (7) Failed to connect to localhost port 80 after 0 ms: Connection refused", "stdout_lines": ["#!/bin/sh", "# shellcheck shell=dash", "", "# This is just a little script that can be downloaded from the internet to", "# install rustup. It just does platform detection, downloads the installer", "# and runs it.", "", "# It runs on Unix shells like {a,ba,da,k,z}sh. It uses the common `local`", "# extension. Note: Most shells limit `local` to 1 var per line, contra bash.", "", "if [ \"$KSH_VERSION\" = 'Version JM 93t+ 2010-03-05' ]; then", "    # The version of ksh93 that ships with many illumos systems does not", "    # support the \"local\" extension.  Print a message rather than fail in", "    # subtle ways later on:", "    echo 'rustup does not work with this ksh93 version; please try bash!' >&2", "    exit 1", "fi", "", "", "set -u", "", "# If RUSTUP_UPDATE_ROOT is unset or empty, default it.", "RUSTUP_UPDATE_ROOT=\"${RUSTUP_UPDATE_ROOT:-https://static.rust-lang.org/rustup}\"", "", "#XXX: If you change anything here, please make the same changes in setup_mode.rs", "usage() {", "    cat 1>&2 <<EOF", "rustup-init 1.25.1 (48d233f65 2022-07-12)", "The installer for rustup", "", "USAGE:", "    rustup-init [FLAGS] [OPTIONS]", "", "FLAGS:", "    -v, --verbose           Enable verbose output", "    -q, --quiet             Disable progress output", "    -y                      Disable confirmation prompt.", "        --no-modify-path    Don't configure the PATH environment variable", "    -h, --help              Prints help information", "    -V, --version           Prints version information", "", "OPTIONS:", "        --default-host <default-host>              Choose a default host triple", "        --default-toolchain <default-toolchain>    Choose a default toolchain to install", "        --default-toolchain none                   Do not install any toolchains", "        --profile [minimal|default|complete]       Choose a profile", "    -c, --component <components>...                Component name to also install", "    -t, --target <targets>...                      Target name to also install", "EOF", "}", "", "main() {", "    downloader --check", "    need_cmd uname", "    need_cmd mktemp", "    need_cmd chmod", "    need_cmd mkdir", "    need_cmd rm", "    need_cmd rmdir", "", "    get_architecture || return 1", "    local _arch=\"$RETVAL\"", "    assert_nz \"$_arch\" \"arch\"", "", "    local _ext=\"\"", "    case \"$_arch\" in", "        *windows*)", "            _ext=\".exe\"", "            ;;", "    esac", "", "    local _url=\"${RUSTUP_UPDATE_ROOT}/dist/${_arch}/rustup-init${_ext}\"", "", "    local _dir", "    _dir=\"$(ensure mktemp -d)\"", "    local _file=\"${_dir}/rustup-init${_ext}\"", "", "    local _ansi_escapes_are_valid=false", "    if [ -t 2 ]; then", "        if [ \"${TERM+set}\" = 'set' ]; then", "            case \"$TERM\" in", "                xterm*|rxvt*|urxvt*|linux*|vt*)", "                    _ansi_escapes_are_valid=true", "                ;;", "            esac", "        fi", "    fi", "", "    # check if we have to use /dev/tty to prompt the user", "    local need_tty=yes", "    for arg in \"$@\"; do", "        case \"$arg\" in", "            --help)", "                usage", "                exit 0", "                ;;", "            *)", "                OPTIND=1", "                if [ \"${arg%%--*}\" = \"\" ]; then", "                    # Long option (other than --help);", "                    # don't attempt to interpret it.", "                    continue", "                fi", "                while getopts :hy sub_arg \"$arg\"; do", "                    case \"$sub_arg\" in", "                        h)", "                            usage", "                            exit 0", "                            ;;", "                        y)", "                            # user wants to skip the prompt --", "                            # we don't need /dev/tty", "                            need_tty=no", "                            ;;", "                        *)", "                            ;;", "                        esac", "                done", "                ;;", "        esac", "    done", "", "    if $_ansi_escapes_are_valid; then", "        printf \"\\33[1minfo:\\33[0m downloading installer\\n\" 1>&2", "    else", "        printf '%s\\n' 'info: downloading installer' 1>&2", "    fi", "", "    ensure mkdir -p \"$_dir\"", "    ensure downloader \"$_url\" \"$_file\" \"$_arch\"", "    ensure chmod u+x \"$_file\"", "    if [ ! -x \"$_file\" ]; then", "        printf '%s\\n' \"Cannot execute $_file (likely because of mounting /tmp as noexec).\" 1>&2", "        printf '%s\\n' \"Please copy the file to a location where you can execute binaries and run ./rustup-init${_ext}.\" 1>&2", "        exit 1", "    fi", "", "    if [ \"$need_tty\" = \"yes\" ] && [ ! -t 0 ]; then", "        # The installer is going to want to ask for confirmation by", "        # reading stdin.  This script was piped into `sh` though and", "        # doesn't have stdin to pass to its children. Instead we're going", "        # to explicitly connect /dev/tty to the installer's stdin.", "        if [ ! -t 1 ]; then", "            err \"Unable to run interactively. Run with -y to accept defaults, --help for additional options\"", "        fi", "", "        ignore \"$_file\" \"$@\" < /dev/tty", "    else", "        ignore \"$_file\" \"$@\"", "    fi", "", "    local _retval=$?", "", "    ignore rm \"$_file\"", "    ignore rmdir \"$_dir\"", "", "    return \"$_retval\"", "}", "", "check_proc() {", "    # Check for /proc by looking for the /proc/self/exe link", "    # This is only run on Linux", "    if ! test -L /proc/self/exe ; then", "        err \"fatal: Unable to find /proc/self/exe.  Is /proc mounted?  Installation cannot proceed without /proc.\"", "    fi", "}", "", "get_bitness() {", "    need_cmd head", "    # Architecture detection without dependencies beyond coreutils.", "    # ELF files start out \"\\x7fELF\", and the following byte is", "    #   0x01 for 32-bit and", "    #   0x02 for 64-bit.", "    # The printf builtin on some shells like dash only supports octal", "    # escape sequences, so we use those.", "    local _current_exe_head", "    _current_exe_head=$(head -c 5 /proc/self/exe )", "    if [ \"$_current_exe_head\" = \"$(printf '\\177ELF\\001')\" ]; then", "        echo 32", "    elif [ \"$_current_exe_head\" = \"$(printf '\\177ELF\\002')\" ]; then", "        echo 64", "    else", "        err \"unknown platform bitness\"", "    fi", "}", "", "is_host_amd64_elf() {", "    need_cmd head", "    need_cmd tail", "    # ELF e_machine detection without dependencies beyond coreutils.", "    # Two-byte field at offset 0x12 indicates the CPU,", "    # but we're interested in it being 0x3E to indicate amd64, or not that.", "    local _current_exe_machine", "    _current_exe_machine=$(head -c 19 /proc/self/exe | tail -c 1)", "    [ \"$_current_exe_machine\" = \"$(printf '\\076')\" ]", "}", "", "get_endianness() {", "    local cputype=$1", "    local suffix_eb=$2", "    local suffix_el=$3", "", "    # detect endianness without od/hexdump, like get_bitness() does.", "    need_cmd head", "    need_cmd tail", "", "    local _current_exe_endianness", "    _current_exe_endianness=\"$(head -c 6 /proc/self/exe | tail -c 1)\"", "    if [ \"$_current_exe_endianness\" = \"$(printf '\\001')\" ]; then", "        echo \"${cputype}${suffix_el}\"", "    elif [ \"$_current_exe_endianness\" = \"$(printf '\\002')\" ]; then", "        echo \"${cputype}${suffix_eb}\"", "    else", "        err \"unknown platform endianness\"", "    fi", "}", "", "get_architecture() {", "    local _ostype _cputype _bitness _arch _clibtype", "    _ostype=\"$(uname -s)\"", "    _cputype=\"$(uname -m)\"", "    _clibtype=\"gnu\"", "", "    if [ \"$_ostype\" = Linux ]; then", "        if [ \"$(uname -o)\" = Android ]; then", "            _ostype=Android", "        fi", "        if ldd --version 2>&1 | grep -q 'musl'; then", "            _clibtype=\"musl\"", "        fi", "    fi", "", "    if [ \"$_ostype\" = Darwin ] && [ \"$_cputype\" = i386 ]; then", "        # Darwin `uname -m` lies", "        if sysctl hw.optional.x86_64 | grep -q ': 1'; then", "            _cputype=x86_64", "        fi", "    fi", "", "    if [ \"$_ostype\" = SunOS ]; then", "        # Both Solaris and illumos presently announce as \"SunOS\" in \"uname -s\"", "        # so use \"uname -o\" to disambiguate.  We use the full path to the", "        # system uname in case the user has coreutils uname first in PATH,", "        # which has historically sometimes printed the wrong value here.", "        if [ \"$(/usr/bin/uname -o)\" = illumos ]; then", "            _ostype=illumos", "        fi", "", "        # illumos systems have multi-arch userlands, and \"uname -m\" reports the", "        # machine hardware name; e.g., \"i86pc\" on both 32- and 64-bit x86", "        # systems.  Check for the native (widest) instruction set on the", "        # running kernel:", "        if [ \"$_cputype\" = i86pc ]; then", "            _cputype=\"$(isainfo -n)\"", "        fi", "    fi", "", "    case \"$_ostype\" in", "", "        Android)", "            _ostype=linux-android", "            ;;", "", "        Linux)", "            check_proc", "            _ostype=unknown-linux-$_clibtype", "            _bitness=$(get_bitness)", "            ;;", "", "        FreeBSD)", "            _ostype=unknown-freebsd", "            ;;", "", "        NetBSD)", "            _ostype=unknown-netbsd", "            ;;", "", "        DragonFly)", "            _ostype=unknown-dragonfly", "            ;;", "", "        Darwin)", "            _ostype=apple-darwin", "            ;;", "", "        illumos)", "            _ostype=unknown-illumos", "            ;;", "", "        MINGW* | MSYS* | CYGWIN* | Windows_NT)", "            _ostype=pc-windows-gnu", "            ;;", "", "        *)", "            err \"unrecognized OS type: $_ostype\"", "            ;;", "", "    esac", "", "    case \"$_cputype\" in", "", "        i386 | i486 | i686 | i786 | x86)", "            _cputype=i686", "            ;;", "", "        xscale | arm)", "            _cputype=arm", "            if [ \"$_ostype\" = \"linux-android\" ]; then", "                _ostype=linux-androideabi", "            fi", "            ;;", "", "        armv6l)", "            _cputype=arm", "            if [ \"$_ostype\" = \"linux-android\" ]; then", "                _ostype=linux-androideabi", "            else", "                _ostype=\"${_ostype}eabihf\"", "            fi", "            ;;", "", "        armv7l | armv8l)", "            _cputype=armv7", "            if [ \"$_ostype\" = \"linux-android\" ]; then", "                _ostype=linux-androideabi", "            else", "                _ostype=\"${_ostype}eabihf\"", "            fi", "            ;;", "", "        aarch64 | arm64)", "            _cputype=aarch64", "            ;;", "", "        x86_64 | x86-64 | x64 | amd64)", "            _cputype=x86_64", "            ;;", "", "        mips)", "            _cputype=$(get_endianness mips '' el)", "            ;;", "", "        mips64)", "            if [ \"$_bitness\" -eq 64 ]; then", "                # only n64 ABI is supported for now", "                _ostype=\"${_ostype}abi64\"", "                _cputype=$(get_endianness mips64 '' el)", "            fi", "            ;;", "", "        ppc)", "            _cputype=powerpc", "            ;;", "", "        ppc64)", "            _cputype=powerpc64", "            ;;", "", "        ppc64le)", "            _cputype=powerpc64le", "            ;;", "", "        s390x)", "            _cputype=s390x", "            ;;", "        riscv64)", "            _cputype=riscv64gc", "            ;;", "        *)", "            err \"unknown CPU type: $_cputype\"", "", "    esac", "", "    # Detect 64-bit linux with 32-bit userland", "    if [ \"${_ostype}\" = unknown-linux-gnu ] && [ \"${_bitness}\" -eq 32 ]; then", "        case $_cputype in", "            x86_64)", "                if [ -n \"${RUSTUP_CPUTYPE:-}\" ]; then", "                    _cputype=\"$RUSTUP_CPUTYPE\"", "                else {", "                    # 32-bit executable for amd64 = x32", "                    if is_host_amd64_elf; then {", "                         echo \"This host is running an x32 userland; as it stands, x32 support is poor,\" 1>&2", "                         echo \"and there isn't a native toolchain -- you will have to install\" 1>&2", "                         echo \"multiarch compatibility with i686 and/or amd64, then select one\" 1>&2", "                         echo \"by re-running this script with the RUSTUP_CPUTYPE environment variable\" 1>&2", "                         echo \"set to i686 or x86_64, respectively.\" 1>&2", "                         echo 1>&2", "                         echo \"You will be able to add an x32 target after installation by running\" 1>&2", "                         echo \"  rustup target add x86_64-unknown-linux-gnux32\" 1>&2", "                         exit 1", "                    }; else", "                        _cputype=i686", "                    fi", "                }; fi", "                ;;", "            mips64)", "                _cputype=$(get_endianness mips '' el)", "                ;;", "            powerpc64)", "                _cputype=powerpc", "                ;;", "            aarch64)", "                _cputype=armv7", "                if [ \"$_ostype\" = \"linux-android\" ]; then", "                    _ostype=linux-androideabi", "                else", "                    _ostype=\"${_ostype}eabihf\"", "                fi", "                ;;", "            riscv64gc)", "                err \"riscv64 with 32-bit userland unsupported\"", "                ;;", "        esac", "    fi", "", "    # Detect armv7 but without the CPU features Rust needs in that build,", "    # and fall back to arm.", "    # See https://github.com/rust-lang/rustup.rs/issues/587.", "    if [ \"$_ostype\" = \"unknown-linux-gnueabihf\" ] && [ \"$_cputype\" = armv7 ]; then", "        if ensure grep '^Features' /proc/cpuinfo | grep -q -v neon; then", "            # At least one processor does not have NEON.", "            _cputype=arm", "        fi", "    fi", "", "    _arch=\"${_cputype}-${_ostype}\"", "", "    RETVAL=\"$_arch\"", "}", "", "say() {", "    printf 'rustup: %s\\n' \"$1\"", "}", "", "err() {", "    say \"$1\" >&2", "    exit 1", "}", "", "need_cmd() {", "    if ! check_cmd \"$1\"; then", "        err \"need '$1' (command not found)\"", "    fi", "}", "", "check_cmd() {", "    command -v \"$1\" > /dev/null 2>&1", "}", "", "assert_nz() {", "    if [ -z \"$1\" ]; then err \"assert_nz $2\"; fi", "}", "", "# Run a command that should never fail. If the command fails execution", "# will immediately terminate with an error showing the failing", "# command.", "ensure() {", "    if ! \"$@\"; then err \"command failed: $*\"; fi", "}", "", "# This is just for indicating that commands' results are being", "# intentionally ignored. Usually, because it's being executed", "# as part of error handling.", "ignore() {", "    \"$@\"", "}", "", "# This wraps curl or wget. Try curl first, if not installed,", "# use wget instead.", "downloader() {", "    local _dld", "    local _ciphersuites", "    local _err", "    local _status", "    local _retry", "    if check_cmd curl; then", "        _dld=curl", "    elif check_cmd wget; then", "        _dld=wget", "    else", "        _dld='curl or wget' # to be used in error message of need_cmd", "    fi", "", "    if [ \"$1\" = --check ]; then", "        need_cmd \"$_dld\"", "    elif [ \"$_dld\" = curl ]; then", "        check_curl_for_retry_support", "        _retry=\"$RETVAL\"", "        get_ciphersuites_for_curl", "        _ciphersuites=\"$RETVAL\"", "        if [ -n \"$_ciphersuites\" ]; then", "            _err=$(curl $_retry --proto '=https' --tlsv1.2 --ciphers \"$_ciphersuites\" --silent --show-error --fail --location \"$1\" --output \"$2\" 2>&1)", "            _status=$?", "        else", "            echo \"Warning: Not enforcing strong cipher suites for TLS, this is potentially less secure\"", "            if ! check_help_for \"$3\" curl --proto --tlsv1.2; then", "                echo \"Warning: Not enforcing TLS v1.2, this is potentially less secure\"", "                _err=$(curl $_retry --silent --show-error --fail --location \"$1\" --output \"$2\" 2>&1)", "                _status=$?", "            else", "                _err=$(curl $_retry --proto '=https' --tlsv1.2 --silent --show-error --fail --location \"$1\" --output \"$2\" 2>&1)", "                _status=$?", "            fi", "        fi", "        if [ -n \"$_err\" ]; then", "            echo \"$_err\" >&2", "            if echo \"$_err\" | grep -q 404$; then", "                err \"installer for platform '$3' not found, this may be unsupported\"", "            fi", "        fi", "        return $_status", "    elif [ \"$_dld\" = wget ]; then", "        if [ \"$(wget -V 2>&1|head -2|tail -1|cut -f1 -d\" \")\" = \"BusyBox\" ]; then", "            echo \"Warning: using the BusyBox version of wget.  Not enforcing strong cipher suites for TLS or TLS v1.2, this is potentially less secure\"", "            _err=$(wget \"$1\" -O \"$2\" 2>&1)", "            _status=$?", "        else", "            get_ciphersuites_for_wget", "            _ciphersuites=\"$RETVAL\"", "            if [ -n \"$_ciphersuites\" ]; then", "                _err=$(wget --https-only --secure-protocol=TLSv1_2 --ciphers \"$_ciphersuites\" \"$1\" -O \"$2\" 2>&1)", "                _status=$?", "            else", "                echo \"Warning: Not enforcing strong cipher suites for TLS, this is potentially less secure\"", "                if ! check_help_for \"$3\" wget --https-only --secure-protocol; then", "                    echo \"Warning: Not enforcing TLS v1.2, this is potentially less secure\"", "                    _err=$(wget \"$1\" -O \"$2\" 2>&1)", "                    _status=$?", "                else", "                    _err=$(wget --https-only --secure-protocol=TLSv1_2 \"$1\" -O \"$2\" 2>&1)", "                    _status=$?", "                fi", "            fi", "        fi", "        if [ -n \"$_err\" ]; then", "            echo \"$_err\" >&2", "            if echo \"$_err\" | grep -q ' 404 Not Found$'; then", "                err \"installer for platform '$3' not found, this may be unsupported\"", "            fi", "        fi", "        return $_status", "    else", "        err \"Unknown downloader\"   # should not reach here", "    fi", "}", "", "check_help_for() {", "    local _arch", "    local _cmd", "    local _arg", "    _arch=\"$1\"", "    shift", "    _cmd=\"$1\"", "    shift", "", "    local _category", "    if \"$_cmd\" --help | grep -q 'For all options use the manual or \"--help all\".'; then", "      _category=\"all\"", "    else", "      _category=\"\"", "    fi", "", "    case \"$_arch\" in", "", "        *darwin*)", "        if check_cmd sw_vers; then", "            case $(sw_vers -productVersion) in", "                10.*)", "                    # If we're running on macOS, older than 10.13, then we always", "                    # fail to find these options to force fallback", "                    if [ \"$(sw_vers -productVersion | cut -d. -f2)\" -lt 13 ]; then", "                        # Older than 10.13", "                        echo \"Warning: Detected macOS platform older than 10.13\"", "                        return 1", "                    fi", "                    ;;", "                11.*)", "                    # We assume Big Sur will be OK for now", "                    ;;", "                *)", "                    # Unknown product version, warn and continue", "                    echo \"Warning: Detected unknown macOS major version: $(sw_vers -productVersion)\"", "                    echo \"Warning TLS capabilities detection may fail\"", "                    ;;", "            esac", "        fi", "        ;;", "", "    esac", "", "    for _arg in \"$@\"; do", "        if ! \"$_cmd\" --help $_category | grep -q -- \"$_arg\"; then", "            return 1", "        fi", "    done", "", "    true # not strictly needed", "}", "", "# Check if curl supports the --retry flag, then pass it to the curl invocation.", "check_curl_for_retry_support() {", "  local _retry_supported=\"\"", "  # \"unspecified\" is for arch, allows for possibility old OS using macports, homebrew, etc.", "  if check_help_for \"notspecified\" \"curl\" \"--retry\"; then", "    _retry_supported=\"--retry 3\"", "  fi", "", "  RETVAL=\"$_retry_supported\"", "", "}", "", "# Return cipher suite string specified by user, otherwise return strong TLS 1.2-1.3 cipher suites", "# if support by local tools is detected. Detection currently supports these curl backends:", "# GnuTLS and OpenSSL (possibly also LibreSSL and BoringSSL). Return value can be empty.", "get_ciphersuites_for_curl() {", "    if [ -n \"${RUSTUP_TLS_CIPHERSUITES-}\" ]; then", "        # user specified custom cipher suites, assume they know what they're doing", "        RETVAL=\"$RUSTUP_TLS_CIPHERSUITES\"", "        return", "    fi", "", "    local _openssl_syntax=\"no\"", "    local _gnutls_syntax=\"no\"", "    local _backend_supported=\"yes\"", "    if curl -V | grep -q ' OpenSSL/'; then", "        _openssl_syntax=\"yes\"", "    elif curl -V | grep -iq ' LibreSSL/'; then", "        _openssl_syntax=\"yes\"", "    elif curl -V | grep -iq ' BoringSSL/'; then", "        _openssl_syntax=\"yes\"", "    elif curl -V | grep -iq ' GnuTLS/'; then", "        _gnutls_syntax=\"yes\"", "    else", "        _backend_supported=\"no\"", "    fi", "", "    local _args_supported=\"no\"", "    if [ \"$_backend_supported\" = \"yes\" ]; then", "        # \"unspecified\" is for arch, allows for possibility old OS using macports, homebrew, etc.", "        if check_help_for \"notspecified\" \"curl\" \"--tlsv1.2\" \"--ciphers\" \"--proto\"; then", "            _args_supported=\"yes\"", "        fi", "    fi", "", "    local _cs=\"\"", "    if [ \"$_args_supported\" = \"yes\" ]; then", "        if [ \"$_openssl_syntax\" = \"yes\" ]; then", "            _cs=$(get_strong_ciphersuites_for \"openssl\")", "        elif [ \"$_gnutls_syntax\" = \"yes\" ]; then", "            _cs=$(get_strong_ciphersuites_for \"gnutls\")", "        fi", "    fi", "", "    RETVAL=\"$_cs\"", "}", "", "# Return cipher suite string specified by user, otherwise return strong TLS 1.2-1.3 cipher suites", "# if support by local tools is detected. Detection currently supports these wget backends:", "# GnuTLS and OpenSSL (possibly also LibreSSL and BoringSSL). Return value can be empty.", "get_ciphersuites_for_wget() {", "    if [ -n \"${RUSTUP_TLS_CIPHERSUITES-}\" ]; then", "        # user specified custom cipher suites, assume they know what they're doing", "        RETVAL=\"$RUSTUP_TLS_CIPHERSUITES\"", "        return", "    fi", "", "    local _cs=\"\"", "    if wget -V | grep -q '\\-DHAVE_LIBSSL'; then", "        # \"unspecified\" is for arch, allows for possibility old OS using macports, homebrew, etc.", "        if check_help_for \"notspecified\" \"wget\" \"TLSv1_2\" \"--ciphers\" \"--https-only\" \"--secure-protocol\"; then", "            _cs=$(get_strong_ciphersuites_for \"openssl\")", "        fi", "    elif wget -V | grep -q '\\-DHAVE_LIBGNUTLS'; then", "        # \"unspecified\" is for arch, allows for possibility old OS using macports, homebrew, etc.", "        if check_help_for \"notspecified\" \"wget\" \"TLSv1_2\" \"--ciphers\" \"--https-only\" \"--secure-protocol\"; then", "            _cs=$(get_strong_ciphersuites_for \"gnutls\")", "        fi", "    fi", "", "    RETVAL=\"$_cs\"", "}", "", "# Return strong TLS 1.2-1.3 cipher suites in OpenSSL or GnuTLS syntax. TLS 1.2", "# excludes non-ECDHE and non-AEAD cipher suites. DHE is excluded due to bad", "# DH params often found on servers (see RFC 7919). Sequence matches or is", "# similar to Firefox 68 ESR with weak cipher suites disabled via about:config.", "# $1 must be openssl or gnutls.", "get_strong_ciphersuites_for() {", "    if [ \"$1\" = \"openssl\" ]; then", "        # OpenSSL is forgiving of unknown values, no problems with TLS 1.3 values on versions that don't support it yet.", "        echo \"TLS_AES_128_GCM_SHA256:TLS_CHACHA20_POLY1305_SHA256:TLS_AES_256_GCM_SHA384:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384\"", "    elif [ \"$1\" = \"gnutls\" ]; then", "        # GnuTLS isn't forgiving of unknown values, so this may require a GnuTLS version that supports TLS 1.3 even if wget doesn't.", "        # Begin with SECURE128 (and higher) then remove/add to build cipher suites. Produces same 9 cipher suites as OpenSSL but in slightly different order.", "        echo \"SECURE128:-VERS-SSL3.0:-VERS-TLS1.0:-VERS-TLS1.1:-VERS-DTLS-ALL:-CIPHER-ALL:-MAC-ALL:-KX-ALL:+AEAD:+ECDHE-ECDSA:+ECDHE-RSA:+AES-128-GCM:+CHACHA20-POLY1305:+AES-256-GCM\"", "    fi", "}", "", "main \"$@\" || exit 1", "curl: (6) Could not resolve host: |", "curl: (7) Failed to connect to localhost port 80 after 0 ms: Connection refused"]}
2022-12-30 00:13:51,444 p=91629 u=kal n=ansible | PLAY RECAP *******************************************************************************************************************************************
2022-12-30 00:13:51,444 p=91629 u=kal n=ansible | krpz                       : ok=1    changed=0    unreachable=0    failed=1    skipped=0    rescued=0    ignored=0   
2022-12-30 00:14:22,183 p=91823 u=kal n=ansible | PLAY [localhost] *************************************************************************************************************************************
2022-12-30 00:14:22,190 p=91823 u=kal n=ansible | TASK [Gathering Facts] *******************************************************************************************************************************
2022-12-30 00:14:26,139 p=91823 u=kal n=ansible | ok: [krpz]
2022-12-30 00:14:26,160 p=91823 u=kal n=ansible | TASK [Install Rust] **********************************************************************************************************************************
2022-12-30 00:14:26,654 p=91823 u=kal n=ansible | fatal: [krpz]: FAILED! => {"changed": true, "cmd": "curl https://sh.rustup.rs | sh", "delta": "0:00:00.258917", "end": "2022-12-30 00:14:26.578397", "msg": "non-zero return code", "rc": 6, "start": "2022-12-30 00:14:26.319480", "stdout": "#!/bin/sh\r\n# shellcheck shell=dash\r\n\r\n# This is just a little script that can be downloaded from the internet to\r\n# install rustup. It just does platform detection, downloads the installer\r\n# and runs it.\r\n\r\n# It runs on Unix shells like {a,ba,da,k,z}sh. It uses the common `local`\r\n# extension. Note: Most shells limit `local` to 1 var per line, contra bash.\r\n\r\nif [ \"$KSH_VERSION\" = 'Version JM 93t+ 2010-03-05' ]; then\r\n    # The version of ksh93 that ships with many illumos systems does not\r\n    # support the \"local\" extension.  Print a message rather than fail in\r\n    # subtle ways later on:\r\n    echo 'rustup does not work with this ksh93 version; please try bash!' >&2\r\n    exit 1\r\nfi\r\n\r\n\r\nset -u\r\n\r\n# If RUSTUP_UPDATE_ROOT is unset or empty, default it.\r\nRUSTUP_UPDATE_ROOT=\"${RUSTUP_UPDATE_ROOT:-https://static.rust-lang.org/rustup}\"\r\n\r\n#XXX: If you change anything here, please make the same changes in setup_mode.rs\r\nusage() {\r\n    cat 1>&2 <<EOF\r\nrustup-init 1.25.1 (48d233f65 2022-07-12)\r\nThe installer for rustup\r\n\r\nUSAGE:\r\n    rustup-init [FLAGS] [OPTIONS]\r\n\r\nFLAGS:\r\n    -v, --verbose           Enable verbose output\r\n    -q, --quiet             Disable progress output\r\n    -y                      Disable confirmation prompt.\r\n        --no-modify-path    Don't configure the PATH environment variable\r\n    -h, --help              Prints help information\r\n    -V, --version           Prints version information\r\n\r\nOPTIONS:\r\n        --default-host <default-host>              Choose a default host triple\r\n        --default-toolchain <default-toolchain>    Choose a default toolchain to install\r\n        --default-toolchain none                   Do not install any toolchains\r\n        --profile [minimal|default|complete]       Choose a profile\r\n    -c, --component <components>...                Component name to also install\r\n    -t, --target <targets>...                      Target name to also install\r\nEOF\r\n}\r\n\r\nmain() {\r\n    downloader --check\r\n    need_cmd uname\r\n    need_cmd mktemp\r\n    need_cmd chmod\r\n    need_cmd mkdir\r\n    need_cmd rm\r\n    need_cmd rmdir\r\n\r\n    get_architecture || return 1\r\n    local _arch=\"$RETVAL\"\r\n    assert_nz \"$_arch\" \"arch\"\r\n\r\n    local _ext=\"\"\r\n    case \"$_arch\" in\r\n        *windows*)\r\n            _ext=\".exe\"\r\n            ;;\r\n    esac\r\n\r\n    local _url=\"${RUSTUP_UPDATE_ROOT}/dist/${_arch}/rustup-init${_ext}\"\r\n\r\n    local _dir\r\n    _dir=\"$(ensure mktemp -d)\"\r\n    local _file=\"${_dir}/rustup-init${_ext}\"\r\n\r\n    local _ansi_escapes_are_valid=false\r\n    if [ -t 2 ]; then\r\n        if [ \"${TERM+set}\" = 'set' ]; then\r\n            case \"$TERM\" in\r\n                xterm*|rxvt*|urxvt*|linux*|vt*)\r\n                    _ansi_escapes_are_valid=true\r\n                ;;\r\n            esac\r\n        fi\r\n    fi\r\n\r\n    # check if we have to use /dev/tty to prompt the user\r\n    local need_tty=yes\r\n    for arg in \"$@\"; do\r\n        case \"$arg\" in\r\n            --help)\r\n                usage\r\n                exit 0\r\n                ;;\r\n            *)\r\n                OPTIND=1\r\n                if [ \"${arg%%--*}\" = \"\" ]; then\r\n                    # Long option (other than --help);\r\n                    # don't attempt to interpret it.\r\n                    continue\r\n                fi\r\n                while getopts :hy sub_arg \"$arg\"; do\r\n                    case \"$sub_arg\" in\r\n                        h)\r\n                            usage\r\n                            exit 0\r\n                            ;;\r\n                        y)\r\n                            # user wants to skip the prompt --\r\n                            # we don't need /dev/tty\r\n                            need_tty=no\r\n                            ;;\r\n                        *)\r\n                            ;;\r\n                        esac\r\n                done\r\n                ;;\r\n        esac\r\n    done\r\n\r\n    if $_ansi_escapes_are_valid; then\r\n        printf \"\\33[1minfo:\\33[0m downloading installer\\n\" 1>&2\r\n    else\r\n        printf '%s\\n' 'info: downloading installer' 1>&2\r\n    fi\r\n\r\n    ensure mkdir -p \"$_dir\"\r\n    ensure downloader \"$_url\" \"$_file\" \"$_arch\"\r\n    ensure chmod u+x \"$_file\"\r\n    if [ ! -x \"$_file\" ]; then\r\n        printf '%s\\n' \"Cannot execute $_file (likely because of mounting /tmp as noexec).\" 1>&2\r\n        printf '%s\\n' \"Please copy the file to a location where you can execute binaries and run ./rustup-init${_ext}.\" 1>&2\r\n        exit 1\r\n    fi\r\n\r\n    if [ \"$need_tty\" = \"yes\" ] && [ ! -t 0 ]; then\r\n        # The installer is going to want to ask for confirmation by\r\n        # reading stdin.  This script was piped into `sh` though and\r\n        # doesn't have stdin to pass to its children. Instead we're going\r\n        # to explicitly connect /dev/tty to the installer's stdin.\r\n        if [ ! -t 1 ]; then\r\n            err \"Unable to run interactively. Run with -y to accept defaults, --help for additional options\"\r\n        fi\r\n\r\n        ignore \"$_file\" \"$@\" < /dev/tty\r\n    else\r\n        ignore \"$_file\" \"$@\"\r\n    fi\r\n\r\n    local _retval=$?\r\n\r\n    ignore rm \"$_file\"\r\n    ignore rmdir \"$_dir\"\r\n\r\n    return \"$_retval\"\r\n}\r\n\r\ncheck_proc() {\r\n    # Check for /proc by looking for the /proc/self/exe link\r\n    # This is only run on Linux\r\n    if ! test -L /proc/self/exe ; then\r\n        err \"fatal: Unable to find /proc/self/exe.  Is /proc mounted?  Installation cannot proceed without /proc.\"\r\n    fi\r\n}\r\n\r\nget_bitness() {\r\n    need_cmd head\r\n    # Architecture detection without dependencies beyond coreutils.\r\n    # ELF files start out \"\\x7fELF\", and the following byte is\r\n    #   0x01 for 32-bit and\r\n    #   0x02 for 64-bit.\r\n    # The printf builtin on some shells like dash only supports octal\r\n    # escape sequences, so we use those.\r\n    local _current_exe_head\r\n    _current_exe_head=$(head -c 5 /proc/self/exe )\r\n    if [ \"$_current_exe_head\" = \"$(printf '\\177ELF\\001')\" ]; then\r\n        echo 32\r\n    elif [ \"$_current_exe_head\" = \"$(printf '\\177ELF\\002')\" ]; then\r\n        echo 64\r\n    else\r\n        err \"unknown platform bitness\"\r\n    fi\r\n}\r\n\r\nis_host_amd64_elf() {\r\n    need_cmd head\r\n    need_cmd tail\r\n    # ELF e_machine detection without dependencies beyond coreutils.\r\n    # Two-byte field at offset 0x12 indicates the CPU,\r\n    # but we're interested in it being 0x3E to indicate amd64, or not that.\r\n    local _current_exe_machine\r\n    _current_exe_machine=$(head -c 19 /proc/self/exe | tail -c 1)\r\n    [ \"$_current_exe_machine\" = \"$(printf '\\076')\" ]\r\n}\r\n\r\nget_endianness() {\r\n    local cputype=$1\r\n    local suffix_eb=$2\r\n    local suffix_el=$3\r\n\r\n    # detect endianness without od/hexdump, like get_bitness() does.\r\n    need_cmd head\r\n    need_cmd tail\r\n\r\n    local _current_exe_endianness\r\n    _current_exe_endianness=\"$(head -c 6 /proc/self/exe | tail -c 1)\"\r\n    if [ \"$_current_exe_endianness\" = \"$(printf '\\001')\" ]; then\r\n        echo \"${cputype}${suffix_el}\"\r\n    elif [ \"$_current_exe_endianness\" = \"$(printf '\\002')\" ]; then\r\n        echo \"${cputype}${suffix_eb}\"\r\n    else\r\n        err \"unknown platform endianness\"\r\n    fi\r\n}\r\n\r\nget_architecture() {\r\n    local _ostype _cputype _bitness _arch _clibtype\r\n    _ostype=\"$(uname -s)\"\r\n    _cputype=\"$(uname -m)\"\r\n    _clibtype=\"gnu\"\r\n\r\n    if [ \"$_ostype\" = Linux ]; then\r\n        if [ \"$(uname -o)\" = Android ]; then\r\n            _ostype=Android\r\n        fi\r\n        if ldd --version 2>&1 | grep -q 'musl'; then\r\n            _clibtype=\"musl\"\r\n        fi\r\n    fi\r\n\r\n    if [ \"$_ostype\" = Darwin ] && [ \"$_cputype\" = i386 ]; then\r\n        # Darwin `uname -m` lies\r\n        if sysctl hw.optional.x86_64 | grep -q ': 1'; then\r\n            _cputype=x86_64\r\n        fi\r\n    fi\r\n\r\n    if [ \"$_ostype\" = SunOS ]; then\r\n        # Both Solaris and illumos presently announce as \"SunOS\" in \"uname -s\"\r\n        # so use \"uname -o\" to disambiguate.  We use the full path to the\r\n        # system uname in case the user has coreutils uname first in PATH,\r\n        # which has historically sometimes printed the wrong value here.\r\n        if [ \"$(/usr/bin/uname -o)\" = illumos ]; then\r\n            _ostype=illumos\r\n        fi\r\n\r\n        # illumos systems have multi-arch userlands, and \"uname -m\" reports the\r\n        # machine hardware name; e.g., \"i86pc\" on both 32- and 64-bit x86\r\n        # systems.  Check for the native (widest) instruction set on the\r\n        # running kernel:\r\n        if [ \"$_cputype\" = i86pc ]; then\r\n            _cputype=\"$(isainfo -n)\"\r\n        fi\r\n    fi\r\n\r\n    case \"$_ostype\" in\r\n\r\n        Android)\r\n            _ostype=linux-android\r\n            ;;\r\n\r\n        Linux)\r\n            check_proc\r\n            _ostype=unknown-linux-$_clibtype\r\n            _bitness=$(get_bitness)\r\n            ;;\r\n\r\n        FreeBSD)\r\n            _ostype=unknown-freebsd\r\n            ;;\r\n\r\n        NetBSD)\r\n            _ostype=unknown-netbsd\r\n            ;;\r\n\r\n        DragonFly)\r\n            _ostype=unknown-dragonfly\r\n            ;;\r\n\r\n        Darwin)\r\n            _ostype=apple-darwin\r\n            ;;\r\n\r\n        illumos)\r\n            _ostype=unknown-illumos\r\n            ;;\r\n\r\n        MINGW* | MSYS* | CYGWIN* | Windows_NT)\r\n            _ostype=pc-windows-gnu\r\n            ;;\r\n\r\n        *)\r\n            err \"unrecognized OS type: $_ostype\"\r\n            ;;\r\n\r\n    esac\r\n\r\n    case \"$_cputype\" in\r\n\r\n        i386 | i486 | i686 | i786 | x86)\r\n            _cputype=i686\r\n            ;;\r\n\r\n        xscale | arm)\r\n            _cputype=arm\r\n            if [ \"$_ostype\" = \"linux-android\" ]; then\r\n                _ostype=linux-androideabi\r\n            fi\r\n            ;;\r\n\r\n        armv6l)\r\n            _cputype=arm\r\n            if [ \"$_ostype\" = \"linux-android\" ]; then\r\n                _ostype=linux-androideabi\r\n            else\r\n                _ostype=\"${_ostype}eabihf\"\r\n            fi\r\n            ;;\r\n\r\n        armv7l | armv8l)\r\n            _cputype=armv7\r\n            if [ \"$_ostype\" = \"linux-android\" ]; then\r\n                _ostype=linux-androideabi\r\n            else\r\n                _ostype=\"${_ostype}eabihf\"\r\n            fi\r\n            ;;\r\n\r\n        aarch64 | arm64)\r\n            _cputype=aarch64\r\n            ;;\r\n\r\n        x86_64 | x86-64 | x64 | amd64)\r\n            _cputype=x86_64\r\n            ;;\r\n\r\n        mips)\r\n            _cputype=$(get_endianness mips '' el)\r\n            ;;\r\n\r\n        mips64)\r\n            if [ \"$_bitness\" -eq 64 ]; then\r\n                # only n64 ABI is supported for now\r\n                _ostype=\"${_ostype}abi64\"\r\n                _cputype=$(get_endianness mips64 '' el)\r\n            fi\r\n            ;;\r\n\r\n        ppc)\r\n            _cputype=powerpc\r\n            ;;\r\n\r\n        ppc64)\r\n            _cputype=powerpc64\r\n            ;;\r\n\r\n        ppc64le)\r\n            _cputype=powerpc64le\r\n            ;;\r\n\r\n        s390x)\r\n            _cputype=s390x\r\n            ;;\r\n        riscv64)\r\n            _cputype=riscv64gc\r\n            ;;\r\n        *)\r\n            err \"unknown CPU type: $_cputype\"\r\n\r\n    esac\r\n\r\n    # Detect 64-bit linux with 32-bit userland\r\n    if [ \"${_ostype}\" = unknown-linux-gnu ] && [ \"${_bitness}\" -eq 32 ]; then\r\n        case $_cputype in\r\n            x86_64)\r\n                if [ -n \"${RUSTUP_CPUTYPE:-}\" ]; then\r\n                    _cputype=\"$RUSTUP_CPUTYPE\"\r\n                else {\r\n                    # 32-bit executable for amd64 = x32\r\n                    if is_host_amd64_elf; then {\r\n                         echo \"This host is running an x32 userland; as it stands, x32 support is poor,\" 1>&2\r\n                         echo \"and there isn't a native toolchain -- you will have to install\" 1>&2\r\n                         echo \"multiarch compatibility with i686 and/or amd64, then select one\" 1>&2\r\n                         echo \"by re-running this script with the RUSTUP_CPUTYPE environment variable\" 1>&2\r\n                         echo \"set to i686 or x86_64, respectively.\" 1>&2\r\n                         echo 1>&2\r\n                         echo \"You will be able to add an x32 target after installation by running\" 1>&2\r\n                         echo \"  rustup target add x86_64-unknown-linux-gnux32\" 1>&2\r\n                         exit 1\r\n                    }; else\r\n                        _cputype=i686\r\n                    fi\r\n                }; fi\r\n                ;;\r\n            mips64)\r\n                _cputype=$(get_endianness mips '' el)\r\n                ;;\r\n            powerpc64)\r\n                _cputype=powerpc\r\n                ;;\r\n            aarch64)\r\n                _cputype=armv7\r\n                if [ \"$_ostype\" = \"linux-android\" ]; then\r\n                    _ostype=linux-androideabi\r\n                else\r\n                    _ostype=\"${_ostype}eabihf\"\r\n                fi\r\n                ;;\r\n            riscv64gc)\r\n                err \"riscv64 with 32-bit userland unsupported\"\r\n                ;;\r\n        esac\r\n    fi\r\n\r\n    # Detect armv7 but without the CPU features Rust needs in that build,\r\n    # and fall back to arm.\r\n    # See https://github.com/rust-lang/rustup.rs/issues/587.\r\n    if [ \"$_ostype\" = \"unknown-linux-gnueabihf\" ] && [ \"$_cputype\" = armv7 ]; then\r\n        if ensure grep '^Features' /proc/cpuinfo | grep -q -v neon; then\r\n            # At least one processor does not have NEON.\r\n            _cputype=arm\r\n        fi\r\n    fi\r\n\r\n    _arch=\"${_cputype}-${_ostype}\"\r\n\r\n    RETVAL=\"$_arch\"\r\n}\r\n\r\nsay() {\r\n    printf 'rustup: %s\\n' \"$1\"\r\n}\r\n\r\nerr() {\r\n    say \"$1\" >&2\r\n    exit 1\r\n}\r\n\r\nneed_cmd() {\r\n    if ! check_cmd \"$1\"; then\r\n        err \"need '$1' (command not found)\"\r\n    fi\r\n}\r\n\r\ncheck_cmd() {\r\n    command -v \"$1\" > /dev/null 2>&1\r\n}\r\n\r\nassert_nz() {\r\n    if [ -z \"$1\" ]; then err \"assert_nz $2\"; fi\r\n}\r\n\r\n# Run a command that should never fail. If the command fails execution\r\n# will immediately terminate with an error showing the failing\r\n# command.\r\nensure() {\r\n    if ! \"$@\"; then err \"command failed: $*\"; fi\r\n}\r\n\r\n# This is just for indicating that commands' results are being\r\n# intentionally ignored. Usually, because it's being executed\r\n# as part of error handling.\r\nignore() {\r\n    \"$@\"\r\n}\r\n\r\n# This wraps curl or wget. Try curl first, if not installed,\r\n# use wget instead.\r\ndownloader() {\r\n    local _dld\r\n    local _ciphersuites\r\n    local _err\r\n    local _status\r\n    local _retry\r\n    if check_cmd curl; then\r\n        _dld=curl\r\n    elif check_cmd wget; then\r\n        _dld=wget\r\n    else\r\n        _dld='curl or wget' # to be used in error message of need_cmd\r\n    fi\r\n\r\n    if [ \"$1\" = --check ]; then\r\n        need_cmd \"$_dld\"\r\n    elif [ \"$_dld\" = curl ]; then\r\n        check_curl_for_retry_support\r\n        _retry=\"$RETVAL\"\r\n        get_ciphersuites_for_curl\r\n        _ciphersuites=\"$RETVAL\"\r\n        if [ -n \"$_ciphersuites\" ]; then\r\n            _err=$(curl $_retry --proto '=https' --tlsv1.2 --ciphers \"$_ciphersuites\" --silent --show-error --fail --location \"$1\" --output \"$2\" 2>&1)\r\n            _status=$?\r\n        else\r\n            echo \"Warning: Not enforcing strong cipher suites for TLS, this is potentially less secure\"\r\n            if ! check_help_for \"$3\" curl --proto --tlsv1.2; then\r\n                echo \"Warning: Not enforcing TLS v1.2, this is potentially less secure\"\r\n                _err=$(curl $_retry --silent --show-error --fail --location \"$1\" --output \"$2\" 2>&1)\r\n                _status=$?\r\n            else\r\n                _err=$(curl $_retry --proto '=https' --tlsv1.2 --silent --show-error --fail --location \"$1\" --output \"$2\" 2>&1)\r\n                _status=$?\r\n            fi\r\n        fi\r\n        if [ -n \"$_err\" ]; then\r\n            echo \"$_err\" >&2\r\n            if echo \"$_err\" | grep -q 404$; then\r\n                err \"installer for platform '$3' not found, this may be unsupported\"\r\n            fi\r\n        fi\r\n        return $_status\r\n    elif [ \"$_dld\" = wget ]; then\r\n        if [ \"$(wget -V 2>&1|head -2|tail -1|cut -f1 -d\" \")\" = \"BusyBox\" ]; then\r\n            echo \"Warning: using the BusyBox version of wget.  Not enforcing strong cipher suites for TLS or TLS v1.2, this is potentially less secure\"\r\n            _err=$(wget \"$1\" -O \"$2\" 2>&1)\r\n            _status=$?\r\n        else\r\n            get_ciphersuites_for_wget\r\n            _ciphersuites=\"$RETVAL\"\r\n            if [ -n \"$_ciphersuites\" ]; then\r\n                _err=$(wget --https-only --secure-protocol=TLSv1_2 --ciphers \"$_ciphersuites\" \"$1\" -O \"$2\" 2>&1)\r\n                _status=$?\r\n            else\r\n                echo \"Warning: Not enforcing strong cipher suites for TLS, this is potentially less secure\"\r\n                if ! check_help_for \"$3\" wget --https-only --secure-protocol; then\r\n                    echo \"Warning: Not enforcing TLS v1.2, this is potentially less secure\"\r\n                    _err=$(wget \"$1\" -O \"$2\" 2>&1)\r\n                    _status=$?\r\n                else\r\n                    _err=$(wget --https-only --secure-protocol=TLSv1_2 \"$1\" -O \"$2\" 2>&1)\r\n                    _status=$?\r\n                fi\r\n            fi\r\n        fi\r\n        if [ -n \"$_err\" ]; then\r\n            echo \"$_err\" >&2\r\n            if echo \"$_err\" | grep -q ' 404 Not Found$'; then\r\n                err \"installer for platform '$3' not found, this may be unsupported\"\r\n            fi\r\n        fi\r\n        return $_status\r\n    else\r\n        err \"Unknown downloader\"   # should not reach here\r\n    fi\r\n}\r\n\r\ncheck_help_for() {\r\n    local _arch\r\n    local _cmd\r\n    local _arg\r\n    _arch=\"$1\"\r\n    shift\r\n    _cmd=\"$1\"\r\n    shift\r\n\r\n    local _category\r\n    if \"$_cmd\" --help | grep -q 'For all options use the manual or \"--help all\".'; then\r\n      _category=\"all\"\r\n    else\r\n      _category=\"\"\r\n    fi\r\n\r\n    case \"$_arch\" in\r\n\r\n        *darwin*)\r\n        if check_cmd sw_vers; then\r\n            case $(sw_vers -productVersion) in\r\n                10.*)\r\n                    # If we're running on macOS, older than 10.13, then we always\r\n                    # fail to find these options to force fallback\r\n                    if [ \"$(sw_vers -productVersion | cut -d. -f2)\" -lt 13 ]; then\r\n                        # Older than 10.13\r\n                        echo \"Warning: Detected macOS platform older than 10.13\"\r\n                        return 1\r\n                    fi\r\n                    ;;\r\n                11.*)\r\n                    # We assume Big Sur will be OK for now\r\n                    ;;\r\n                *)\r\n                    # Unknown product version, warn and continue\r\n                    echo \"Warning: Detected unknown macOS major version: $(sw_vers -productVersion)\"\r\n                    echo \"Warning TLS capabilities detection may fail\"\r\n                    ;;\r\n            esac\r\n        fi\r\n        ;;\r\n\r\n    esac\r\n\r\n    for _arg in \"$@\"; do\r\n        if ! \"$_cmd\" --help $_category | grep -q -- \"$_arg\"; then\r\n            return 1\r\n        fi\r\n    done\r\n\r\n    true # not strictly needed\r\n}\r\n\r\n# Check if curl supports the --retry flag, then pass it to the curl invocation.\r\ncheck_curl_for_retry_support() {\r\n  local _retry_supported=\"\"\r\n  # \"unspecified\" is for arch, allows for possibility old OS using macports, homebrew, etc.\r\n  if check_help_for \"notspecified\" \"curl\" \"--retry\"; then\r\n    _retry_supported=\"--retry 3\"\r\n  fi\r\n\r\n  RETVAL=\"$_retry_supported\"\r\n\r\n}\r\n\r\n# Return cipher suite string specified by user, otherwise return strong TLS 1.2-1.3 cipher suites\r\n# if support by local tools is detected. Detection currently supports these curl backends:\r\n# GnuTLS and OpenSSL (possibly also LibreSSL and BoringSSL). Return value can be empty.\r\nget_ciphersuites_for_curl() {\r\n    if [ -n \"${RUSTUP_TLS_CIPHERSUITES-}\" ]; then\r\n        # user specified custom cipher suites, assume they know what they're doing\r\n        RETVAL=\"$RUSTUP_TLS_CIPHERSUITES\"\r\n        return\r\n    fi\r\n\r\n    local _openssl_syntax=\"no\"\r\n    local _gnutls_syntax=\"no\"\r\n    local _backend_supported=\"yes\"\r\n    if curl -V | grep -q ' OpenSSL/'; then\r\n        _openssl_syntax=\"yes\"\r\n    elif curl -V | grep -iq ' LibreSSL/'; then\r\n        _openssl_syntax=\"yes\"\r\n    elif curl -V | grep -iq ' BoringSSL/'; then\r\n        _openssl_syntax=\"yes\"\r\n    elif curl -V | grep -iq ' GnuTLS/'; then\r\n        _gnutls_syntax=\"yes\"\r\n    else\r\n        _backend_supported=\"no\"\r\n    fi\r\n\r\n    local _args_supported=\"no\"\r\n    if [ \"$_backend_supported\" = \"yes\" ]; then\r\n        # \"unspecified\" is for arch, allows for possibility old OS using macports, homebrew, etc.\r\n        if check_help_for \"notspecified\" \"curl\" \"--tlsv1.2\" \"--ciphers\" \"--proto\"; then\r\n            _args_supported=\"yes\"\r\n        fi\r\n    fi\r\n\r\n    local _cs=\"\"\r\n    if [ \"$_args_supported\" = \"yes\" ]; then\r\n        if [ \"$_openssl_syntax\" = \"yes\" ]; then\r\n            _cs=$(get_strong_ciphersuites_for \"openssl\")\r\n        elif [ \"$_gnutls_syntax\" = \"yes\" ]; then\r\n            _cs=$(get_strong_ciphersuites_for \"gnutls\")\r\n        fi\r\n    fi\r\n\r\n    RETVAL=\"$_cs\"\r\n}\r\n\r\n# Return cipher suite string specified by user, otherwise return strong TLS 1.2-1.3 cipher suites\r\n# if support by local tools is detected. Detection currently supports these wget backends:\r\n# GnuTLS and OpenSSL (possibly also LibreSSL and BoringSSL). Return value can be empty.\r\nget_ciphersuites_for_wget() {\r\n    if [ -n \"${RUSTUP_TLS_CIPHERSUITES-}\" ]; then\r\n        # user specified custom cipher suites, assume they know what they're doing\r\n        RETVAL=\"$RUSTUP_TLS_CIPHERSUITES\"\r\n        return\r\n    fi\r\n\r\n    local _cs=\"\"\r\n    if wget -V | grep -q '\\-DHAVE_LIBSSL'; then\r\n        # \"unspecified\" is for arch, allows for possibility old OS using macports, homebrew, etc.\r\n        if check_help_for \"notspecified\" \"wget\" \"TLSv1_2\" \"--ciphers\" \"--https-only\" \"--secure-protocol\"; then\r\n            _cs=$(get_strong_ciphersuites_for \"openssl\")\r\n        fi\r\n    elif wget -V | grep -q '\\-DHAVE_LIBGNUTLS'; then\r\n        # \"unspecified\" is for arch, allows for possibility old OS using macports, homebrew, etc.\r\n        if check_help_for \"notspecified\" \"wget\" \"TLSv1_2\" \"--ciphers\" \"--https-only\" \"--secure-protocol\"; then\r\n            _cs=$(get_strong_ciphersuites_for \"gnutls\")\r\n        fi\r\n    fi\r\n\r\n    RETVAL=\"$_cs\"\r\n}\r\n\r\n# Return strong TLS 1.2-1.3 cipher suites in OpenSSL or GnuTLS syntax. TLS 1.2\r\n# excludes non-ECDHE and non-AEAD cipher suites. DHE is excluded due to bad\r\n# DH params often found on servers (see RFC 7919). Sequence matches or is\r\n# similar to Firefox 68 ESR with weak cipher suites disabled via about:config.\r\n# $1 must be openssl or gnutls.\r\nget_strong_ciphersuites_for() {\r\n    if [ \"$1\" = \"openssl\" ]; then\r\n        # OpenSSL is forgiving of unknown values, no problems with TLS 1.3 values on versions that don't support it yet.\r\n        echo \"TLS_AES_128_GCM_SHA256:TLS_CHACHA20_POLY1305_SHA256:TLS_AES_256_GCM_SHA384:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384\"\r\n    elif [ \"$1\" = \"gnutls\" ]; then\r\n        # GnuTLS isn't forgiving of unknown values, so this may require a GnuTLS version that supports TLS 1.3 even if wget doesn't.\r\n        # Begin with SECURE128 (and higher) then remove/add to build cipher suites. Produces same 9 cipher suites as OpenSSL but in slightly different order.\r\n        echo \"SECURE128:-VERS-SSL3.0:-VERS-TLS1.0:-VERS-TLS1.1:-VERS-DTLS-ALL:-CIPHER-ALL:-MAC-ALL:-KX-ALL:+AEAD:+ECDHE-ECDSA:+ECDHE-RSA:+AES-128-GCM:+CHACHA20-POLY1305:+AES-256-GCM\"\r\n    fi\r\n}\r\n\r\nmain \"$@\" || exit 1\r\ncurl: (6) Could not resolve host: |\r\ncurl: (6) Could not resolve host: sh", "stdout_lines": ["#!/bin/sh", "# shellcheck shell=dash", "", "# This is just a little script that can be downloaded from the internet to", "# install rustup. It just does platform detection, downloads the installer", "# and runs it.", "", "# It runs on Unix shells like {a,ba,da,k,z}sh. It uses the common `local`", "# extension. Note: Most shells limit `local` to 1 var per line, contra bash.", "", "if [ \"$KSH_VERSION\" = 'Version JM 93t+ 2010-03-05' ]; then", "    # The version of ksh93 that ships with many illumos systems does not", "    # support the \"local\" extension.  Print a message rather than fail in", "    # subtle ways later on:", "    echo 'rustup does not work with this ksh93 version; please try bash!' >&2", "    exit 1", "fi", "", "", "set -u", "", "# If RUSTUP_UPDATE_ROOT is unset or empty, default it.", "RUSTUP_UPDATE_ROOT=\"${RUSTUP_UPDATE_ROOT:-https://static.rust-lang.org/rustup}\"", "", "#XXX: If you change anything here, please make the same changes in setup_mode.rs", "usage() {", "    cat 1>&2 <<EOF", "rustup-init 1.25.1 (48d233f65 2022-07-12)", "The installer for rustup", "", "USAGE:", "    rustup-init [FLAGS] [OPTIONS]", "", "FLAGS:", "    -v, --verbose           Enable verbose output", "    -q, --quiet             Disable progress output", "    -y                      Disable confirmation prompt.", "        --no-modify-path    Don't configure the PATH environment variable", "    -h, --help              Prints help information", "    -V, --version           Prints version information", "", "OPTIONS:", "        --default-host <default-host>              Choose a default host triple", "        --default-toolchain <default-toolchain>    Choose a default toolchain to install", "        --default-toolchain none                   Do not install any toolchains", "        --profile [minimal|default|complete]       Choose a profile", "    -c, --component <components>...                Component name to also install", "    -t, --target <targets>...                      Target name to also install", "EOF", "}", "", "main() {", "    downloader --check", "    need_cmd uname", "    need_cmd mktemp", "    need_cmd chmod", "    need_cmd mkdir", "    need_cmd rm", "    need_cmd rmdir", "", "    get_architecture || return 1", "    local _arch=\"$RETVAL\"", "    assert_nz \"$_arch\" \"arch\"", "", "    local _ext=\"\"", "    case \"$_arch\" in", "        *windows*)", "            _ext=\".exe\"", "            ;;", "    esac", "", "    local _url=\"${RUSTUP_UPDATE_ROOT}/dist/${_arch}/rustup-init${_ext}\"", "", "    local _dir", "    _dir=\"$(ensure mktemp -d)\"", "    local _file=\"${_dir}/rustup-init${_ext}\"", "", "    local _ansi_escapes_are_valid=false", "    if [ -t 2 ]; then", "        if [ \"${TERM+set}\" = 'set' ]; then", "            case \"$TERM\" in", "                xterm*|rxvt*|urxvt*|linux*|vt*)", "                    _ansi_escapes_are_valid=true", "                ;;", "            esac", "        fi", "    fi", "", "    # check if we have to use /dev/tty to prompt the user", "    local need_tty=yes", "    for arg in \"$@\"; do", "        case \"$arg\" in", "            --help)", "                usage", "                exit 0", "                ;;", "            *)", "                OPTIND=1", "                if [ \"${arg%%--*}\" = \"\" ]; then", "                    # Long option (other than --help);", "                    # don't attempt to interpret it.", "                    continue", "                fi", "                while getopts :hy sub_arg \"$arg\"; do", "                    case \"$sub_arg\" in", "                        h)", "                            usage", "                            exit 0", "                            ;;", "                        y)", "                            # user wants to skip the prompt --", "                            # we don't need /dev/tty", "                            need_tty=no", "                            ;;", "                        *)", "                            ;;", "                        esac", "                done", "                ;;", "        esac", "    done", "", "    if $_ansi_escapes_are_valid; then", "        printf \"\\33[1minfo:\\33[0m downloading installer\\n\" 1>&2", "    else", "        printf '%s\\n' 'info: downloading installer' 1>&2", "    fi", "", "    ensure mkdir -p \"$_dir\"", "    ensure downloader \"$_url\" \"$_file\" \"$_arch\"", "    ensure chmod u+x \"$_file\"", "    if [ ! -x \"$_file\" ]; then", "        printf '%s\\n' \"Cannot execute $_file (likely because of mounting /tmp as noexec).\" 1>&2", "        printf '%s\\n' \"Please copy the file to a location where you can execute binaries and run ./rustup-init${_ext}.\" 1>&2", "        exit 1", "    fi", "", "    if [ \"$need_tty\" = \"yes\" ] && [ ! -t 0 ]; then", "        # The installer is going to want to ask for confirmation by", "        # reading stdin.  This script was piped into `sh` though and", "        # doesn't have stdin to pass to its children. Instead we're going", "        # to explicitly connect /dev/tty to the installer's stdin.", "        if [ ! -t 1 ]; then", "            err \"Unable to run interactively. Run with -y to accept defaults, --help for additional options\"", "        fi", "", "        ignore \"$_file\" \"$@\" < /dev/tty", "    else", "        ignore \"$_file\" \"$@\"", "    fi", "", "    local _retval=$?", "", "    ignore rm \"$_file\"", "    ignore rmdir \"$_dir\"", "", "    return \"$_retval\"", "}", "", "check_proc() {", "    # Check for /proc by looking for the /proc/self/exe link", "    # This is only run on Linux", "    if ! test -L /proc/self/exe ; then", "        err \"fatal: Unable to find /proc/self/exe.  Is /proc mounted?  Installation cannot proceed without /proc.\"", "    fi", "}", "", "get_bitness() {", "    need_cmd head", "    # Architecture detection without dependencies beyond coreutils.", "    # ELF files start out \"\\x7fELF\", and the following byte is", "    #   0x01 for 32-bit and", "    #   0x02 for 64-bit.", "    # The printf builtin on some shells like dash only supports octal", "    # escape sequences, so we use those.", "    local _current_exe_head", "    _current_exe_head=$(head -c 5 /proc/self/exe )", "    if [ \"$_current_exe_head\" = \"$(printf '\\177ELF\\001')\" ]; then", "        echo 32", "    elif [ \"$_current_exe_head\" = \"$(printf '\\177ELF\\002')\" ]; then", "        echo 64", "    else", "        err \"unknown platform bitness\"", "    fi", "}", "", "is_host_amd64_elf() {", "    need_cmd head", "    need_cmd tail", "    # ELF e_machine detection without dependencies beyond coreutils.", "    # Two-byte field at offset 0x12 indicates the CPU,", "    # but we're interested in it being 0x3E to indicate amd64, or not that.", "    local _current_exe_machine", "    _current_exe_machine=$(head -c 19 /proc/self/exe | tail -c 1)", "    [ \"$_current_exe_machine\" = \"$(printf '\\076')\" ]", "}", "", "get_endianness() {", "    local cputype=$1", "    local suffix_eb=$2", "    local suffix_el=$3", "", "    # detect endianness without od/hexdump, like get_bitness() does.", "    need_cmd head", "    need_cmd tail", "", "    local _current_exe_endianness", "    _current_exe_endianness=\"$(head -c 6 /proc/self/exe | tail -c 1)\"", "    if [ \"$_current_exe_endianness\" = \"$(printf '\\001')\" ]; then", "        echo \"${cputype}${suffix_el}\"", "    elif [ \"$_current_exe_endianness\" = \"$(printf '\\002')\" ]; then", "        echo \"${cputype}${suffix_eb}\"", "    else", "        err \"unknown platform endianness\"", "    fi", "}", "", "get_architecture() {", "    local _ostype _cputype _bitness _arch _clibtype", "    _ostype=\"$(uname -s)\"", "    _cputype=\"$(uname -m)\"", "    _clibtype=\"gnu\"", "", "    if [ \"$_ostype\" = Linux ]; then", "        if [ \"$(uname -o)\" = Android ]; then", "            _ostype=Android", "        fi", "        if ldd --version 2>&1 | grep -q 'musl'; then", "            _clibtype=\"musl\"", "        fi", "    fi", "", "    if [ \"$_ostype\" = Darwin ] && [ \"$_cputype\" = i386 ]; then", "        # Darwin `uname -m` lies", "        if sysctl hw.optional.x86_64 | grep -q ': 1'; then", "            _cputype=x86_64", "        fi", "    fi", "", "    if [ \"$_ostype\" = SunOS ]; then", "        # Both Solaris and illumos presently announce as \"SunOS\" in \"uname -s\"", "        # so use \"uname -o\" to disambiguate.  We use the full path to the", "        # system uname in case the user has coreutils uname first in PATH,", "        # which has historically sometimes printed the wrong value here.", "        if [ \"$(/usr/bin/uname -o)\" = illumos ]; then", "            _ostype=illumos", "        fi", "", "        # illumos systems have multi-arch userlands, and \"uname -m\" reports the", "        # machine hardware name; e.g., \"i86pc\" on both 32- and 64-bit x86", "        # systems.  Check for the native (widest) instruction set on the", "        # running kernel:", "        if [ \"$_cputype\" = i86pc ]; then", "            _cputype=\"$(isainfo -n)\"", "        fi", "    fi", "", "    case \"$_ostype\" in", "", "        Android)", "            _ostype=linux-android", "            ;;", "", "        Linux)", "            check_proc", "            _ostype=unknown-linux-$_clibtype", "            _bitness=$(get_bitness)", "            ;;", "", "        FreeBSD)", "            _ostype=unknown-freebsd", "            ;;", "", "        NetBSD)", "            _ostype=unknown-netbsd", "            ;;", "", "        DragonFly)", "            _ostype=unknown-dragonfly", "            ;;", "", "        Darwin)", "            _ostype=apple-darwin", "            ;;", "", "        illumos)", "            _ostype=unknown-illumos", "            ;;", "", "        MINGW* | MSYS* | CYGWIN* | Windows_NT)", "            _ostype=pc-windows-gnu", "            ;;", "", "        *)", "            err \"unrecognized OS type: $_ostype\"", "            ;;", "", "    esac", "", "    case \"$_cputype\" in", "", "        i386 | i486 | i686 | i786 | x86)", "            _cputype=i686", "            ;;", "", "        xscale | arm)", "            _cputype=arm", "            if [ \"$_ostype\" = \"linux-android\" ]; then", "                _ostype=linux-androideabi", "            fi", "            ;;", "", "        armv6l)", "            _cputype=arm", "            if [ \"$_ostype\" = \"linux-android\" ]; then", "                _ostype=linux-androideabi", "            else", "                _ostype=\"${_ostype}eabihf\"", "            fi", "            ;;", "", "        armv7l | armv8l)", "            _cputype=armv7", "            if [ \"$_ostype\" = \"linux-android\" ]; then", "                _ostype=linux-androideabi", "            else", "                _ostype=\"${_ostype}eabihf\"", "            fi", "            ;;", "", "        aarch64 | arm64)", "            _cputype=aarch64", "            ;;", "", "        x86_64 | x86-64 | x64 | amd64)", "            _cputype=x86_64", "            ;;", "", "        mips)", "            _cputype=$(get_endianness mips '' el)", "            ;;", "", "        mips64)", "            if [ \"$_bitness\" -eq 64 ]; then", "                # only n64 ABI is supported for now", "                _ostype=\"${_ostype}abi64\"", "                _cputype=$(get_endianness mips64 '' el)", "            fi", "            ;;", "", "        ppc)", "            _cputype=powerpc", "            ;;", "", "        ppc64)", "            _cputype=powerpc64", "            ;;", "", "        ppc64le)", "            _cputype=powerpc64le", "            ;;", "", "        s390x)", "            _cputype=s390x", "            ;;", "        riscv64)", "            _cputype=riscv64gc", "            ;;", "        *)", "            err \"unknown CPU type: $_cputype\"", "", "    esac", "", "    # Detect 64-bit linux with 32-bit userland", "    if [ \"${_ostype}\" = unknown-linux-gnu ] && [ \"${_bitness}\" -eq 32 ]; then", "        case $_cputype in", "            x86_64)", "                if [ -n \"${RUSTUP_CPUTYPE:-}\" ]; then", "                    _cputype=\"$RUSTUP_CPUTYPE\"", "                else {", "                    # 32-bit executable for amd64 = x32", "                    if is_host_amd64_elf; then {", "                         echo \"This host is running an x32 userland; as it stands, x32 support is poor,\" 1>&2", "                         echo \"and there isn't a native toolchain -- you will have to install\" 1>&2", "                         echo \"multiarch compatibility with i686 and/or amd64, then select one\" 1>&2", "                         echo \"by re-running this script with the RUSTUP_CPUTYPE environment variable\" 1>&2", "                         echo \"set to i686 or x86_64, respectively.\" 1>&2", "                         echo 1>&2", "                         echo \"You will be able to add an x32 target after installation by running\" 1>&2", "                         echo \"  rustup target add x86_64-unknown-linux-gnux32\" 1>&2", "                         exit 1", "                    }; else", "                        _cputype=i686", "                    fi", "                }; fi", "                ;;", "            mips64)", "                _cputype=$(get_endianness mips '' el)", "                ;;", "            powerpc64)", "                _cputype=powerpc", "                ;;", "            aarch64)", "                _cputype=armv7", "                if [ \"$_ostype\" = \"linux-android\" ]; then", "                    _ostype=linux-androideabi", "                else", "                    _ostype=\"${_ostype}eabihf\"", "                fi", "                ;;", "            riscv64gc)", "                err \"riscv64 with 32-bit userland unsupported\"", "                ;;", "        esac", "    fi", "", "    # Detect armv7 but without the CPU features Rust needs in that build,", "    # and fall back to arm.", "    # See https://github.com/rust-lang/rustup.rs/issues/587.", "    if [ \"$_ostype\" = \"unknown-linux-gnueabihf\" ] && [ \"$_cputype\" = armv7 ]; then", "        if ensure grep '^Features' /proc/cpuinfo | grep -q -v neon; then", "            # At least one processor does not have NEON.", "            _cputype=arm", "        fi", "    fi", "", "    _arch=\"${_cputype}-${_ostype}\"", "", "    RETVAL=\"$_arch\"", "}", "", "say() {", "    printf 'rustup: %s\\n' \"$1\"", "}", "", "err() {", "    say \"$1\" >&2", "    exit 1", "}", "", "need_cmd() {", "    if ! check_cmd \"$1\"; then", "        err \"need '$1' (command not found)\"", "    fi", "}", "", "check_cmd() {", "    command -v \"$1\" > /dev/null 2>&1", "}", "", "assert_nz() {", "    if [ -z \"$1\" ]; then err \"assert_nz $2\"; fi", "}", "", "# Run a command that should never fail. If the command fails execution", "# will immediately terminate with an error showing the failing", "# command.", "ensure() {", "    if ! \"$@\"; then err \"command failed: $*\"; fi", "}", "", "# This is just for indicating that commands' results are being", "# intentionally ignored. Usually, because it's being executed", "# as part of error handling.", "ignore() {", "    \"$@\"", "}", "", "# This wraps curl or wget. Try curl first, if not installed,", "# use wget instead.", "downloader() {", "    local _dld", "    local _ciphersuites", "    local _err", "    local _status", "    local _retry", "    if check_cmd curl; then", "        _dld=curl", "    elif check_cmd wget; then", "        _dld=wget", "    else", "        _dld='curl or wget' # to be used in error message of need_cmd", "    fi", "", "    if [ \"$1\" = --check ]; then", "        need_cmd \"$_dld\"", "    elif [ \"$_dld\" = curl ]; then", "        check_curl_for_retry_support", "        _retry=\"$RETVAL\"", "        get_ciphersuites_for_curl", "        _ciphersuites=\"$RETVAL\"", "        if [ -n \"$_ciphersuites\" ]; then", "            _err=$(curl $_retry --proto '=https' --tlsv1.2 --ciphers \"$_ciphersuites\" --silent --show-error --fail --location \"$1\" --output \"$2\" 2>&1)", "            _status=$?", "        else", "            echo \"Warning: Not enforcing strong cipher suites for TLS, this is potentially less secure\"", "            if ! check_help_for \"$3\" curl --proto --tlsv1.2; then", "                echo \"Warning: Not enforcing TLS v1.2, this is potentially less secure\"", "                _err=$(curl $_retry --silent --show-error --fail --location \"$1\" --output \"$2\" 2>&1)", "                _status=$?", "            else", "                _err=$(curl $_retry --proto '=https' --tlsv1.2 --silent --show-error --fail --location \"$1\" --output \"$2\" 2>&1)", "                _status=$?", "            fi", "        fi", "        if [ -n \"$_err\" ]; then", "            echo \"$_err\" >&2", "            if echo \"$_err\" | grep -q 404$; then", "                err \"installer for platform '$3' not found, this may be unsupported\"", "            fi", "        fi", "        return $_status", "    elif [ \"$_dld\" = wget ]; then", "        if [ \"$(wget -V 2>&1|head -2|tail -1|cut -f1 -d\" \")\" = \"BusyBox\" ]; then", "            echo \"Warning: using the BusyBox version of wget.  Not enforcing strong cipher suites for TLS or TLS v1.2, this is potentially less secure\"", "            _err=$(wget \"$1\" -O \"$2\" 2>&1)", "            _status=$?", "        else", "            get_ciphersuites_for_wget", "            _ciphersuites=\"$RETVAL\"", "            if [ -n \"$_ciphersuites\" ]; then", "                _err=$(wget --https-only --secure-protocol=TLSv1_2 --ciphers \"$_ciphersuites\" \"$1\" -O \"$2\" 2>&1)", "                _status=$?", "            else", "                echo \"Warning: Not enforcing strong cipher suites for TLS, this is potentially less secure\"", "                if ! check_help_for \"$3\" wget --https-only --secure-protocol; then", "                    echo \"Warning: Not enforcing TLS v1.2, this is potentially less secure\"", "                    _err=$(wget \"$1\" -O \"$2\" 2>&1)", "                    _status=$?", "                else", "                    _err=$(wget --https-only --secure-protocol=TLSv1_2 \"$1\" -O \"$2\" 2>&1)", "                    _status=$?", "                fi", "            fi", "        fi", "        if [ -n \"$_err\" ]; then", "            echo \"$_err\" >&2", "            if echo \"$_err\" | grep -q ' 404 Not Found$'; then", "                err \"installer for platform '$3' not found, this may be unsupported\"", "            fi", "        fi", "        return $_status", "    else", "        err \"Unknown downloader\"   # should not reach here", "    fi", "}", "", "check_help_for() {", "    local _arch", "    local _cmd", "    local _arg", "    _arch=\"$1\"", "    shift", "    _cmd=\"$1\"", "    shift", "", "    local _category", "    if \"$_cmd\" --help | grep -q 'For all options use the manual or \"--help all\".'; then", "      _category=\"all\"", "    else", "      _category=\"\"", "    fi", "", "    case \"$_arch\" in", "", "        *darwin*)", "        if check_cmd sw_vers; then", "            case $(sw_vers -productVersion) in", "                10.*)", "                    # If we're running on macOS, older than 10.13, then we always", "                    # fail to find these options to force fallback", "                    if [ \"$(sw_vers -productVersion | cut -d. -f2)\" -lt 13 ]; then", "                        # Older than 10.13", "                        echo \"Warning: Detected macOS platform older than 10.13\"", "                        return 1", "                    fi", "                    ;;", "                11.*)", "                    # We assume Big Sur will be OK for now", "                    ;;", "                *)", "                    # Unknown product version, warn and continue", "                    echo \"Warning: Detected unknown macOS major version: $(sw_vers -productVersion)\"", "                    echo \"Warning TLS capabilities detection may fail\"", "                    ;;", "            esac", "        fi", "        ;;", "", "    esac", "", "    for _arg in \"$@\"; do", "        if ! \"$_cmd\" --help $_category | grep -q -- \"$_arg\"; then", "            return 1", "        fi", "    done", "", "    true # not strictly needed", "}", "", "# Check if curl supports the --retry flag, then pass it to the curl invocation.", "check_curl_for_retry_support() {", "  local _retry_supported=\"\"", "  # \"unspecified\" is for arch, allows for possibility old OS using macports, homebrew, etc.", "  if check_help_for \"notspecified\" \"curl\" \"--retry\"; then", "    _retry_supported=\"--retry 3\"", "  fi", "", "  RETVAL=\"$_retry_supported\"", "", "}", "", "# Return cipher suite string specified by user, otherwise return strong TLS 1.2-1.3 cipher suites", "# if support by local tools is detected. Detection currently supports these curl backends:", "# GnuTLS and OpenSSL (possibly also LibreSSL and BoringSSL). Return value can be empty.", "get_ciphersuites_for_curl() {", "    if [ -n \"${RUSTUP_TLS_CIPHERSUITES-}\" ]; then", "        # user specified custom cipher suites, assume they know what they're doing", "        RETVAL=\"$RUSTUP_TLS_CIPHERSUITES\"", "        return", "    fi", "", "    local _openssl_syntax=\"no\"", "    local _gnutls_syntax=\"no\"", "    local _backend_supported=\"yes\"", "    if curl -V | grep -q ' OpenSSL/'; then", "        _openssl_syntax=\"yes\"", "    elif curl -V | grep -iq ' LibreSSL/'; then", "        _openssl_syntax=\"yes\"", "    elif curl -V | grep -iq ' BoringSSL/'; then", "        _openssl_syntax=\"yes\"", "    elif curl -V | grep -iq ' GnuTLS/'; then", "        _gnutls_syntax=\"yes\"", "    else", "        _backend_supported=\"no\"", "    fi", "", "    local _args_supported=\"no\"", "    if [ \"$_backend_supported\" = \"yes\" ]; then", "        # \"unspecified\" is for arch, allows for possibility old OS using macports, homebrew, etc.", "        if check_help_for \"notspecified\" \"curl\" \"--tlsv1.2\" \"--ciphers\" \"--proto\"; then", "            _args_supported=\"yes\"", "        fi", "    fi", "", "    local _cs=\"\"", "    if [ \"$_args_supported\" = \"yes\" ]; then", "        if [ \"$_openssl_syntax\" = \"yes\" ]; then", "            _cs=$(get_strong_ciphersuites_for \"openssl\")", "        elif [ \"$_gnutls_syntax\" = \"yes\" ]; then", "            _cs=$(get_strong_ciphersuites_for \"gnutls\")", "        fi", "    fi", "", "    RETVAL=\"$_cs\"", "}", "", "# Return cipher suite string specified by user, otherwise return strong TLS 1.2-1.3 cipher suites", "# if support by local tools is detected. Detection currently supports these wget backends:", "# GnuTLS and OpenSSL (possibly also LibreSSL and BoringSSL). Return value can be empty.", "get_ciphersuites_for_wget() {", "    if [ -n \"${RUSTUP_TLS_CIPHERSUITES-}\" ]; then", "        # user specified custom cipher suites, assume they know what they're doing", "        RETVAL=\"$RUSTUP_TLS_CIPHERSUITES\"", "        return", "    fi", "", "    local _cs=\"\"", "    if wget -V | grep -q '\\-DHAVE_LIBSSL'; then", "        # \"unspecified\" is for arch, allows for possibility old OS using macports, homebrew, etc.", "        if check_help_for \"notspecified\" \"wget\" \"TLSv1_2\" \"--ciphers\" \"--https-only\" \"--secure-protocol\"; then", "            _cs=$(get_strong_ciphersuites_for \"openssl\")", "        fi", "    elif wget -V | grep -q '\\-DHAVE_LIBGNUTLS'; then", "        # \"unspecified\" is for arch, allows for possibility old OS using macports, homebrew, etc.", "        if check_help_for \"notspecified\" \"wget\" \"TLSv1_2\" \"--ciphers\" \"--https-only\" \"--secure-protocol\"; then", "            _cs=$(get_strong_ciphersuites_for \"gnutls\")", "        fi", "    fi", "", "    RETVAL=\"$_cs\"", "}", "", "# Return strong TLS 1.2-1.3 cipher suites in OpenSSL or GnuTLS syntax. TLS 1.2", "# excludes non-ECDHE and non-AEAD cipher suites. DHE is excluded due to bad", "# DH params often found on servers (see RFC 7919). Sequence matches or is", "# similar to Firefox 68 ESR with weak cipher suites disabled via about:config.", "# $1 must be openssl or gnutls.", "get_strong_ciphersuites_for() {", "    if [ \"$1\" = \"openssl\" ]; then", "        # OpenSSL is forgiving of unknown values, no problems with TLS 1.3 values on versions that don't support it yet.", "        echo \"TLS_AES_128_GCM_SHA256:TLS_CHACHA20_POLY1305_SHA256:TLS_AES_256_GCM_SHA384:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384\"", "    elif [ \"$1\" = \"gnutls\" ]; then", "        # GnuTLS isn't forgiving of unknown values, so this may require a GnuTLS version that supports TLS 1.3 even if wget doesn't.", "        # Begin with SECURE128 (and higher) then remove/add to build cipher suites. Produces same 9 cipher suites as OpenSSL but in slightly different order.", "        echo \"SECURE128:-VERS-SSL3.0:-VERS-TLS1.0:-VERS-TLS1.1:-VERS-DTLS-ALL:-CIPHER-ALL:-MAC-ALL:-KX-ALL:+AEAD:+ECDHE-ECDSA:+ECDHE-RSA:+AES-128-GCM:+CHACHA20-POLY1305:+AES-256-GCM\"", "    fi", "}", "", "main \"$@\" || exit 1", "curl: (6) Could not resolve host: |", "curl: (6) Could not resolve host: sh"]}
2022-12-30 00:14:26,655 p=91823 u=kal n=ansible | PLAY RECAP *******************************************************************************************************************************************
2022-12-30 00:14:26,655 p=91823 u=kal n=ansible | krpz                       : ok=1    changed=0    unreachable=0    failed=1    skipped=0    rescued=0    ignored=0   
2022-12-30 00:15:26,192 p=92047 u=kal n=ansible | PLAY [localhost] *************************************************************************************************************************************
2022-12-30 00:15:26,199 p=92047 u=kal n=ansible | TASK [Gathering Facts] *******************************************************************************************************************************
2022-12-30 00:15:30,205 p=92047 u=kal n=ansible | ok: [krpz]
2022-12-30 00:15:30,227 p=92047 u=kal n=ansible | TASK [Install Rust] **********************************************************************************************************************************
2022-12-30 00:15:30,755 p=92047 u=kal n=ansible | fatal: [krpz]: FAILED! => {"changed": true, "cmd": "curl https://sh.rustup.rs | sh", "delta": "0:00:00.301351", "end": "2022-12-30 00:15:30.687066", "msg": "non-zero return code", "rc": 6, "start": "2022-12-30 00:15:30.385715", "stdout": "#!/bin/sh\r\n# shellcheck shell=dash\r\n\r\n# This is just a little script that can be downloaded from the internet to\r\n# install rustup. It just does platform detection, downloads the installer\r\n# and runs it.\r\n\r\n# It runs on Unix shells like {a,ba,da,k,z}sh. It uses the common `local`\r\n# extension. Note: Most shells limit `local` to 1 var per line, contra bash.\r\n\r\nif [ \"$KSH_VERSION\" = 'Version JM 93t+ 2010-03-05' ]; then\r\n    # The version of ksh93 that ships with many illumos systems does not\r\n    # support the \"local\" extension.  Print a message rather than fail in\r\n    # subtle ways later on:\r\n    echo 'rustup does not work with this ksh93 version; please try bash!' >&2\r\n    exit 1\r\nfi\r\n\r\n\r\nset -u\r\n\r\n# If RUSTUP_UPDATE_ROOT is unset or empty, default it.\r\nRUSTUP_UPDATE_ROOT=\"${RUSTUP_UPDATE_ROOT:-https://static.rust-lang.org/rustup}\"\r\n\r\n#XXX: If you change anything here, please make the same changes in setup_mode.rs\r\nusage() {\r\n    cat 1>&2 <<EOF\r\nrustup-init 1.25.1 (48d233f65 2022-07-12)\r\nThe installer for rustup\r\n\r\nUSAGE:\r\n    rustup-init [FLAGS] [OPTIONS]\r\n\r\nFLAGS:\r\n    -v, --verbose           Enable verbose output\r\n    -q, --quiet             Disable progress output\r\n    -y                      Disable confirmation prompt.\r\n        --no-modify-path    Don't configure the PATH environment variable\r\n    -h, --help              Prints help information\r\n    -V, --version           Prints version information\r\n\r\nOPTIONS:\r\n        --default-host <default-host>              Choose a default host triple\r\n        --default-toolchain <default-toolchain>    Choose a default toolchain to install\r\n        --default-toolchain none                   Do not install any toolchains\r\n        --profile [minimal|default|complete]       Choose a profile\r\n    -c, --component <components>...                Component name to also install\r\n    -t, --target <targets>...                      Target name to also install\r\nEOF\r\n}\r\n\r\nmain() {\r\n    downloader --check\r\n    need_cmd uname\r\n    need_cmd mktemp\r\n    need_cmd chmod\r\n    need_cmd mkdir\r\n    need_cmd rm\r\n    need_cmd rmdir\r\n\r\n    get_architecture || return 1\r\n    local _arch=\"$RETVAL\"\r\n    assert_nz \"$_arch\" \"arch\"\r\n\r\n    local _ext=\"\"\r\n    case \"$_arch\" in\r\n        *windows*)\r\n            _ext=\".exe\"\r\n            ;;\r\n    esac\r\n\r\n    local _url=\"${RUSTUP_UPDATE_ROOT}/dist/${_arch}/rustup-init${_ext}\"\r\n\r\n    local _dir\r\n    _dir=\"$(ensure mktemp -d)\"\r\n    local _file=\"${_dir}/rustup-init${_ext}\"\r\n\r\n    local _ansi_escapes_are_valid=false\r\n    if [ -t 2 ]; then\r\n        if [ \"${TERM+set}\" = 'set' ]; then\r\n            case \"$TERM\" in\r\n                xterm*|rxvt*|urxvt*|linux*|vt*)\r\n                    _ansi_escapes_are_valid=true\r\n                ;;\r\n            esac\r\n        fi\r\n    fi\r\n\r\n    # check if we have to use /dev/tty to prompt the user\r\n    local need_tty=yes\r\n    for arg in \"$@\"; do\r\n        case \"$arg\" in\r\n            --help)\r\n                usage\r\n                exit 0\r\n                ;;\r\n            *)\r\n                OPTIND=1\r\n                if [ \"${arg%%--*}\" = \"\" ]; then\r\n                    # Long option (other than --help);\r\n                    # don't attempt to interpret it.\r\n                    continue\r\n                fi\r\n                while getopts :hy sub_arg \"$arg\"; do\r\n                    case \"$sub_arg\" in\r\n                        h)\r\n                            usage\r\n                            exit 0\r\n                            ;;\r\n                        y)\r\n                            # user wants to skip the prompt --\r\n                            # we don't need /dev/tty\r\n                            need_tty=no\r\n                            ;;\r\n                        *)\r\n                            ;;\r\n                        esac\r\n                done\r\n                ;;\r\n        esac\r\n    done\r\n\r\n    if $_ansi_escapes_are_valid; then\r\n        printf \"\\33[1minfo:\\33[0m downloading installer\\n\" 1>&2\r\n    else\r\n        printf '%s\\n' 'info: downloading installer' 1>&2\r\n    fi\r\n\r\n    ensure mkdir -p \"$_dir\"\r\n    ensure downloader \"$_url\" \"$_file\" \"$_arch\"\r\n    ensure chmod u+x \"$_file\"\r\n    if [ ! -x \"$_file\" ]; then\r\n        printf '%s\\n' \"Cannot execute $_file (likely because of mounting /tmp as noexec).\" 1>&2\r\n        printf '%s\\n' \"Please copy the file to a location where you can execute binaries and run ./rustup-init${_ext}.\" 1>&2\r\n        exit 1\r\n    fi\r\n\r\n    if [ \"$need_tty\" = \"yes\" ] && [ ! -t 0 ]; then\r\n        # The installer is going to want to ask for confirmation by\r\n        # reading stdin.  This script was piped into `sh` though and\r\n        # doesn't have stdin to pass to its children. Instead we're going\r\n        # to explicitly connect /dev/tty to the installer's stdin.\r\n        if [ ! -t 1 ]; then\r\n            err \"Unable to run interactively. Run with -y to accept defaults, --help for additional options\"\r\n        fi\r\n\r\n        ignore \"$_file\" \"$@\" < /dev/tty\r\n    else\r\n        ignore \"$_file\" \"$@\"\r\n    fi\r\n\r\n    local _retval=$?\r\n\r\n    ignore rm \"$_file\"\r\n    ignore rmdir \"$_dir\"\r\n\r\n    return \"$_retval\"\r\n}\r\n\r\ncheck_proc() {\r\n    # Check for /proc by looking for the /proc/self/exe link\r\n    # This is only run on Linux\r\n    if ! test -L /proc/self/exe ; then\r\n        err \"fatal: Unable to find /proc/self/exe.  Is /proc mounted?  Installation cannot proceed without /proc.\"\r\n    fi\r\n}\r\n\r\nget_bitness() {\r\n    need_cmd head\r\n    # Architecture detection without dependencies beyond coreutils.\r\n    # ELF files start out \"\\x7fELF\", and the following byte is\r\n    #   0x01 for 32-bit and\r\n    #   0x02 for 64-bit.\r\n    # The printf builtin on some shells like dash only supports octal\r\n    # escape sequences, so we use those.\r\n    local _current_exe_head\r\n    _current_exe_head=$(head -c 5 /proc/self/exe )\r\n    if [ \"$_current_exe_head\" = \"$(printf '\\177ELF\\001')\" ]; then\r\n        echo 32\r\n    elif [ \"$_current_exe_head\" = \"$(printf '\\177ELF\\002')\" ]; then\r\n        echo 64\r\n    else\r\n        err \"unknown platform bitness\"\r\n    fi\r\n}\r\n\r\nis_host_amd64_elf() {\r\n    need_cmd head\r\n    need_cmd tail\r\n    # ELF e_machine detection without dependencies beyond coreutils.\r\n    # Two-byte field at offset 0x12 indicates the CPU,\r\n    # but we're interested in it being 0x3E to indicate amd64, or not that.\r\n    local _current_exe_machine\r\n    _current_exe_machine=$(head -c 19 /proc/self/exe | tail -c 1)\r\n    [ \"$_current_exe_machine\" = \"$(printf '\\076')\" ]\r\n}\r\n\r\nget_endianness() {\r\n    local cputype=$1\r\n    local suffix_eb=$2\r\n    local suffix_el=$3\r\n\r\n    # detect endianness without od/hexdump, like get_bitness() does.\r\n    need_cmd head\r\n    need_cmd tail\r\n\r\n    local _current_exe_endianness\r\n    _current_exe_endianness=\"$(head -c 6 /proc/self/exe | tail -c 1)\"\r\n    if [ \"$_current_exe_endianness\" = \"$(printf '\\001')\" ]; then\r\n        echo \"${cputype}${suffix_el}\"\r\n    elif [ \"$_current_exe_endianness\" = \"$(printf '\\002')\" ]; then\r\n        echo \"${cputype}${suffix_eb}\"\r\n    else\r\n        err \"unknown platform endianness\"\r\n    fi\r\n}\r\n\r\nget_architecture() {\r\n    local _ostype _cputype _bitness _arch _clibtype\r\n    _ostype=\"$(uname -s)\"\r\n    _cputype=\"$(uname -m)\"\r\n    _clibtype=\"gnu\"\r\n\r\n    if [ \"$_ostype\" = Linux ]; then\r\n        if [ \"$(uname -o)\" = Android ]; then\r\n            _ostype=Android\r\n        fi\r\n        if ldd --version 2>&1 | grep -q 'musl'; then\r\n            _clibtype=\"musl\"\r\n        fi\r\n    fi\r\n\r\n    if [ \"$_ostype\" = Darwin ] && [ \"$_cputype\" = i386 ]; then\r\n        # Darwin `uname -m` lies\r\n        if sysctl hw.optional.x86_64 | grep -q ': 1'; then\r\n            _cputype=x86_64\r\n        fi\r\n    fi\r\n\r\n    if [ \"$_ostype\" = SunOS ]; then\r\n        # Both Solaris and illumos presently announce as \"SunOS\" in \"uname -s\"\r\n        # so use \"uname -o\" to disambiguate.  We use the full path to the\r\n        # system uname in case the user has coreutils uname first in PATH,\r\n        # which has historically sometimes printed the wrong value here.\r\n        if [ \"$(/usr/bin/uname -o)\" = illumos ]; then\r\n            _ostype=illumos\r\n        fi\r\n\r\n        # illumos systems have multi-arch userlands, and \"uname -m\" reports the\r\n        # machine hardware name; e.g., \"i86pc\" on both 32- and 64-bit x86\r\n        # systems.  Check for the native (widest) instruction set on the\r\n        # running kernel:\r\n        if [ \"$_cputype\" = i86pc ]; then\r\n            _cputype=\"$(isainfo -n)\"\r\n        fi\r\n    fi\r\n\r\n    case \"$_ostype\" in\r\n\r\n        Android)\r\n            _ostype=linux-android\r\n            ;;\r\n\r\n        Linux)\r\n            check_proc\r\n            _ostype=unknown-linux-$_clibtype\r\n            _bitness=$(get_bitness)\r\n            ;;\r\n\r\n        FreeBSD)\r\n            _ostype=unknown-freebsd\r\n            ;;\r\n\r\n        NetBSD)\r\n            _ostype=unknown-netbsd\r\n            ;;\r\n\r\n        DragonFly)\r\n            _ostype=unknown-dragonfly\r\n            ;;\r\n\r\n        Darwin)\r\n            _ostype=apple-darwin\r\n            ;;\r\n\r\n        illumos)\r\n            _ostype=unknown-illumos\r\n            ;;\r\n\r\n        MINGW* | MSYS* | CYGWIN* | Windows_NT)\r\n            _ostype=pc-windows-gnu\r\n            ;;\r\n\r\n        *)\r\n            err \"unrecognized OS type: $_ostype\"\r\n            ;;\r\n\r\n    esac\r\n\r\n    case \"$_cputype\" in\r\n\r\n        i386 | i486 | i686 | i786 | x86)\r\n            _cputype=i686\r\n            ;;\r\n\r\n        xscale | arm)\r\n            _cputype=arm\r\n            if [ \"$_ostype\" = \"linux-android\" ]; then\r\n                _ostype=linux-androideabi\r\n            fi\r\n            ;;\r\n\r\n        armv6l)\r\n            _cputype=arm\r\n            if [ \"$_ostype\" = \"linux-android\" ]; then\r\n                _ostype=linux-androideabi\r\n            else\r\n                _ostype=\"${_ostype}eabihf\"\r\n            fi\r\n            ;;\r\n\r\n        armv7l | armv8l)\r\n            _cputype=armv7\r\n            if [ \"$_ostype\" = \"linux-android\" ]; then\r\n                _ostype=linux-androideabi\r\n            else\r\n                _ostype=\"${_ostype}eabihf\"\r\n            fi\r\n            ;;\r\n\r\n        aarch64 | arm64)\r\n            _cputype=aarch64\r\n            ;;\r\n\r\n        x86_64 | x86-64 | x64 | amd64)\r\n            _cputype=x86_64\r\n            ;;\r\n\r\n        mips)\r\n            _cputype=$(get_endianness mips '' el)\r\n            ;;\r\n\r\n        mips64)\r\n            if [ \"$_bitness\" -eq 64 ]; then\r\n                # only n64 ABI is supported for now\r\n                _ostype=\"${_ostype}abi64\"\r\n                _cputype=$(get_endianness mips64 '' el)\r\n            fi\r\n            ;;\r\n\r\n        ppc)\r\n            _cputype=powerpc\r\n            ;;\r\n\r\n        ppc64)\r\n            _cputype=powerpc64\r\n            ;;\r\n\r\n        ppc64le)\r\n            _cputype=powerpc64le\r\n            ;;\r\n\r\n        s390x)\r\n            _cputype=s390x\r\n            ;;\r\n        riscv64)\r\n            _cputype=riscv64gc\r\n            ;;\r\n        *)\r\n            err \"unknown CPU type: $_cputype\"\r\n\r\n    esac\r\n\r\n    # Detect 64-bit linux with 32-bit userland\r\n    if [ \"${_ostype}\" = unknown-linux-gnu ] && [ \"${_bitness}\" -eq 32 ]; then\r\n        case $_cputype in\r\n            x86_64)\r\n                if [ -n \"${RUSTUP_CPUTYPE:-}\" ]; then\r\n                    _cputype=\"$RUSTUP_CPUTYPE\"\r\n                else {\r\n                    # 32-bit executable for amd64 = x32\r\n                    if is_host_amd64_elf; then {\r\n                         echo \"This host is running an x32 userland; as it stands, x32 support is poor,\" 1>&2\r\n                         echo \"and there isn't a native toolchain -- you will have to install\" 1>&2\r\n                         echo \"multiarch compatibility with i686 and/or amd64, then select one\" 1>&2\r\n                         echo \"by re-running this script with the RUSTUP_CPUTYPE environment variable\" 1>&2\r\n                         echo \"set to i686 or x86_64, respectively.\" 1>&2\r\n                         echo 1>&2\r\n                         echo \"You will be able to add an x32 target after installation by running\" 1>&2\r\n                         echo \"  rustup target add x86_64-unknown-linux-gnux32\" 1>&2\r\n                         exit 1\r\n                    }; else\r\n                        _cputype=i686\r\n                    fi\r\n                }; fi\r\n                ;;\r\n            mips64)\r\n                _cputype=$(get_endianness mips '' el)\r\n                ;;\r\n            powerpc64)\r\n                _cputype=powerpc\r\n                ;;\r\n            aarch64)\r\n                _cputype=armv7\r\n                if [ \"$_ostype\" = \"linux-android\" ]; then\r\n                    _ostype=linux-androideabi\r\n                else\r\n                    _ostype=\"${_ostype}eabihf\"\r\n                fi\r\n                ;;\r\n            riscv64gc)\r\n                err \"riscv64 with 32-bit userland unsupported\"\r\n                ;;\r\n        esac\r\n    fi\r\n\r\n    # Detect armv7 but without the CPU features Rust needs in that build,\r\n    # and fall back to arm.\r\n    # See https://github.com/rust-lang/rustup.rs/issues/587.\r\n    if [ \"$_ostype\" = \"unknown-linux-gnueabihf\" ] && [ \"$_cputype\" = armv7 ]; then\r\n        if ensure grep '^Features' /proc/cpuinfo | grep -q -v neon; then\r\n            # At least one processor does not have NEON.\r\n            _cputype=arm\r\n        fi\r\n    fi\r\n\r\n    _arch=\"${_cputype}-${_ostype}\"\r\n\r\n    RETVAL=\"$_arch\"\r\n}\r\n\r\nsay() {\r\n    printf 'rustup: %s\\n' \"$1\"\r\n}\r\n\r\nerr() {\r\n    say \"$1\" >&2\r\n    exit 1\r\n}\r\n\r\nneed_cmd() {\r\n    if ! check_cmd \"$1\"; then\r\n        err \"need '$1' (command not found)\"\r\n    fi\r\n}\r\n\r\ncheck_cmd() {\r\n    command -v \"$1\" > /dev/null 2>&1\r\n}\r\n\r\nassert_nz() {\r\n    if [ -z \"$1\" ]; then err \"assert_nz $2\"; fi\r\n}\r\n\r\n# Run a command that should never fail. If the command fails execution\r\n# will immediately terminate with an error showing the failing\r\n# command.\r\nensure() {\r\n    if ! \"$@\"; then err \"command failed: $*\"; fi\r\n}\r\n\r\n# This is just for indicating that commands' results are being\r\n# intentionally ignored. Usually, because it's being executed\r\n# as part of error handling.\r\nignore() {\r\n    \"$@\"\r\n}\r\n\r\n# This wraps curl or wget. Try curl first, if not installed,\r\n# use wget instead.\r\ndownloader() {\r\n    local _dld\r\n    local _ciphersuites\r\n    local _err\r\n    local _status\r\n    local _retry\r\n    if check_cmd curl; then\r\n        _dld=curl\r\n    elif check_cmd wget; then\r\n        _dld=wget\r\n    else\r\n        _dld='curl or wget' # to be used in error message of need_cmd\r\n    fi\r\n\r\n    if [ \"$1\" = --check ]; then\r\n        need_cmd \"$_dld\"\r\n    elif [ \"$_dld\" = curl ]; then\r\n        check_curl_for_retry_support\r\n        _retry=\"$RETVAL\"\r\n        get_ciphersuites_for_curl\r\n        _ciphersuites=\"$RETVAL\"\r\n        if [ -n \"$_ciphersuites\" ]; then\r\n            _err=$(curl $_retry --proto '=https' --tlsv1.2 --ciphers \"$_ciphersuites\" --silent --show-error --fail --location \"$1\" --output \"$2\" 2>&1)\r\n            _status=$?\r\n        else\r\n            echo \"Warning: Not enforcing strong cipher suites for TLS, this is potentially less secure\"\r\n            if ! check_help_for \"$3\" curl --proto --tlsv1.2; then\r\n                echo \"Warning: Not enforcing TLS v1.2, this is potentially less secure\"\r\n                _err=$(curl $_retry --silent --show-error --fail --location \"$1\" --output \"$2\" 2>&1)\r\n                _status=$?\r\n            else\r\n                _err=$(curl $_retry --proto '=https' --tlsv1.2 --silent --show-error --fail --location \"$1\" --output \"$2\" 2>&1)\r\n                _status=$?\r\n            fi\r\n        fi\r\n        if [ -n \"$_err\" ]; then\r\n            echo \"$_err\" >&2\r\n            if echo \"$_err\" | grep -q 404$; then\r\n                err \"installer for platform '$3' not found, this may be unsupported\"\r\n            fi\r\n        fi\r\n        return $_status\r\n    elif [ \"$_dld\" = wget ]; then\r\n        if [ \"$(wget -V 2>&1|head -2|tail -1|cut -f1 -d\" \")\" = \"BusyBox\" ]; then\r\n            echo \"Warning: using the BusyBox version of wget.  Not enforcing strong cipher suites for TLS or TLS v1.2, this is potentially less secure\"\r\n            _err=$(wget \"$1\" -O \"$2\" 2>&1)\r\n            _status=$?\r\n        else\r\n            get_ciphersuites_for_wget\r\n            _ciphersuites=\"$RETVAL\"\r\n            if [ -n \"$_ciphersuites\" ]; then\r\n                _err=$(wget --https-only --secure-protocol=TLSv1_2 --ciphers \"$_ciphersuites\" \"$1\" -O \"$2\" 2>&1)\r\n                _status=$?\r\n            else\r\n                echo \"Warning: Not enforcing strong cipher suites for TLS, this is potentially less secure\"\r\n                if ! check_help_for \"$3\" wget --https-only --secure-protocol; then\r\n                    echo \"Warning: Not enforcing TLS v1.2, this is potentially less secure\"\r\n                    _err=$(wget \"$1\" -O \"$2\" 2>&1)\r\n                    _status=$?\r\n                else\r\n                    _err=$(wget --https-only --secure-protocol=TLSv1_2 \"$1\" -O \"$2\" 2>&1)\r\n                    _status=$?\r\n                fi\r\n            fi\r\n        fi\r\n        if [ -n \"$_err\" ]; then\r\n            echo \"$_err\" >&2\r\n            if echo \"$_err\" | grep -q ' 404 Not Found$'; then\r\n                err \"installer for platform '$3' not found, this may be unsupported\"\r\n            fi\r\n        fi\r\n        return $_status\r\n    else\r\n        err \"Unknown downloader\"   # should not reach here\r\n    fi\r\n}\r\n\r\ncheck_help_for() {\r\n    local _arch\r\n    local _cmd\r\n    local _arg\r\n    _arch=\"$1\"\r\n    shift\r\n    _cmd=\"$1\"\r\n    shift\r\n\r\n    local _category\r\n    if \"$_cmd\" --help | grep -q 'For all options use the manual or \"--help all\".'; then\r\n      _category=\"all\"\r\n    else\r\n      _category=\"\"\r\n    fi\r\n\r\n    case \"$_arch\" in\r\n\r\n        *darwin*)\r\n        if check_cmd sw_vers; then\r\n            case $(sw_vers -productVersion) in\r\n                10.*)\r\n                    # If we're running on macOS, older than 10.13, then we always\r\n                    # fail to find these options to force fallback\r\n                    if [ \"$(sw_vers -productVersion | cut -d. -f2)\" -lt 13 ]; then\r\n                        # Older than 10.13\r\n                        echo \"Warning: Detected macOS platform older than 10.13\"\r\n                        return 1\r\n                    fi\r\n                    ;;\r\n                11.*)\r\n                    # We assume Big Sur will be OK for now\r\n                    ;;\r\n                *)\r\n                    # Unknown product version, warn and continue\r\n                    echo \"Warning: Detected unknown macOS major version: $(sw_vers -productVersion)\"\r\n                    echo \"Warning TLS capabilities detection may fail\"\r\n                    ;;\r\n            esac\r\n        fi\r\n        ;;\r\n\r\n    esac\r\n\r\n    for _arg in \"$@\"; do\r\n        if ! \"$_cmd\" --help $_category | grep -q -- \"$_arg\"; then\r\n            return 1\r\n        fi\r\n    done\r\n\r\n    true # not strictly needed\r\n}\r\n\r\n# Check if curl supports the --retry flag, then pass it to the curl invocation.\r\ncheck_curl_for_retry_support() {\r\n  local _retry_supported=\"\"\r\n  # \"unspecified\" is for arch, allows for possibility old OS using macports, homebrew, etc.\r\n  if check_help_for \"notspecified\" \"curl\" \"--retry\"; then\r\n    _retry_supported=\"--retry 3\"\r\n  fi\r\n\r\n  RETVAL=\"$_retry_supported\"\r\n\r\n}\r\n\r\n# Return cipher suite string specified by user, otherwise return strong TLS 1.2-1.3 cipher suites\r\n# if support by local tools is detected. Detection currently supports these curl backends:\r\n# GnuTLS and OpenSSL (possibly also LibreSSL and BoringSSL). Return value can be empty.\r\nget_ciphersuites_for_curl() {\r\n    if [ -n \"${RUSTUP_TLS_CIPHERSUITES-}\" ]; then\r\n        # user specified custom cipher suites, assume they know what they're doing\r\n        RETVAL=\"$RUSTUP_TLS_CIPHERSUITES\"\r\n        return\r\n    fi\r\n\r\n    local _openssl_syntax=\"no\"\r\n    local _gnutls_syntax=\"no\"\r\n    local _backend_supported=\"yes\"\r\n    if curl -V | grep -q ' OpenSSL/'; then\r\n        _openssl_syntax=\"yes\"\r\n    elif curl -V | grep -iq ' LibreSSL/'; then\r\n        _openssl_syntax=\"yes\"\r\n    elif curl -V | grep -iq ' BoringSSL/'; then\r\n        _openssl_syntax=\"yes\"\r\n    elif curl -V | grep -iq ' GnuTLS/'; then\r\n        _gnutls_syntax=\"yes\"\r\n    else\r\n        _backend_supported=\"no\"\r\n    fi\r\n\r\n    local _args_supported=\"no\"\r\n    if [ \"$_backend_supported\" = \"yes\" ]; then\r\n        # \"unspecified\" is for arch, allows for possibility old OS using macports, homebrew, etc.\r\n        if check_help_for \"notspecified\" \"curl\" \"--tlsv1.2\" \"--ciphers\" \"--proto\"; then\r\n            _args_supported=\"yes\"\r\n        fi\r\n    fi\r\n\r\n    local _cs=\"\"\r\n    if [ \"$_args_supported\" = \"yes\" ]; then\r\n        if [ \"$_openssl_syntax\" = \"yes\" ]; then\r\n            _cs=$(get_strong_ciphersuites_for \"openssl\")\r\n        elif [ \"$_gnutls_syntax\" = \"yes\" ]; then\r\n            _cs=$(get_strong_ciphersuites_for \"gnutls\")\r\n        fi\r\n    fi\r\n\r\n    RETVAL=\"$_cs\"\r\n}\r\n\r\n# Return cipher suite string specified by user, otherwise return strong TLS 1.2-1.3 cipher suites\r\n# if support by local tools is detected. Detection currently supports these wget backends:\r\n# GnuTLS and OpenSSL (possibly also LibreSSL and BoringSSL). Return value can be empty.\r\nget_ciphersuites_for_wget() {\r\n    if [ -n \"${RUSTUP_TLS_CIPHERSUITES-}\" ]; then\r\n        # user specified custom cipher suites, assume they know what they're doing\r\n        RETVAL=\"$RUSTUP_TLS_CIPHERSUITES\"\r\n        return\r\n    fi\r\n\r\n    local _cs=\"\"\r\n    if wget -V | grep -q '\\-DHAVE_LIBSSL'; then\r\n        # \"unspecified\" is for arch, allows for possibility old OS using macports, homebrew, etc.\r\n        if check_help_for \"notspecified\" \"wget\" \"TLSv1_2\" \"--ciphers\" \"--https-only\" \"--secure-protocol\"; then\r\n            _cs=$(get_strong_ciphersuites_for \"openssl\")\r\n        fi\r\n    elif wget -V | grep -q '\\-DHAVE_LIBGNUTLS'; then\r\n        # \"unspecified\" is for arch, allows for possibility old OS using macports, homebrew, etc.\r\n        if check_help_for \"notspecified\" \"wget\" \"TLSv1_2\" \"--ciphers\" \"--https-only\" \"--secure-protocol\"; then\r\n            _cs=$(get_strong_ciphersuites_for \"gnutls\")\r\n        fi\r\n    fi\r\n\r\n    RETVAL=\"$_cs\"\r\n}\r\n\r\n# Return strong TLS 1.2-1.3 cipher suites in OpenSSL or GnuTLS syntax. TLS 1.2\r\n# excludes non-ECDHE and non-AEAD cipher suites. DHE is excluded due to bad\r\n# DH params often found on servers (see RFC 7919). Sequence matches or is\r\n# similar to Firefox 68 ESR with weak cipher suites disabled via about:config.\r\n# $1 must be openssl or gnutls.\r\nget_strong_ciphersuites_for() {\r\n    if [ \"$1\" = \"openssl\" ]; then\r\n        # OpenSSL is forgiving of unknown values, no problems with TLS 1.3 values on versions that don't support it yet.\r\n        echo \"TLS_AES_128_GCM_SHA256:TLS_CHACHA20_POLY1305_SHA256:TLS_AES_256_GCM_SHA384:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384\"\r\n    elif [ \"$1\" = \"gnutls\" ]; then\r\n        # GnuTLS isn't forgiving of unknown values, so this may require a GnuTLS version that supports TLS 1.3 even if wget doesn't.\r\n        # Begin with SECURE128 (and higher) then remove/add to build cipher suites. Produces same 9 cipher suites as OpenSSL but in slightly different order.\r\n        echo \"SECURE128:-VERS-SSL3.0:-VERS-TLS1.0:-VERS-TLS1.1:-VERS-DTLS-ALL:-CIPHER-ALL:-MAC-ALL:-KX-ALL:+AEAD:+ECDHE-ECDSA:+ECDHE-RSA:+AES-128-GCM:+CHACHA20-POLY1305:+AES-256-GCM\"\r\n    fi\r\n}\r\n\r\nmain \"$@\" || exit 1\r\ncurl: (6) Could not resolve host: |\r\ncurl: (6) Could not resolve host: sh", "stdout_lines": ["#!/bin/sh", "# shellcheck shell=dash", "", "# This is just a little script that can be downloaded from the internet to", "# install rustup. It just does platform detection, downloads the installer", "# and runs it.", "", "# It runs on Unix shells like {a,ba,da,k,z}sh. It uses the common `local`", "# extension. Note: Most shells limit `local` to 1 var per line, contra bash.", "", "if [ \"$KSH_VERSION\" = 'Version JM 93t+ 2010-03-05' ]; then", "    # The version of ksh93 that ships with many illumos systems does not", "    # support the \"local\" extension.  Print a message rather than fail in", "    # subtle ways later on:", "    echo 'rustup does not work with this ksh93 version; please try bash!' >&2", "    exit 1", "fi", "", "", "set -u", "", "# If RUSTUP_UPDATE_ROOT is unset or empty, default it.", "RUSTUP_UPDATE_ROOT=\"${RUSTUP_UPDATE_ROOT:-https://static.rust-lang.org/rustup}\"", "", "#XXX: If you change anything here, please make the same changes in setup_mode.rs", "usage() {", "    cat 1>&2 <<EOF", "rustup-init 1.25.1 (48d233f65 2022-07-12)", "The installer for rustup", "", "USAGE:", "    rustup-init [FLAGS] [OPTIONS]", "", "FLAGS:", "    -v, --verbose           Enable verbose output", "    -q, --quiet             Disable progress output", "    -y                      Disable confirmation prompt.", "        --no-modify-path    Don't configure the PATH environment variable", "    -h, --help              Prints help information", "    -V, --version           Prints version information", "", "OPTIONS:", "        --default-host <default-host>              Choose a default host triple", "        --default-toolchain <default-toolchain>    Choose a default toolchain to install", "        --default-toolchain none                   Do not install any toolchains", "        --profile [minimal|default|complete]       Choose a profile", "    -c, --component <components>...                Component name to also install", "    -t, --target <targets>...                      Target name to also install", "EOF", "}", "", "main() {", "    downloader --check", "    need_cmd uname", "    need_cmd mktemp", "    need_cmd chmod", "    need_cmd mkdir", "    need_cmd rm", "    need_cmd rmdir", "", "    get_architecture || return 1", "    local _arch=\"$RETVAL\"", "    assert_nz \"$_arch\" \"arch\"", "", "    local _ext=\"\"", "    case \"$_arch\" in", "        *windows*)", "            _ext=\".exe\"", "            ;;", "    esac", "", "    local _url=\"${RUSTUP_UPDATE_ROOT}/dist/${_arch}/rustup-init${_ext}\"", "", "    local _dir", "    _dir=\"$(ensure mktemp -d)\"", "    local _file=\"${_dir}/rustup-init${_ext}\"", "", "    local _ansi_escapes_are_valid=false", "    if [ -t 2 ]; then", "        if [ \"${TERM+set}\" = 'set' ]; then", "            case \"$TERM\" in", "                xterm*|rxvt*|urxvt*|linux*|vt*)", "                    _ansi_escapes_are_valid=true", "                ;;", "            esac", "        fi", "    fi", "", "    # check if we have to use /dev/tty to prompt the user", "    local need_tty=yes", "    for arg in \"$@\"; do", "        case \"$arg\" in", "            --help)", "                usage", "                exit 0", "                ;;", "            *)", "                OPTIND=1", "                if [ \"${arg%%--*}\" = \"\" ]; then", "                    # Long option (other than --help);", "                    # don't attempt to interpret it.", "                    continue", "                fi", "                while getopts :hy sub_arg \"$arg\"; do", "                    case \"$sub_arg\" in", "                        h)", "                            usage", "                            exit 0", "                            ;;", "                        y)", "                            # user wants to skip the prompt --", "                            # we don't need /dev/tty", "                            need_tty=no", "                            ;;", "                        *)", "                            ;;", "                        esac", "                done", "                ;;", "        esac", "    done", "", "    if $_ansi_escapes_are_valid; then", "        printf \"\\33[1minfo:\\33[0m downloading installer\\n\" 1>&2", "    else", "        printf '%s\\n' 'info: downloading installer' 1>&2", "    fi", "", "    ensure mkdir -p \"$_dir\"", "    ensure downloader \"$_url\" \"$_file\" \"$_arch\"", "    ensure chmod u+x \"$_file\"", "    if [ ! -x \"$_file\" ]; then", "        printf '%s\\n' \"Cannot execute $_file (likely because of mounting /tmp as noexec).\" 1>&2", "        printf '%s\\n' \"Please copy the file to a location where you can execute binaries and run ./rustup-init${_ext}.\" 1>&2", "        exit 1", "    fi", "", "    if [ \"$need_tty\" = \"yes\" ] && [ ! -t 0 ]; then", "        # The installer is going to want to ask for confirmation by", "        # reading stdin.  This script was piped into `sh` though and", "        # doesn't have stdin to pass to its children. Instead we're going", "        # to explicitly connect /dev/tty to the installer's stdin.", "        if [ ! -t 1 ]; then", "            err \"Unable to run interactively. Run with -y to accept defaults, --help for additional options\"", "        fi", "", "        ignore \"$_file\" \"$@\" < /dev/tty", "    else", "        ignore \"$_file\" \"$@\"", "    fi", "", "    local _retval=$?", "", "    ignore rm \"$_file\"", "    ignore rmdir \"$_dir\"", "", "    return \"$_retval\"", "}", "", "check_proc() {", "    # Check for /proc by looking for the /proc/self/exe link", "    # This is only run on Linux", "    if ! test -L /proc/self/exe ; then", "        err \"fatal: Unable to find /proc/self/exe.  Is /proc mounted?  Installation cannot proceed without /proc.\"", "    fi", "}", "", "get_bitness() {", "    need_cmd head", "    # Architecture detection without dependencies beyond coreutils.", "    # ELF files start out \"\\x7fELF\", and the following byte is", "    #   0x01 for 32-bit and", "    #   0x02 for 64-bit.", "    # The printf builtin on some shells like dash only supports octal", "    # escape sequences, so we use those.", "    local _current_exe_head", "    _current_exe_head=$(head -c 5 /proc/self/exe )", "    if [ \"$_current_exe_head\" = \"$(printf '\\177ELF\\001')\" ]; then", "        echo 32", "    elif [ \"$_current_exe_head\" = \"$(printf '\\177ELF\\002')\" ]; then", "        echo 64", "    else", "        err \"unknown platform bitness\"", "    fi", "}", "", "is_host_amd64_elf() {", "    need_cmd head", "    need_cmd tail", "    # ELF e_machine detection without dependencies beyond coreutils.", "    # Two-byte field at offset 0x12 indicates the CPU,", "    # but we're interested in it being 0x3E to indicate amd64, or not that.", "    local _current_exe_machine", "    _current_exe_machine=$(head -c 19 /proc/self/exe | tail -c 1)", "    [ \"$_current_exe_machine\" = \"$(printf '\\076')\" ]", "}", "", "get_endianness() {", "    local cputype=$1", "    local suffix_eb=$2", "    local suffix_el=$3", "", "    # detect endianness without od/hexdump, like get_bitness() does.", "    need_cmd head", "    need_cmd tail", "", "    local _current_exe_endianness", "    _current_exe_endianness=\"$(head -c 6 /proc/self/exe | tail -c 1)\"", "    if [ \"$_current_exe_endianness\" = \"$(printf '\\001')\" ]; then", "        echo \"${cputype}${suffix_el}\"", "    elif [ \"$_current_exe_endianness\" = \"$(printf '\\002')\" ]; then", "        echo \"${cputype}${suffix_eb}\"", "    else", "        err \"unknown platform endianness\"", "    fi", "}", "", "get_architecture() {", "    local _ostype _cputype _bitness _arch _clibtype", "    _ostype=\"$(uname -s)\"", "    _cputype=\"$(uname -m)\"", "    _clibtype=\"gnu\"", "", "    if [ \"$_ostype\" = Linux ]; then", "        if [ \"$(uname -o)\" = Android ]; then", "            _ostype=Android", "        fi", "        if ldd --version 2>&1 | grep -q 'musl'; then", "            _clibtype=\"musl\"", "        fi", "    fi", "", "    if [ \"$_ostype\" = Darwin ] && [ \"$_cputype\" = i386 ]; then", "        # Darwin `uname -m` lies", "        if sysctl hw.optional.x86_64 | grep -q ': 1'; then", "            _cputype=x86_64", "        fi", "    fi", "", "    if [ \"$_ostype\" = SunOS ]; then", "        # Both Solaris and illumos presently announce as \"SunOS\" in \"uname -s\"", "        # so use \"uname -o\" to disambiguate.  We use the full path to the", "        # system uname in case the user has coreutils uname first in PATH,", "        # which has historically sometimes printed the wrong value here.", "        if [ \"$(/usr/bin/uname -o)\" = illumos ]; then", "            _ostype=illumos", "        fi", "", "        # illumos systems have multi-arch userlands, and \"uname -m\" reports the", "        # machine hardware name; e.g., \"i86pc\" on both 32- and 64-bit x86", "        # systems.  Check for the native (widest) instruction set on the", "        # running kernel:", "        if [ \"$_cputype\" = i86pc ]; then", "            _cputype=\"$(isainfo -n)\"", "        fi", "    fi", "", "    case \"$_ostype\" in", "", "        Android)", "            _ostype=linux-android", "            ;;", "", "        Linux)", "            check_proc", "            _ostype=unknown-linux-$_clibtype", "            _bitness=$(get_bitness)", "            ;;", "", "        FreeBSD)", "            _ostype=unknown-freebsd", "            ;;", "", "        NetBSD)", "            _ostype=unknown-netbsd", "            ;;", "", "        DragonFly)", "            _ostype=unknown-dragonfly", "            ;;", "", "        Darwin)", "            _ostype=apple-darwin", "            ;;", "", "        illumos)", "            _ostype=unknown-illumos", "            ;;", "", "        MINGW* | MSYS* | CYGWIN* | Windows_NT)", "            _ostype=pc-windows-gnu", "            ;;", "", "        *)", "            err \"unrecognized OS type: $_ostype\"", "            ;;", "", "    esac", "", "    case \"$_cputype\" in", "", "        i386 | i486 | i686 | i786 | x86)", "            _cputype=i686", "            ;;", "", "        xscale | arm)", "            _cputype=arm", "            if [ \"$_ostype\" = \"linux-android\" ]; then", "                _ostype=linux-androideabi", "            fi", "            ;;", "", "        armv6l)", "            _cputype=arm", "            if [ \"$_ostype\" = \"linux-android\" ]; then", "                _ostype=linux-androideabi", "            else", "                _ostype=\"${_ostype}eabihf\"", "            fi", "            ;;", "", "        armv7l | armv8l)", "            _cputype=armv7", "            if [ \"$_ostype\" = \"linux-android\" ]; then", "                _ostype=linux-androideabi", "            else", "                _ostype=\"${_ostype}eabihf\"", "            fi", "            ;;", "", "        aarch64 | arm64)", "            _cputype=aarch64", "            ;;", "", "        x86_64 | x86-64 | x64 | amd64)", "            _cputype=x86_64", "            ;;", "", "        mips)", "            _cputype=$(get_endianness mips '' el)", "            ;;", "", "        mips64)", "            if [ \"$_bitness\" -eq 64 ]; then", "                # only n64 ABI is supported for now", "                _ostype=\"${_ostype}abi64\"", "                _cputype=$(get_endianness mips64 '' el)", "            fi", "            ;;", "", "        ppc)", "            _cputype=powerpc", "            ;;", "", "        ppc64)", "            _cputype=powerpc64", "            ;;", "", "        ppc64le)", "            _cputype=powerpc64le", "            ;;", "", "        s390x)", "            _cputype=s390x", "            ;;", "        riscv64)", "            _cputype=riscv64gc", "            ;;", "        *)", "            err \"unknown CPU type: $_cputype\"", "", "    esac", "", "    # Detect 64-bit linux with 32-bit userland", "    if [ \"${_ostype}\" = unknown-linux-gnu ] && [ \"${_bitness}\" -eq 32 ]; then", "        case $_cputype in", "            x86_64)", "                if [ -n \"${RUSTUP_CPUTYPE:-}\" ]; then", "                    _cputype=\"$RUSTUP_CPUTYPE\"", "                else {", "                    # 32-bit executable for amd64 = x32", "                    if is_host_amd64_elf; then {", "                         echo \"This host is running an x32 userland; as it stands, x32 support is poor,\" 1>&2", "                         echo \"and there isn't a native toolchain -- you will have to install\" 1>&2", "                         echo \"multiarch compatibility with i686 and/or amd64, then select one\" 1>&2", "                         echo \"by re-running this script with the RUSTUP_CPUTYPE environment variable\" 1>&2", "                         echo \"set to i686 or x86_64, respectively.\" 1>&2", "                         echo 1>&2", "                         echo \"You will be able to add an x32 target after installation by running\" 1>&2", "                         echo \"  rustup target add x86_64-unknown-linux-gnux32\" 1>&2", "                         exit 1", "                    }; else", "                        _cputype=i686", "                    fi", "                }; fi", "                ;;", "            mips64)", "                _cputype=$(get_endianness mips '' el)", "                ;;", "            powerpc64)", "                _cputype=powerpc", "                ;;", "            aarch64)", "                _cputype=armv7", "                if [ \"$_ostype\" = \"linux-android\" ]; then", "                    _ostype=linux-androideabi", "                else", "                    _ostype=\"${_ostype}eabihf\"", "                fi", "                ;;", "            riscv64gc)", "                err \"riscv64 with 32-bit userland unsupported\"", "                ;;", "        esac", "    fi", "", "    # Detect armv7 but without the CPU features Rust needs in that build,", "    # and fall back to arm.", "    # See https://github.com/rust-lang/rustup.rs/issues/587.", "    if [ \"$_ostype\" = \"unknown-linux-gnueabihf\" ] && [ \"$_cputype\" = armv7 ]; then", "        if ensure grep '^Features' /proc/cpuinfo | grep -q -v neon; then", "            # At least one processor does not have NEON.", "            _cputype=arm", "        fi", "    fi", "", "    _arch=\"${_cputype}-${_ostype}\"", "", "    RETVAL=\"$_arch\"", "}", "", "say() {", "    printf 'rustup: %s\\n' \"$1\"", "}", "", "err() {", "    say \"$1\" >&2", "    exit 1", "}", "", "need_cmd() {", "    if ! check_cmd \"$1\"; then", "        err \"need '$1' (command not found)\"", "    fi", "}", "", "check_cmd() {", "    command -v \"$1\" > /dev/null 2>&1", "}", "", "assert_nz() {", "    if [ -z \"$1\" ]; then err \"assert_nz $2\"; fi", "}", "", "# Run a command that should never fail. If the command fails execution", "# will immediately terminate with an error showing the failing", "# command.", "ensure() {", "    if ! \"$@\"; then err \"command failed: $*\"; fi", "}", "", "# This is just for indicating that commands' results are being", "# intentionally ignored. Usually, because it's being executed", "# as part of error handling.", "ignore() {", "    \"$@\"", "}", "", "# This wraps curl or wget. Try curl first, if not installed,", "# use wget instead.", "downloader() {", "    local _dld", "    local _ciphersuites", "    local _err", "    local _status", "    local _retry", "    if check_cmd curl; then", "        _dld=curl", "    elif check_cmd wget; then", "        _dld=wget", "    else", "        _dld='curl or wget' # to be used in error message of need_cmd", "    fi", "", "    if [ \"$1\" = --check ]; then", "        need_cmd \"$_dld\"", "    elif [ \"$_dld\" = curl ]; then", "        check_curl_for_retry_support", "        _retry=\"$RETVAL\"", "        get_ciphersuites_for_curl", "        _ciphersuites=\"$RETVAL\"", "        if [ -n \"$_ciphersuites\" ]; then", "            _err=$(curl $_retry --proto '=https' --tlsv1.2 --ciphers \"$_ciphersuites\" --silent --show-error --fail --location \"$1\" --output \"$2\" 2>&1)", "            _status=$?", "        else", "            echo \"Warning: Not enforcing strong cipher suites for TLS, this is potentially less secure\"", "            if ! check_help_for \"$3\" curl --proto --tlsv1.2; then", "                echo \"Warning: Not enforcing TLS v1.2, this is potentially less secure\"", "                _err=$(curl $_retry --silent --show-error --fail --location \"$1\" --output \"$2\" 2>&1)", "                _status=$?", "            else", "                _err=$(curl $_retry --proto '=https' --tlsv1.2 --silent --show-error --fail --location \"$1\" --output \"$2\" 2>&1)", "                _status=$?", "            fi", "        fi", "        if [ -n \"$_err\" ]; then", "            echo \"$_err\" >&2", "            if echo \"$_err\" | grep -q 404$; then", "                err \"installer for platform '$3' not found, this may be unsupported\"", "            fi", "        fi", "        return $_status", "    elif [ \"$_dld\" = wget ]; then", "        if [ \"$(wget -V 2>&1|head -2|tail -1|cut -f1 -d\" \")\" = \"BusyBox\" ]; then", "            echo \"Warning: using the BusyBox version of wget.  Not enforcing strong cipher suites for TLS or TLS v1.2, this is potentially less secure\"", "            _err=$(wget \"$1\" -O \"$2\" 2>&1)", "            _status=$?", "        else", "            get_ciphersuites_for_wget", "            _ciphersuites=\"$RETVAL\"", "            if [ -n \"$_ciphersuites\" ]; then", "                _err=$(wget --https-only --secure-protocol=TLSv1_2 --ciphers \"$_ciphersuites\" \"$1\" -O \"$2\" 2>&1)", "                _status=$?", "            else", "                echo \"Warning: Not enforcing strong cipher suites for TLS, this is potentially less secure\"", "                if ! check_help_for \"$3\" wget --https-only --secure-protocol; then", "                    echo \"Warning: Not enforcing TLS v1.2, this is potentially less secure\"", "                    _err=$(wget \"$1\" -O \"$2\" 2>&1)", "                    _status=$?", "                else", "                    _err=$(wget --https-only --secure-protocol=TLSv1_2 \"$1\" -O \"$2\" 2>&1)", "                    _status=$?", "                fi", "            fi", "        fi", "        if [ -n \"$_err\" ]; then", "            echo \"$_err\" >&2", "            if echo \"$_err\" | grep -q ' 404 Not Found$'; then", "                err \"installer for platform '$3' not found, this may be unsupported\"", "            fi", "        fi", "        return $_status", "    else", "        err \"Unknown downloader\"   # should not reach here", "    fi", "}", "", "check_help_for() {", "    local _arch", "    local _cmd", "    local _arg", "    _arch=\"$1\"", "    shift", "    _cmd=\"$1\"", "    shift", "", "    local _category", "    if \"$_cmd\" --help | grep -q 'For all options use the manual or \"--help all\".'; then", "      _category=\"all\"", "    else", "      _category=\"\"", "    fi", "", "    case \"$_arch\" in", "", "        *darwin*)", "        if check_cmd sw_vers; then", "            case $(sw_vers -productVersion) in", "                10.*)", "                    # If we're running on macOS, older than 10.13, then we always", "                    # fail to find these options to force fallback", "                    if [ \"$(sw_vers -productVersion | cut -d. -f2)\" -lt 13 ]; then", "                        # Older than 10.13", "                        echo \"Warning: Detected macOS platform older than 10.13\"", "                        return 1", "                    fi", "                    ;;", "                11.*)", "                    # We assume Big Sur will be OK for now", "                    ;;", "                *)", "                    # Unknown product version, warn and continue", "                    echo \"Warning: Detected unknown macOS major version: $(sw_vers -productVersion)\"", "                    echo \"Warning TLS capabilities detection may fail\"", "                    ;;", "            esac", "        fi", "        ;;", "", "    esac", "", "    for _arg in \"$@\"; do", "        if ! \"$_cmd\" --help $_category | grep -q -- \"$_arg\"; then", "            return 1", "        fi", "    done", "", "    true # not strictly needed", "}", "", "# Check if curl supports the --retry flag, then pass it to the curl invocation.", "check_curl_for_retry_support() {", "  local _retry_supported=\"\"", "  # \"unspecified\" is for arch, allows for possibility old OS using macports, homebrew, etc.", "  if check_help_for \"notspecified\" \"curl\" \"--retry\"; then", "    _retry_supported=\"--retry 3\"", "  fi", "", "  RETVAL=\"$_retry_supported\"", "", "}", "", "# Return cipher suite string specified by user, otherwise return strong TLS 1.2-1.3 cipher suites", "# if support by local tools is detected. Detection currently supports these curl backends:", "# GnuTLS and OpenSSL (possibly also LibreSSL and BoringSSL). Return value can be empty.", "get_ciphersuites_for_curl() {", "    if [ -n \"${RUSTUP_TLS_CIPHERSUITES-}\" ]; then", "        # user specified custom cipher suites, assume they know what they're doing", "        RETVAL=\"$RUSTUP_TLS_CIPHERSUITES\"", "        return", "    fi", "", "    local _openssl_syntax=\"no\"", "    local _gnutls_syntax=\"no\"", "    local _backend_supported=\"yes\"", "    if curl -V | grep -q ' OpenSSL/'; then", "        _openssl_syntax=\"yes\"", "    elif curl -V | grep -iq ' LibreSSL/'; then", "        _openssl_syntax=\"yes\"", "    elif curl -V | grep -iq ' BoringSSL/'; then", "        _openssl_syntax=\"yes\"", "    elif curl -V | grep -iq ' GnuTLS/'; then", "        _gnutls_syntax=\"yes\"", "    else", "        _backend_supported=\"no\"", "    fi", "", "    local _args_supported=\"no\"", "    if [ \"$_backend_supported\" = \"yes\" ]; then", "        # \"unspecified\" is for arch, allows for possibility old OS using macports, homebrew, etc.", "        if check_help_for \"notspecified\" \"curl\" \"--tlsv1.2\" \"--ciphers\" \"--proto\"; then", "            _args_supported=\"yes\"", "        fi", "    fi", "", "    local _cs=\"\"", "    if [ \"$_args_supported\" = \"yes\" ]; then", "        if [ \"$_openssl_syntax\" = \"yes\" ]; then", "            _cs=$(get_strong_ciphersuites_for \"openssl\")", "        elif [ \"$_gnutls_syntax\" = \"yes\" ]; then", "            _cs=$(get_strong_ciphersuites_for \"gnutls\")", "        fi", "    fi", "", "    RETVAL=\"$_cs\"", "}", "", "# Return cipher suite string specified by user, otherwise return strong TLS 1.2-1.3 cipher suites", "# if support by local tools is detected. Detection currently supports these wget backends:", "# GnuTLS and OpenSSL (possibly also LibreSSL and BoringSSL). Return value can be empty.", "get_ciphersuites_for_wget() {", "    if [ -n \"${RUSTUP_TLS_CIPHERSUITES-}\" ]; then", "        # user specified custom cipher suites, assume they know what they're doing", "        RETVAL=\"$RUSTUP_TLS_CIPHERSUITES\"", "        return", "    fi", "", "    local _cs=\"\"", "    if wget -V | grep -q '\\-DHAVE_LIBSSL'; then", "        # \"unspecified\" is for arch, allows for possibility old OS using macports, homebrew, etc.", "        if check_help_for \"notspecified\" \"wget\" \"TLSv1_2\" \"--ciphers\" \"--https-only\" \"--secure-protocol\"; then", "            _cs=$(get_strong_ciphersuites_for \"openssl\")", "        fi", "    elif wget -V | grep -q '\\-DHAVE_LIBGNUTLS'; then", "        # \"unspecified\" is for arch, allows for possibility old OS using macports, homebrew, etc.", "        if check_help_for \"notspecified\" \"wget\" \"TLSv1_2\" \"--ciphers\" \"--https-only\" \"--secure-protocol\"; then", "            _cs=$(get_strong_ciphersuites_for \"gnutls\")", "        fi", "    fi", "", "    RETVAL=\"$_cs\"", "}", "", "# Return strong TLS 1.2-1.3 cipher suites in OpenSSL or GnuTLS syntax. TLS 1.2", "# excludes non-ECDHE and non-AEAD cipher suites. DHE is excluded due to bad", "# DH params often found on servers (see RFC 7919). Sequence matches or is", "# similar to Firefox 68 ESR with weak cipher suites disabled via about:config.", "# $1 must be openssl or gnutls.", "get_strong_ciphersuites_for() {", "    if [ \"$1\" = \"openssl\" ]; then", "        # OpenSSL is forgiving of unknown values, no problems with TLS 1.3 values on versions that don't support it yet.", "        echo \"TLS_AES_128_GCM_SHA256:TLS_CHACHA20_POLY1305_SHA256:TLS_AES_256_GCM_SHA384:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384\"", "    elif [ \"$1\" = \"gnutls\" ]; then", "        # GnuTLS isn't forgiving of unknown values, so this may require a GnuTLS version that supports TLS 1.3 even if wget doesn't.", "        # Begin with SECURE128 (and higher) then remove/add to build cipher suites. Produces same 9 cipher suites as OpenSSL but in slightly different order.", "        echo \"SECURE128:-VERS-SSL3.0:-VERS-TLS1.0:-VERS-TLS1.1:-VERS-DTLS-ALL:-CIPHER-ALL:-MAC-ALL:-KX-ALL:+AEAD:+ECDHE-ECDSA:+ECDHE-RSA:+AES-128-GCM:+CHACHA20-POLY1305:+AES-256-GCM\"", "    fi", "}", "", "main \"$@\" || exit 1", "curl: (6) Could not resolve host: |", "curl: (6) Could not resolve host: sh"]}
2022-12-30 00:15:30,756 p=92047 u=kal n=ansible | PLAY RECAP *******************************************************************************************************************************************
2022-12-30 00:15:30,756 p=92047 u=kal n=ansible | krpz                       : ok=1    changed=0    unreachable=0    failed=1    skipped=0    rescued=0    ignored=0   
2022-12-30 00:15:35,458 p=92214 u=kal n=ansible | PLAY [localhost] *************************************************************************************************************************************
2022-12-30 00:15:35,465 p=92214 u=kal n=ansible | TASK [Gathering Facts] *******************************************************************************************************************************
2022-12-30 00:15:36,571 p=92214 u=kal n=ansible | ok: [krpz]
2022-12-30 00:15:36,605 p=92214 u=kal n=ansible | TASK [Install Rust] **********************************************************************************************************************************
2022-12-30 00:15:37,092 p=92214 u=kal n=ansible | fatal: [krpz]: FAILED! => {"changed": true, "cmd": "curl https://sh.rustup.rs | sh", "delta": "0:00:00.265684", "end": "2022-12-30 00:15:37.033786", "msg": "non-zero return code", "rc": 6, "start": "2022-12-30 00:15:36.768102", "stdout": "#!/bin/sh\r\n# shellcheck shell=dash\r\n\r\n# This is just a little script that can be downloaded from the internet to\r\n# install rustup. It just does platform detection, downloads the installer\r\n# and runs it.\r\n\r\n# It runs on Unix shells like {a,ba,da,k,z}sh. It uses the common `local`\r\n# extension. Note: Most shells limit `local` to 1 var per line, contra bash.\r\n\r\nif [ \"$KSH_VERSION\" = 'Version JM 93t+ 2010-03-05' ]; then\r\n    # The version of ksh93 that ships with many illumos systems does not\r\n    # support the \"local\" extension.  Print a message rather than fail in\r\n    # subtle ways later on:\r\n    echo 'rustup does not work with this ksh93 version; please try bash!' >&2\r\n    exit 1\r\nfi\r\n\r\n\r\nset -u\r\n\r\n# If RUSTUP_UPDATE_ROOT is unset or empty, default it.\r\nRUSTUP_UPDATE_ROOT=\"${RUSTUP_UPDATE_ROOT:-https://static.rust-lang.org/rustup}\"\r\n\r\n#XXX: If you change anything here, please make the same changes in setup_mode.rs\r\nusage() {\r\n    cat 1>&2 <<EOF\r\nrustup-init 1.25.1 (48d233f65 2022-07-12)\r\nThe installer for rustup\r\n\r\nUSAGE:\r\n    rustup-init [FLAGS] [OPTIONS]\r\n\r\nFLAGS:\r\n    -v, --verbose           Enable verbose output\r\n    -q, --quiet             Disable progress output\r\n    -y                      Disable confirmation prompt.\r\n        --no-modify-path    Don't configure the PATH environment variable\r\n    -h, --help              Prints help information\r\n    -V, --version           Prints version information\r\n\r\nOPTIONS:\r\n        --default-host <default-host>              Choose a default host triple\r\n        --default-toolchain <default-toolchain>    Choose a default toolchain to install\r\n        --default-toolchain none                   Do not install any toolchains\r\n        --profile [minimal|default|complete]       Choose a profile\r\n    -c, --component <components>...                Component name to also install\r\n    -t, --target <targets>...                      Target name to also install\r\nEOF\r\n}\r\n\r\nmain() {\r\n    downloader --check\r\n    need_cmd uname\r\n    need_cmd mktemp\r\n    need_cmd chmod\r\n    need_cmd mkdir\r\n    need_cmd rm\r\n    need_cmd rmdir\r\n\r\n    get_architecture || return 1\r\n    local _arch=\"$RETVAL\"\r\n    assert_nz \"$_arch\" \"arch\"\r\n\r\n    local _ext=\"\"\r\n    case \"$_arch\" in\r\n        *windows*)\r\n            _ext=\".exe\"\r\n            ;;\r\n    esac\r\n\r\n    local _url=\"${RUSTUP_UPDATE_ROOT}/dist/${_arch}/rustup-init${_ext}\"\r\n\r\n    local _dir\r\n    _dir=\"$(ensure mktemp -d)\"\r\n    local _file=\"${_dir}/rustup-init${_ext}\"\r\n\r\n    local _ansi_escapes_are_valid=false\r\n    if [ -t 2 ]; then\r\n        if [ \"${TERM+set}\" = 'set' ]; then\r\n            case \"$TERM\" in\r\n                xterm*|rxvt*|urxvt*|linux*|vt*)\r\n                    _ansi_escapes_are_valid=true\r\n                ;;\r\n            esac\r\n        fi\r\n    fi\r\n\r\n    # check if we have to use /dev/tty to prompt the user\r\n    local need_tty=yes\r\n    for arg in \"$@\"; do\r\n        case \"$arg\" in\r\n            --help)\r\n                usage\r\n                exit 0\r\n                ;;\r\n            *)\r\n                OPTIND=1\r\n                if [ \"${arg%%--*}\" = \"\" ]; then\r\n                    # Long option (other than --help);\r\n                    # don't attempt to interpret it.\r\n                    continue\r\n                fi\r\n                while getopts :hy sub_arg \"$arg\"; do\r\n                    case \"$sub_arg\" in\r\n                        h)\r\n                            usage\r\n                            exit 0\r\n                            ;;\r\n                        y)\r\n                            # user wants to skip the prompt --\r\n                            # we don't need /dev/tty\r\n                            need_tty=no\r\n                            ;;\r\n                        *)\r\n                            ;;\r\n                        esac\r\n                done\r\n                ;;\r\n        esac\r\n    done\r\n\r\n    if $_ansi_escapes_are_valid; then\r\n        printf \"\\33[1minfo:\\33[0m downloading installer\\n\" 1>&2\r\n    else\r\n        printf '%s\\n' 'info: downloading installer' 1>&2\r\n    fi\r\n\r\n    ensure mkdir -p \"$_dir\"\r\n    ensure downloader \"$_url\" \"$_file\" \"$_arch\"\r\n    ensure chmod u+x \"$_file\"\r\n    if [ ! -x \"$_file\" ]; then\r\n        printf '%s\\n' \"Cannot execute $_file (likely because of mounting /tmp as noexec).\" 1>&2\r\n        printf '%s\\n' \"Please copy the file to a location where you can execute binaries and run ./rustup-init${_ext}.\" 1>&2\r\n        exit 1\r\n    fi\r\n\r\n    if [ \"$need_tty\" = \"yes\" ] && [ ! -t 0 ]; then\r\n        # The installer is going to want to ask for confirmation by\r\n        # reading stdin.  This script was piped into `sh` though and\r\n        # doesn't have stdin to pass to its children. Instead we're going\r\n        # to explicitly connect /dev/tty to the installer's stdin.\r\n        if [ ! -t 1 ]; then\r\n            err \"Unable to run interactively. Run with -y to accept defaults, --help for additional options\"\r\n        fi\r\n\r\n        ignore \"$_file\" \"$@\" < /dev/tty\r\n    else\r\n        ignore \"$_file\" \"$@\"\r\n    fi\r\n\r\n    local _retval=$?\r\n\r\n    ignore rm \"$_file\"\r\n    ignore rmdir \"$_dir\"\r\n\r\n    return \"$_retval\"\r\n}\r\n\r\ncheck_proc() {\r\n    # Check for /proc by looking for the /proc/self/exe link\r\n    # This is only run on Linux\r\n    if ! test -L /proc/self/exe ; then\r\n        err \"fatal: Unable to find /proc/self/exe.  Is /proc mounted?  Installation cannot proceed without /proc.\"\r\n    fi\r\n}\r\n\r\nget_bitness() {\r\n    need_cmd head\r\n    # Architecture detection without dependencies beyond coreutils.\r\n    # ELF files start out \"\\x7fELF\", and the following byte is\r\n    #   0x01 for 32-bit and\r\n    #   0x02 for 64-bit.\r\n    # The printf builtin on some shells like dash only supports octal\r\n    # escape sequences, so we use those.\r\n    local _current_exe_head\r\n    _current_exe_head=$(head -c 5 /proc/self/exe )\r\n    if [ \"$_current_exe_head\" = \"$(printf '\\177ELF\\001')\" ]; then\r\n        echo 32\r\n    elif [ \"$_current_exe_head\" = \"$(printf '\\177ELF\\002')\" ]; then\r\n        echo 64\r\n    else\r\n        err \"unknown platform bitness\"\r\n    fi\r\n}\r\n\r\nis_host_amd64_elf() {\r\n    need_cmd head\r\n    need_cmd tail\r\n    # ELF e_machine detection without dependencies beyond coreutils.\r\n    # Two-byte field at offset 0x12 indicates the CPU,\r\n    # but we're interested in it being 0x3E to indicate amd64, or not that.\r\n    local _current_exe_machine\r\n    _current_exe_machine=$(head -c 19 /proc/self/exe | tail -c 1)\r\n    [ \"$_current_exe_machine\" = \"$(printf '\\076')\" ]\r\n}\r\n\r\nget_endianness() {\r\n    local cputype=$1\r\n    local suffix_eb=$2\r\n    local suffix_el=$3\r\n\r\n    # detect endianness without od/hexdump, like get_bitness() does.\r\n    need_cmd head\r\n    need_cmd tail\r\n\r\n    local _current_exe_endianness\r\n    _current_exe_endianness=\"$(head -c 6 /proc/self/exe | tail -c 1)\"\r\n    if [ \"$_current_exe_endianness\" = \"$(printf '\\001')\" ]; then\r\n        echo \"${cputype}${suffix_el}\"\r\n    elif [ \"$_current_exe_endianness\" = \"$(printf '\\002')\" ]; then\r\n        echo \"${cputype}${suffix_eb}\"\r\n    else\r\n        err \"unknown platform endianness\"\r\n    fi\r\n}\r\n\r\nget_architecture() {\r\n    local _ostype _cputype _bitness _arch _clibtype\r\n    _ostype=\"$(uname -s)\"\r\n    _cputype=\"$(uname -m)\"\r\n    _clibtype=\"gnu\"\r\n\r\n    if [ \"$_ostype\" = Linux ]; then\r\n        if [ \"$(uname -o)\" = Android ]; then\r\n            _ostype=Android\r\n        fi\r\n        if ldd --version 2>&1 | grep -q 'musl'; then\r\n            _clibtype=\"musl\"\r\n        fi\r\n    fi\r\n\r\n    if [ \"$_ostype\" = Darwin ] && [ \"$_cputype\" = i386 ]; then\r\n        # Darwin `uname -m` lies\r\n        if sysctl hw.optional.x86_64 | grep -q ': 1'; then\r\n            _cputype=x86_64\r\n        fi\r\n    fi\r\n\r\n    if [ \"$_ostype\" = SunOS ]; then\r\n        # Both Solaris and illumos presently announce as \"SunOS\" in \"uname -s\"\r\n        # so use \"uname -o\" to disambiguate.  We use the full path to the\r\n        # system uname in case the user has coreutils uname first in PATH,\r\n        # which has historically sometimes printed the wrong value here.\r\n        if [ \"$(/usr/bin/uname -o)\" = illumos ]; then\r\n            _ostype=illumos\r\n        fi\r\n\r\n        # illumos systems have multi-arch userlands, and \"uname -m\" reports the\r\n        # machine hardware name; e.g., \"i86pc\" on both 32- and 64-bit x86\r\n        # systems.  Check for the native (widest) instruction set on the\r\n        # running kernel:\r\n        if [ \"$_cputype\" = i86pc ]; then\r\n            _cputype=\"$(isainfo -n)\"\r\n        fi\r\n    fi\r\n\r\n    case \"$_ostype\" in\r\n\r\n        Android)\r\n            _ostype=linux-android\r\n            ;;\r\n\r\n        Linux)\r\n            check_proc\r\n            _ostype=unknown-linux-$_clibtype\r\n            _bitness=$(get_bitness)\r\n            ;;\r\n\r\n        FreeBSD)\r\n            _ostype=unknown-freebsd\r\n            ;;\r\n\r\n        NetBSD)\r\n            _ostype=unknown-netbsd\r\n            ;;\r\n\r\n        DragonFly)\r\n            _ostype=unknown-dragonfly\r\n            ;;\r\n\r\n        Darwin)\r\n            _ostype=apple-darwin\r\n            ;;\r\n\r\n        illumos)\r\n            _ostype=unknown-illumos\r\n            ;;\r\n\r\n        MINGW* | MSYS* | CYGWIN* | Windows_NT)\r\n            _ostype=pc-windows-gnu\r\n            ;;\r\n\r\n        *)\r\n            err \"unrecognized OS type: $_ostype\"\r\n            ;;\r\n\r\n    esac\r\n\r\n    case \"$_cputype\" in\r\n\r\n        i386 | i486 | i686 | i786 | x86)\r\n            _cputype=i686\r\n            ;;\r\n\r\n        xscale | arm)\r\n            _cputype=arm\r\n            if [ \"$_ostype\" = \"linux-android\" ]; then\r\n                _ostype=linux-androideabi\r\n            fi\r\n            ;;\r\n\r\n        armv6l)\r\n            _cputype=arm\r\n            if [ \"$_ostype\" = \"linux-android\" ]; then\r\n                _ostype=linux-androideabi\r\n            else\r\n                _ostype=\"${_ostype}eabihf\"\r\n            fi\r\n            ;;\r\n\r\n        armv7l | armv8l)\r\n            _cputype=armv7\r\n            if [ \"$_ostype\" = \"linux-android\" ]; then\r\n                _ostype=linux-androideabi\r\n            else\r\n                _ostype=\"${_ostype}eabihf\"\r\n            fi\r\n            ;;\r\n\r\n        aarch64 | arm64)\r\n            _cputype=aarch64\r\n            ;;\r\n\r\n        x86_64 | x86-64 | x64 | amd64)\r\n            _cputype=x86_64\r\n            ;;\r\n\r\n        mips)\r\n            _cputype=$(get_endianness mips '' el)\r\n            ;;\r\n\r\n        mips64)\r\n            if [ \"$_bitness\" -eq 64 ]; then\r\n                # only n64 ABI is supported for now\r\n                _ostype=\"${_ostype}abi64\"\r\n                _cputype=$(get_endianness mips64 '' el)\r\n            fi\r\n            ;;\r\n\r\n        ppc)\r\n            _cputype=powerpc\r\n            ;;\r\n\r\n        ppc64)\r\n            _cputype=powerpc64\r\n            ;;\r\n\r\n        ppc64le)\r\n            _cputype=powerpc64le\r\n            ;;\r\n\r\n        s390x)\r\n            _cputype=s390x\r\n            ;;\r\n        riscv64)\r\n            _cputype=riscv64gc\r\n            ;;\r\n        *)\r\n            err \"unknown CPU type: $_cputype\"\r\n\r\n    esac\r\n\r\n    # Detect 64-bit linux with 32-bit userland\r\n    if [ \"${_ostype}\" = unknown-linux-gnu ] && [ \"${_bitness}\" -eq 32 ]; then\r\n        case $_cputype in\r\n            x86_64)\r\n                if [ -n \"${RUSTUP_CPUTYPE:-}\" ]; then\r\n                    _cputype=\"$RUSTUP_CPUTYPE\"\r\n                else {\r\n                    # 32-bit executable for amd64 = x32\r\n                    if is_host_amd64_elf; then {\r\n                         echo \"This host is running an x32 userland; as it stands, x32 support is poor,\" 1>&2\r\n                         echo \"and there isn't a native toolchain -- you will have to install\" 1>&2\r\n                         echo \"multiarch compatibility with i686 and/or amd64, then select one\" 1>&2\r\n                         echo \"by re-running this script with the RUSTUP_CPUTYPE environment variable\" 1>&2\r\n                         echo \"set to i686 or x86_64, respectively.\" 1>&2\r\n                         echo 1>&2\r\n                         echo \"You will be able to add an x32 target after installation by running\" 1>&2\r\n                         echo \"  rustup target add x86_64-unknown-linux-gnux32\" 1>&2\r\n                         exit 1\r\n                    }; else\r\n                        _cputype=i686\r\n                    fi\r\n                }; fi\r\n                ;;\r\n            mips64)\r\n                _cputype=$(get_endianness mips '' el)\r\n                ;;\r\n            powerpc64)\r\n                _cputype=powerpc\r\n                ;;\r\n            aarch64)\r\n                _cputype=armv7\r\n                if [ \"$_ostype\" = \"linux-android\" ]; then\r\n                    _ostype=linux-androideabi\r\n                else\r\n                    _ostype=\"${_ostype}eabihf\"\r\n                fi\r\n                ;;\r\n            riscv64gc)\r\n                err \"riscv64 with 32-bit userland unsupported\"\r\n                ;;\r\n        esac\r\n    fi\r\n\r\n    # Detect armv7 but without the CPU features Rust needs in that build,\r\n    # and fall back to arm.\r\n    # See https://github.com/rust-lang/rustup.rs/issues/587.\r\n    if [ \"$_ostype\" = \"unknown-linux-gnueabihf\" ] && [ \"$_cputype\" = armv7 ]; then\r\n        if ensure grep '^Features' /proc/cpuinfo | grep -q -v neon; then\r\n            # At least one processor does not have NEON.\r\n            _cputype=arm\r\n        fi\r\n    fi\r\n\r\n    _arch=\"${_cputype}-${_ostype}\"\r\n\r\n    RETVAL=\"$_arch\"\r\n}\r\n\r\nsay() {\r\n    printf 'rustup: %s\\n' \"$1\"\r\n}\r\n\r\nerr() {\r\n    say \"$1\" >&2\r\n    exit 1\r\n}\r\n\r\nneed_cmd() {\r\n    if ! check_cmd \"$1\"; then\r\n        err \"need '$1' (command not found)\"\r\n    fi\r\n}\r\n\r\ncheck_cmd() {\r\n    command -v \"$1\" > /dev/null 2>&1\r\n}\r\n\r\nassert_nz() {\r\n    if [ -z \"$1\" ]; then err \"assert_nz $2\"; fi\r\n}\r\n\r\n# Run a command that should never fail. If the command fails execution\r\n# will immediately terminate with an error showing the failing\r\n# command.\r\nensure() {\r\n    if ! \"$@\"; then err \"command failed: $*\"; fi\r\n}\r\n\r\n# This is just for indicating that commands' results are being\r\n# intentionally ignored. Usually, because it's being executed\r\n# as part of error handling.\r\nignore() {\r\n    \"$@\"\r\n}\r\n\r\n# This wraps curl or wget. Try curl first, if not installed,\r\n# use wget instead.\r\ndownloader() {\r\n    local _dld\r\n    local _ciphersuites\r\n    local _err\r\n    local _status\r\n    local _retry\r\n    if check_cmd curl; then\r\n        _dld=curl\r\n    elif check_cmd wget; then\r\n        _dld=wget\r\n    else\r\n        _dld='curl or wget' # to be used in error message of need_cmd\r\n    fi\r\n\r\n    if [ \"$1\" = --check ]; then\r\n        need_cmd \"$_dld\"\r\n    elif [ \"$_dld\" = curl ]; then\r\n        check_curl_for_retry_support\r\n        _retry=\"$RETVAL\"\r\n        get_ciphersuites_for_curl\r\n        _ciphersuites=\"$RETVAL\"\r\n        if [ -n \"$_ciphersuites\" ]; then\r\n            _err=$(curl $_retry --proto '=https' --tlsv1.2 --ciphers \"$_ciphersuites\" --silent --show-error --fail --location \"$1\" --output \"$2\" 2>&1)\r\n            _status=$?\r\n        else\r\n            echo \"Warning: Not enforcing strong cipher suites for TLS, this is potentially less secure\"\r\n            if ! check_help_for \"$3\" curl --proto --tlsv1.2; then\r\n                echo \"Warning: Not enforcing TLS v1.2, this is potentially less secure\"\r\n                _err=$(curl $_retry --silent --show-error --fail --location \"$1\" --output \"$2\" 2>&1)\r\n                _status=$?\r\n            else\r\n                _err=$(curl $_retry --proto '=https' --tlsv1.2 --silent --show-error --fail --location \"$1\" --output \"$2\" 2>&1)\r\n                _status=$?\r\n            fi\r\n        fi\r\n        if [ -n \"$_err\" ]; then\r\n            echo \"$_err\" >&2\r\n            if echo \"$_err\" | grep -q 404$; then\r\n                err \"installer for platform '$3' not found, this may be unsupported\"\r\n            fi\r\n        fi\r\n        return $_status\r\n    elif [ \"$_dld\" = wget ]; then\r\n        if [ \"$(wget -V 2>&1|head -2|tail -1|cut -f1 -d\" \")\" = \"BusyBox\" ]; then\r\n            echo \"Warning: using the BusyBox version of wget.  Not enforcing strong cipher suites for TLS or TLS v1.2, this is potentially less secure\"\r\n            _err=$(wget \"$1\" -O \"$2\" 2>&1)\r\n            _status=$?\r\n        else\r\n            get_ciphersuites_for_wget\r\n            _ciphersuites=\"$RETVAL\"\r\n            if [ -n \"$_ciphersuites\" ]; then\r\n                _err=$(wget --https-only --secure-protocol=TLSv1_2 --ciphers \"$_ciphersuites\" \"$1\" -O \"$2\" 2>&1)\r\n                _status=$?\r\n            else\r\n                echo \"Warning: Not enforcing strong cipher suites for TLS, this is potentially less secure\"\r\n                if ! check_help_for \"$3\" wget --https-only --secure-protocol; then\r\n                    echo \"Warning: Not enforcing TLS v1.2, this is potentially less secure\"\r\n                    _err=$(wget \"$1\" -O \"$2\" 2>&1)\r\n                    _status=$?\r\n                else\r\n                    _err=$(wget --https-only --secure-protocol=TLSv1_2 \"$1\" -O \"$2\" 2>&1)\r\n                    _status=$?\r\n                fi\r\n            fi\r\n        fi\r\n        if [ -n \"$_err\" ]; then\r\n            echo \"$_err\" >&2\r\n            if echo \"$_err\" | grep -q ' 404 Not Found$'; then\r\n                err \"installer for platform '$3' not found, this may be unsupported\"\r\n            fi\r\n        fi\r\n        return $_status\r\n    else\r\n        err \"Unknown downloader\"   # should not reach here\r\n    fi\r\n}\r\n\r\ncheck_help_for() {\r\n    local _arch\r\n    local _cmd\r\n    local _arg\r\n    _arch=\"$1\"\r\n    shift\r\n    _cmd=\"$1\"\r\n    shift\r\n\r\n    local _category\r\n    if \"$_cmd\" --help | grep -q 'For all options use the manual or \"--help all\".'; then\r\n      _category=\"all\"\r\n    else\r\n      _category=\"\"\r\n    fi\r\n\r\n    case \"$_arch\" in\r\n\r\n        *darwin*)\r\n        if check_cmd sw_vers; then\r\n            case $(sw_vers -productVersion) in\r\n                10.*)\r\n                    # If we're running on macOS, older than 10.13, then we always\r\n                    # fail to find these options to force fallback\r\n                    if [ \"$(sw_vers -productVersion | cut -d. -f2)\" -lt 13 ]; then\r\n                        # Older than 10.13\r\n                        echo \"Warning: Detected macOS platform older than 10.13\"\r\n                        return 1\r\n                    fi\r\n                    ;;\r\n                11.*)\r\n                    # We assume Big Sur will be OK for now\r\n                    ;;\r\n                *)\r\n                    # Unknown product version, warn and continue\r\n                    echo \"Warning: Detected unknown macOS major version: $(sw_vers -productVersion)\"\r\n                    echo \"Warning TLS capabilities detection may fail\"\r\n                    ;;\r\n            esac\r\n        fi\r\n        ;;\r\n\r\n    esac\r\n\r\n    for _arg in \"$@\"; do\r\n        if ! \"$_cmd\" --help $_category | grep -q -- \"$_arg\"; then\r\n            return 1\r\n        fi\r\n    done\r\n\r\n    true # not strictly needed\r\n}\r\n\r\n# Check if curl supports the --retry flag, then pass it to the curl invocation.\r\ncheck_curl_for_retry_support() {\r\n  local _retry_supported=\"\"\r\n  # \"unspecified\" is for arch, allows for possibility old OS using macports, homebrew, etc.\r\n  if check_help_for \"notspecified\" \"curl\" \"--retry\"; then\r\n    _retry_supported=\"--retry 3\"\r\n  fi\r\n\r\n  RETVAL=\"$_retry_supported\"\r\n\r\n}\r\n\r\n# Return cipher suite string specified by user, otherwise return strong TLS 1.2-1.3 cipher suites\r\n# if support by local tools is detected. Detection currently supports these curl backends:\r\n# GnuTLS and OpenSSL (possibly also LibreSSL and BoringSSL). Return value can be empty.\r\nget_ciphersuites_for_curl() {\r\n    if [ -n \"${RUSTUP_TLS_CIPHERSUITES-}\" ]; then\r\n        # user specified custom cipher suites, assume they know what they're doing\r\n        RETVAL=\"$RUSTUP_TLS_CIPHERSUITES\"\r\n        return\r\n    fi\r\n\r\n    local _openssl_syntax=\"no\"\r\n    local _gnutls_syntax=\"no\"\r\n    local _backend_supported=\"yes\"\r\n    if curl -V | grep -q ' OpenSSL/'; then\r\n        _openssl_syntax=\"yes\"\r\n    elif curl -V | grep -iq ' LibreSSL/'; then\r\n        _openssl_syntax=\"yes\"\r\n    elif curl -V | grep -iq ' BoringSSL/'; then\r\n        _openssl_syntax=\"yes\"\r\n    elif curl -V | grep -iq ' GnuTLS/'; then\r\n        _gnutls_syntax=\"yes\"\r\n    else\r\n        _backend_supported=\"no\"\r\n    fi\r\n\r\n    local _args_supported=\"no\"\r\n    if [ \"$_backend_supported\" = \"yes\" ]; then\r\n        # \"unspecified\" is for arch, allows for possibility old OS using macports, homebrew, etc.\r\n        if check_help_for \"notspecified\" \"curl\" \"--tlsv1.2\" \"--ciphers\" \"--proto\"; then\r\n            _args_supported=\"yes\"\r\n        fi\r\n    fi\r\n\r\n    local _cs=\"\"\r\n    if [ \"$_args_supported\" = \"yes\" ]; then\r\n        if [ \"$_openssl_syntax\" = \"yes\" ]; then\r\n            _cs=$(get_strong_ciphersuites_for \"openssl\")\r\n        elif [ \"$_gnutls_syntax\" = \"yes\" ]; then\r\n            _cs=$(get_strong_ciphersuites_for \"gnutls\")\r\n        fi\r\n    fi\r\n\r\n    RETVAL=\"$_cs\"\r\n}\r\n\r\n# Return cipher suite string specified by user, otherwise return strong TLS 1.2-1.3 cipher suites\r\n# if support by local tools is detected. Detection currently supports these wget backends:\r\n# GnuTLS and OpenSSL (possibly also LibreSSL and BoringSSL). Return value can be empty.\r\nget_ciphersuites_for_wget() {\r\n    if [ -n \"${RUSTUP_TLS_CIPHERSUITES-}\" ]; then\r\n        # user specified custom cipher suites, assume they know what they're doing\r\n        RETVAL=\"$RUSTUP_TLS_CIPHERSUITES\"\r\n        return\r\n    fi\r\n\r\n    local _cs=\"\"\r\n    if wget -V | grep -q '\\-DHAVE_LIBSSL'; then\r\n        # \"unspecified\" is for arch, allows for possibility old OS using macports, homebrew, etc.\r\n        if check_help_for \"notspecified\" \"wget\" \"TLSv1_2\" \"--ciphers\" \"--https-only\" \"--secure-protocol\"; then\r\n            _cs=$(get_strong_ciphersuites_for \"openssl\")\r\n        fi\r\n    elif wget -V | grep -q '\\-DHAVE_LIBGNUTLS'; then\r\n        # \"unspecified\" is for arch, allows for possibility old OS using macports, homebrew, etc.\r\n        if check_help_for \"notspecified\" \"wget\" \"TLSv1_2\" \"--ciphers\" \"--https-only\" \"--secure-protocol\"; then\r\n            _cs=$(get_strong_ciphersuites_for \"gnutls\")\r\n        fi\r\n    fi\r\n\r\n    RETVAL=\"$_cs\"\r\n}\r\n\r\n# Return strong TLS 1.2-1.3 cipher suites in OpenSSL or GnuTLS syntax. TLS 1.2\r\n# excludes non-ECDHE and non-AEAD cipher suites. DHE is excluded due to bad\r\n# DH params often found on servers (see RFC 7919). Sequence matches or is\r\n# similar to Firefox 68 ESR with weak cipher suites disabled via about:config.\r\n# $1 must be openssl or gnutls.\r\nget_strong_ciphersuites_for() {\r\n    if [ \"$1\" = \"openssl\" ]; then\r\n        # OpenSSL is forgiving of unknown values, no problems with TLS 1.3 values on versions that don't support it yet.\r\n        echo \"TLS_AES_128_GCM_SHA256:TLS_CHACHA20_POLY1305_SHA256:TLS_AES_256_GCM_SHA384:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384\"\r\n    elif [ \"$1\" = \"gnutls\" ]; then\r\n        # GnuTLS isn't forgiving of unknown values, so this may require a GnuTLS version that supports TLS 1.3 even if wget doesn't.\r\n        # Begin with SECURE128 (and higher) then remove/add to build cipher suites. Produces same 9 cipher suites as OpenSSL but in slightly different order.\r\n        echo \"SECURE128:-VERS-SSL3.0:-VERS-TLS1.0:-VERS-TLS1.1:-VERS-DTLS-ALL:-CIPHER-ALL:-MAC-ALL:-KX-ALL:+AEAD:+ECDHE-ECDSA:+ECDHE-RSA:+AES-128-GCM:+CHACHA20-POLY1305:+AES-256-GCM\"\r\n    fi\r\n}\r\n\r\nmain \"$@\" || exit 1\r\ncurl: (6) Could not resolve host: |\r\ncurl: (6) Could not resolve host: sh", "stdout_lines": ["#!/bin/sh", "# shellcheck shell=dash", "", "# This is just a little script that can be downloaded from the internet to", "# install rustup. It just does platform detection, downloads the installer", "# and runs it.", "", "# It runs on Unix shells like {a,ba,da,k,z}sh. It uses the common `local`", "# extension. Note: Most shells limit `local` to 1 var per line, contra bash.", "", "if [ \"$KSH_VERSION\" = 'Version JM 93t+ 2010-03-05' ]; then", "    # The version of ksh93 that ships with many illumos systems does not", "    # support the \"local\" extension.  Print a message rather than fail in", "    # subtle ways later on:", "    echo 'rustup does not work with this ksh93 version; please try bash!' >&2", "    exit 1", "fi", "", "", "set -u", "", "# If RUSTUP_UPDATE_ROOT is unset or empty, default it.", "RUSTUP_UPDATE_ROOT=\"${RUSTUP_UPDATE_ROOT:-https://static.rust-lang.org/rustup}\"", "", "#XXX: If you change anything here, please make the same changes in setup_mode.rs", "usage() {", "    cat 1>&2 <<EOF", "rustup-init 1.25.1 (48d233f65 2022-07-12)", "The installer for rustup", "", "USAGE:", "    rustup-init [FLAGS] [OPTIONS]", "", "FLAGS:", "    -v, --verbose           Enable verbose output", "    -q, --quiet             Disable progress output", "    -y                      Disable confirmation prompt.", "        --no-modify-path    Don't configure the PATH environment variable", "    -h, --help              Prints help information", "    -V, --version           Prints version information", "", "OPTIONS:", "        --default-host <default-host>              Choose a default host triple", "        --default-toolchain <default-toolchain>    Choose a default toolchain to install", "        --default-toolchain none                   Do not install any toolchains", "        --profile [minimal|default|complete]       Choose a profile", "    -c, --component <components>...                Component name to also install", "    -t, --target <targets>...                      Target name to also install", "EOF", "}", "", "main() {", "    downloader --check", "    need_cmd uname", "    need_cmd mktemp", "    need_cmd chmod", "    need_cmd mkdir", "    need_cmd rm", "    need_cmd rmdir", "", "    get_architecture || return 1", "    local _arch=\"$RETVAL\"", "    assert_nz \"$_arch\" \"arch\"", "", "    local _ext=\"\"", "    case \"$_arch\" in", "        *windows*)", "            _ext=\".exe\"", "            ;;", "    esac", "", "    local _url=\"${RUSTUP_UPDATE_ROOT}/dist/${_arch}/rustup-init${_ext}\"", "", "    local _dir", "    _dir=\"$(ensure mktemp -d)\"", "    local _file=\"${_dir}/rustup-init${_ext}\"", "", "    local _ansi_escapes_are_valid=false", "    if [ -t 2 ]; then", "        if [ \"${TERM+set}\" = 'set' ]; then", "            case \"$TERM\" in", "                xterm*|rxvt*|urxvt*|linux*|vt*)", "                    _ansi_escapes_are_valid=true", "                ;;", "            esac", "        fi", "    fi", "", "    # check if we have to use /dev/tty to prompt the user", "    local need_tty=yes", "    for arg in \"$@\"; do", "        case \"$arg\" in", "            --help)", "                usage", "                exit 0", "                ;;", "            *)", "                OPTIND=1", "                if [ \"${arg%%--*}\" = \"\" ]; then", "                    # Long option (other than --help);", "                    # don't attempt to interpret it.", "                    continue", "                fi", "                while getopts :hy sub_arg \"$arg\"; do", "                    case \"$sub_arg\" in", "                        h)", "                            usage", "                            exit 0", "                            ;;", "                        y)", "                            # user wants to skip the prompt --", "                            # we don't need /dev/tty", "                            need_tty=no", "                            ;;", "                        *)", "                            ;;", "                        esac", "                done", "                ;;", "        esac", "    done", "", "    if $_ansi_escapes_are_valid; then", "        printf \"\\33[1minfo:\\33[0m downloading installer\\n\" 1>&2", "    else", "        printf '%s\\n' 'info: downloading installer' 1>&2", "    fi", "", "    ensure mkdir -p \"$_dir\"", "    ensure downloader \"$_url\" \"$_file\" \"$_arch\"", "    ensure chmod u+x \"$_file\"", "    if [ ! -x \"$_file\" ]; then", "        printf '%s\\n' \"Cannot execute $_file (likely because of mounting /tmp as noexec).\" 1>&2", "        printf '%s\\n' \"Please copy the file to a location where you can execute binaries and run ./rustup-init${_ext}.\" 1>&2", "        exit 1", "    fi", "", "    if [ \"$need_tty\" = \"yes\" ] && [ ! -t 0 ]; then", "        # The installer is going to want to ask for confirmation by", "        # reading stdin.  This script was piped into `sh` though and", "        # doesn't have stdin to pass to its children. Instead we're going", "        # to explicitly connect /dev/tty to the installer's stdin.", "        if [ ! -t 1 ]; then", "            err \"Unable to run interactively. Run with -y to accept defaults, --help for additional options\"", "        fi", "", "        ignore \"$_file\" \"$@\" < /dev/tty", "    else", "        ignore \"$_file\" \"$@\"", "    fi", "", "    local _retval=$?", "", "    ignore rm \"$_file\"", "    ignore rmdir \"$_dir\"", "", "    return \"$_retval\"", "}", "", "check_proc() {", "    # Check for /proc by looking for the /proc/self/exe link", "    # This is only run on Linux", "    if ! test -L /proc/self/exe ; then", "        err \"fatal: Unable to find /proc/self/exe.  Is /proc mounted?  Installation cannot proceed without /proc.\"", "    fi", "}", "", "get_bitness() {", "    need_cmd head", "    # Architecture detection without dependencies beyond coreutils.", "    # ELF files start out \"\\x7fELF\", and the following byte is", "    #   0x01 for 32-bit and", "    #   0x02 for 64-bit.", "    # The printf builtin on some shells like dash only supports octal", "    # escape sequences, so we use those.", "    local _current_exe_head", "    _current_exe_head=$(head -c 5 /proc/self/exe )", "    if [ \"$_current_exe_head\" = \"$(printf '\\177ELF\\001')\" ]; then", "        echo 32", "    elif [ \"$_current_exe_head\" = \"$(printf '\\177ELF\\002')\" ]; then", "        echo 64", "    else", "        err \"unknown platform bitness\"", "    fi", "}", "", "is_host_amd64_elf() {", "    need_cmd head", "    need_cmd tail", "    # ELF e_machine detection without dependencies beyond coreutils.", "    # Two-byte field at offset 0x12 indicates the CPU,", "    # but we're interested in it being 0x3E to indicate amd64, or not that.", "    local _current_exe_machine", "    _current_exe_machine=$(head -c 19 /proc/self/exe | tail -c 1)", "    [ \"$_current_exe_machine\" = \"$(printf '\\076')\" ]", "}", "", "get_endianness() {", "    local cputype=$1", "    local suffix_eb=$2", "    local suffix_el=$3", "", "    # detect endianness without od/hexdump, like get_bitness() does.", "    need_cmd head", "    need_cmd tail", "", "    local _current_exe_endianness", "    _current_exe_endianness=\"$(head -c 6 /proc/self/exe | tail -c 1)\"", "    if [ \"$_current_exe_endianness\" = \"$(printf '\\001')\" ]; then", "        echo \"${cputype}${suffix_el}\"", "    elif [ \"$_current_exe_endianness\" = \"$(printf '\\002')\" ]; then", "        echo \"${cputype}${suffix_eb}\"", "    else", "        err \"unknown platform endianness\"", "    fi", "}", "", "get_architecture() {", "    local _ostype _cputype _bitness _arch _clibtype", "    _ostype=\"$(uname -s)\"", "    _cputype=\"$(uname -m)\"", "    _clibtype=\"gnu\"", "", "    if [ \"$_ostype\" = Linux ]; then", "        if [ \"$(uname -o)\" = Android ]; then", "            _ostype=Android", "        fi", "        if ldd --version 2>&1 | grep -q 'musl'; then", "            _clibtype=\"musl\"", "        fi", "    fi", "", "    if [ \"$_ostype\" = Darwin ] && [ \"$_cputype\" = i386 ]; then", "        # Darwin `uname -m` lies", "        if sysctl hw.optional.x86_64 | grep -q ': 1'; then", "            _cputype=x86_64", "        fi", "    fi", "", "    if [ \"$_ostype\" = SunOS ]; then", "        # Both Solaris and illumos presently announce as \"SunOS\" in \"uname -s\"", "        # so use \"uname -o\" to disambiguate.  We use the full path to the", "        # system uname in case the user has coreutils uname first in PATH,", "        # which has historically sometimes printed the wrong value here.", "        if [ \"$(/usr/bin/uname -o)\" = illumos ]; then", "            _ostype=illumos", "        fi", "", "        # illumos systems have multi-arch userlands, and \"uname -m\" reports the", "        # machine hardware name; e.g., \"i86pc\" on both 32- and 64-bit x86", "        # systems.  Check for the native (widest) instruction set on the", "        # running kernel:", "        if [ \"$_cputype\" = i86pc ]; then", "            _cputype=\"$(isainfo -n)\"", "        fi", "    fi", "", "    case \"$_ostype\" in", "", "        Android)", "            _ostype=linux-android", "            ;;", "", "        Linux)", "            check_proc", "            _ostype=unknown-linux-$_clibtype", "            _bitness=$(get_bitness)", "            ;;", "", "        FreeBSD)", "            _ostype=unknown-freebsd", "            ;;", "", "        NetBSD)", "            _ostype=unknown-netbsd", "            ;;", "", "        DragonFly)", "            _ostype=unknown-dragonfly", "            ;;", "", "        Darwin)", "            _ostype=apple-darwin", "            ;;", "", "        illumos)", "            _ostype=unknown-illumos", "            ;;", "", "        MINGW* | MSYS* | CYGWIN* | Windows_NT)", "            _ostype=pc-windows-gnu", "            ;;", "", "        *)", "            err \"unrecognized OS type: $_ostype\"", "            ;;", "", "    esac", "", "    case \"$_cputype\" in", "", "        i386 | i486 | i686 | i786 | x86)", "            _cputype=i686", "            ;;", "", "        xscale | arm)", "            _cputype=arm", "            if [ \"$_ostype\" = \"linux-android\" ]; then", "                _ostype=linux-androideabi", "            fi", "            ;;", "", "        armv6l)", "            _cputype=arm", "            if [ \"$_ostype\" = \"linux-android\" ]; then", "                _ostype=linux-androideabi", "            else", "                _ostype=\"${_ostype}eabihf\"", "            fi", "            ;;", "", "        armv7l | armv8l)", "            _cputype=armv7", "            if [ \"$_ostype\" = \"linux-android\" ]; then", "                _ostype=linux-androideabi", "            else", "                _ostype=\"${_ostype}eabihf\"", "            fi", "            ;;", "", "        aarch64 | arm64)", "            _cputype=aarch64", "            ;;", "", "        x86_64 | x86-64 | x64 | amd64)", "            _cputype=x86_64", "            ;;", "", "        mips)", "            _cputype=$(get_endianness mips '' el)", "            ;;", "", "        mips64)", "            if [ \"$_bitness\" -eq 64 ]; then", "                # only n64 ABI is supported for now", "                _ostype=\"${_ostype}abi64\"", "                _cputype=$(get_endianness mips64 '' el)", "            fi", "            ;;", "", "        ppc)", "            _cputype=powerpc", "            ;;", "", "        ppc64)", "            _cputype=powerpc64", "            ;;", "", "        ppc64le)", "            _cputype=powerpc64le", "            ;;", "", "        s390x)", "            _cputype=s390x", "            ;;", "        riscv64)", "            _cputype=riscv64gc", "            ;;", "        *)", "            err \"unknown CPU type: $_cputype\"", "", "    esac", "", "    # Detect 64-bit linux with 32-bit userland", "    if [ \"${_ostype}\" = unknown-linux-gnu ] && [ \"${_bitness}\" -eq 32 ]; then", "        case $_cputype in", "            x86_64)", "                if [ -n \"${RUSTUP_CPUTYPE:-}\" ]; then", "                    _cputype=\"$RUSTUP_CPUTYPE\"", "                else {", "                    # 32-bit executable for amd64 = x32", "                    if is_host_amd64_elf; then {", "                         echo \"This host is running an x32 userland; as it stands, x32 support is poor,\" 1>&2", "                         echo \"and there isn't a native toolchain -- you will have to install\" 1>&2", "                         echo \"multiarch compatibility with i686 and/or amd64, then select one\" 1>&2", "                         echo \"by re-running this script with the RUSTUP_CPUTYPE environment variable\" 1>&2", "                         echo \"set to i686 or x86_64, respectively.\" 1>&2", "                         echo 1>&2", "                         echo \"You will be able to add an x32 target after installation by running\" 1>&2", "                         echo \"  rustup target add x86_64-unknown-linux-gnux32\" 1>&2", "                         exit 1", "                    }; else", "                        _cputype=i686", "                    fi", "                }; fi", "                ;;", "            mips64)", "                _cputype=$(get_endianness mips '' el)", "                ;;", "            powerpc64)", "                _cputype=powerpc", "                ;;", "            aarch64)", "                _cputype=armv7", "                if [ \"$_ostype\" = \"linux-android\" ]; then", "                    _ostype=linux-androideabi", "                else", "                    _ostype=\"${_ostype}eabihf\"", "                fi", "                ;;", "            riscv64gc)", "                err \"riscv64 with 32-bit userland unsupported\"", "                ;;", "        esac", "    fi", "", "    # Detect armv7 but without the CPU features Rust needs in that build,", "    # and fall back to arm.", "    # See https://github.com/rust-lang/rustup.rs/issues/587.", "    if [ \"$_ostype\" = \"unknown-linux-gnueabihf\" ] && [ \"$_cputype\" = armv7 ]; then", "        if ensure grep '^Features' /proc/cpuinfo | grep -q -v neon; then", "            # At least one processor does not have NEON.", "            _cputype=arm", "        fi", "    fi", "", "    _arch=\"${_cputype}-${_ostype}\"", "", "    RETVAL=\"$_arch\"", "}", "", "say() {", "    printf 'rustup: %s\\n' \"$1\"", "}", "", "err() {", "    say \"$1\" >&2", "    exit 1", "}", "", "need_cmd() {", "    if ! check_cmd \"$1\"; then", "        err \"need '$1' (command not found)\"", "    fi", "}", "", "check_cmd() {", "    command -v \"$1\" > /dev/null 2>&1", "}", "", "assert_nz() {", "    if [ -z \"$1\" ]; then err \"assert_nz $2\"; fi", "}", "", "# Run a command that should never fail. If the command fails execution", "# will immediately terminate with an error showing the failing", "# command.", "ensure() {", "    if ! \"$@\"; then err \"command failed: $*\"; fi", "}", "", "# This is just for indicating that commands' results are being", "# intentionally ignored. Usually, because it's being executed", "# as part of error handling.", "ignore() {", "    \"$@\"", "}", "", "# This wraps curl or wget. Try curl first, if not installed,", "# use wget instead.", "downloader() {", "    local _dld", "    local _ciphersuites", "    local _err", "    local _status", "    local _retry", "    if check_cmd curl; then", "        _dld=curl", "    elif check_cmd wget; then", "        _dld=wget", "    else", "        _dld='curl or wget' # to be used in error message of need_cmd", "    fi", "", "    if [ \"$1\" = --check ]; then", "        need_cmd \"$_dld\"", "    elif [ \"$_dld\" = curl ]; then", "        check_curl_for_retry_support", "        _retry=\"$RETVAL\"", "        get_ciphersuites_for_curl", "        _ciphersuites=\"$RETVAL\"", "        if [ -n \"$_ciphersuites\" ]; then", "            _err=$(curl $_retry --proto '=https' --tlsv1.2 --ciphers \"$_ciphersuites\" --silent --show-error --fail --location \"$1\" --output \"$2\" 2>&1)", "            _status=$?", "        else", "            echo \"Warning: Not enforcing strong cipher suites for TLS, this is potentially less secure\"", "            if ! check_help_for \"$3\" curl --proto --tlsv1.2; then", "                echo \"Warning: Not enforcing TLS v1.2, this is potentially less secure\"", "                _err=$(curl $_retry --silent --show-error --fail --location \"$1\" --output \"$2\" 2>&1)", "                _status=$?", "            else", "                _err=$(curl $_retry --proto '=https' --tlsv1.2 --silent --show-error --fail --location \"$1\" --output \"$2\" 2>&1)", "                _status=$?", "            fi", "        fi", "        if [ -n \"$_err\" ]; then", "            echo \"$_err\" >&2", "            if echo \"$_err\" | grep -q 404$; then", "                err \"installer for platform '$3' not found, this may be unsupported\"", "            fi", "        fi", "        return $_status", "    elif [ \"$_dld\" = wget ]; then", "        if [ \"$(wget -V 2>&1|head -2|tail -1|cut -f1 -d\" \")\" = \"BusyBox\" ]; then", "            echo \"Warning: using the BusyBox version of wget.  Not enforcing strong cipher suites for TLS or TLS v1.2, this is potentially less secure\"", "            _err=$(wget \"$1\" -O \"$2\" 2>&1)", "            _status=$?", "        else", "            get_ciphersuites_for_wget", "            _ciphersuites=\"$RETVAL\"", "            if [ -n \"$_ciphersuites\" ]; then", "                _err=$(wget --https-only --secure-protocol=TLSv1_2 --ciphers \"$_ciphersuites\" \"$1\" -O \"$2\" 2>&1)", "                _status=$?", "            else", "                echo \"Warning: Not enforcing strong cipher suites for TLS, this is potentially less secure\"", "                if ! check_help_for \"$3\" wget --https-only --secure-protocol; then", "                    echo \"Warning: Not enforcing TLS v1.2, this is potentially less secure\"", "                    _err=$(wget \"$1\" -O \"$2\" 2>&1)", "                    _status=$?", "                else", "                    _err=$(wget --https-only --secure-protocol=TLSv1_2 \"$1\" -O \"$2\" 2>&1)", "                    _status=$?", "                fi", "            fi", "        fi", "        if [ -n \"$_err\" ]; then", "            echo \"$_err\" >&2", "            if echo \"$_err\" | grep -q ' 404 Not Found$'; then", "                err \"installer for platform '$3' not found, this may be unsupported\"", "            fi", "        fi", "        return $_status", "    else", "        err \"Unknown downloader\"   # should not reach here", "    fi", "}", "", "check_help_for() {", "    local _arch", "    local _cmd", "    local _arg", "    _arch=\"$1\"", "    shift", "    _cmd=\"$1\"", "    shift", "", "    local _category", "    if \"$_cmd\" --help | grep -q 'For all options use the manual or \"--help all\".'; then", "      _category=\"all\"", "    else", "      _category=\"\"", "    fi", "", "    case \"$_arch\" in", "", "        *darwin*)", "        if check_cmd sw_vers; then", "            case $(sw_vers -productVersion) in", "                10.*)", "                    # If we're running on macOS, older than 10.13, then we always", "                    # fail to find these options to force fallback", "                    if [ \"$(sw_vers -productVersion | cut -d. -f2)\" -lt 13 ]; then", "                        # Older than 10.13", "                        echo \"Warning: Detected macOS platform older than 10.13\"", "                        return 1", "                    fi", "                    ;;", "                11.*)", "                    # We assume Big Sur will be OK for now", "                    ;;", "                *)", "                    # Unknown product version, warn and continue", "                    echo \"Warning: Detected unknown macOS major version: $(sw_vers -productVersion)\"", "                    echo \"Warning TLS capabilities detection may fail\"", "                    ;;", "            esac", "        fi", "        ;;", "", "    esac", "", "    for _arg in \"$@\"; do", "        if ! \"$_cmd\" --help $_category | grep -q -- \"$_arg\"; then", "            return 1", "        fi", "    done", "", "    true # not strictly needed", "}", "", "# Check if curl supports the --retry flag, then pass it to the curl invocation.", "check_curl_for_retry_support() {", "  local _retry_supported=\"\"", "  # \"unspecified\" is for arch, allows for possibility old OS using macports, homebrew, etc.", "  if check_help_for \"notspecified\" \"curl\" \"--retry\"; then", "    _retry_supported=\"--retry 3\"", "  fi", "", "  RETVAL=\"$_retry_supported\"", "", "}", "", "# Return cipher suite string specified by user, otherwise return strong TLS 1.2-1.3 cipher suites", "# if support by local tools is detected. Detection currently supports these curl backends:", "# GnuTLS and OpenSSL (possibly also LibreSSL and BoringSSL). Return value can be empty.", "get_ciphersuites_for_curl() {", "    if [ -n \"${RUSTUP_TLS_CIPHERSUITES-}\" ]; then", "        # user specified custom cipher suites, assume they know what they're doing", "        RETVAL=\"$RUSTUP_TLS_CIPHERSUITES\"", "        return", "    fi", "", "    local _openssl_syntax=\"no\"", "    local _gnutls_syntax=\"no\"", "    local _backend_supported=\"yes\"", "    if curl -V | grep -q ' OpenSSL/'; then", "        _openssl_syntax=\"yes\"", "    elif curl -V | grep -iq ' LibreSSL/'; then", "        _openssl_syntax=\"yes\"", "    elif curl -V | grep -iq ' BoringSSL/'; then", "        _openssl_syntax=\"yes\"", "    elif curl -V | grep -iq ' GnuTLS/'; then", "        _gnutls_syntax=\"yes\"", "    else", "        _backend_supported=\"no\"", "    fi", "", "    local _args_supported=\"no\"", "    if [ \"$_backend_supported\" = \"yes\" ]; then", "        # \"unspecified\" is for arch, allows for possibility old OS using macports, homebrew, etc.", "        if check_help_for \"notspecified\" \"curl\" \"--tlsv1.2\" \"--ciphers\" \"--proto\"; then", "            _args_supported=\"yes\"", "        fi", "    fi", "", "    local _cs=\"\"", "    if [ \"$_args_supported\" = \"yes\" ]; then", "        if [ \"$_openssl_syntax\" = \"yes\" ]; then", "            _cs=$(get_strong_ciphersuites_for \"openssl\")", "        elif [ \"$_gnutls_syntax\" = \"yes\" ]; then", "            _cs=$(get_strong_ciphersuites_for \"gnutls\")", "        fi", "    fi", "", "    RETVAL=\"$_cs\"", "}", "", "# Return cipher suite string specified by user, otherwise return strong TLS 1.2-1.3 cipher suites", "# if support by local tools is detected. Detection currently supports these wget backends:", "# GnuTLS and OpenSSL (possibly also LibreSSL and BoringSSL). Return value can be empty.", "get_ciphersuites_for_wget() {", "    if [ -n \"${RUSTUP_TLS_CIPHERSUITES-}\" ]; then", "        # user specified custom cipher suites, assume they know what they're doing", "        RETVAL=\"$RUSTUP_TLS_CIPHERSUITES\"", "        return", "    fi", "", "    local _cs=\"\"", "    if wget -V | grep -q '\\-DHAVE_LIBSSL'; then", "        # \"unspecified\" is for arch, allows for possibility old OS using macports, homebrew, etc.", "        if check_help_for \"notspecified\" \"wget\" \"TLSv1_2\" \"--ciphers\" \"--https-only\" \"--secure-protocol\"; then", "            _cs=$(get_strong_ciphersuites_for \"openssl\")", "        fi", "    elif wget -V | grep -q '\\-DHAVE_LIBGNUTLS'; then", "        # \"unspecified\" is for arch, allows for possibility old OS using macports, homebrew, etc.", "        if check_help_for \"notspecified\" \"wget\" \"TLSv1_2\" \"--ciphers\" \"--https-only\" \"--secure-protocol\"; then", "            _cs=$(get_strong_ciphersuites_for \"gnutls\")", "        fi", "    fi", "", "    RETVAL=\"$_cs\"", "}", "", "# Return strong TLS 1.2-1.3 cipher suites in OpenSSL or GnuTLS syntax. TLS 1.2", "# excludes non-ECDHE and non-AEAD cipher suites. DHE is excluded due to bad", "# DH params often found on servers (see RFC 7919). Sequence matches or is", "# similar to Firefox 68 ESR with weak cipher suites disabled via about:config.", "# $1 must be openssl or gnutls.", "get_strong_ciphersuites_for() {", "    if [ \"$1\" = \"openssl\" ]; then", "        # OpenSSL is forgiving of unknown values, no problems with TLS 1.3 values on versions that don't support it yet.", "        echo \"TLS_AES_128_GCM_SHA256:TLS_CHACHA20_POLY1305_SHA256:TLS_AES_256_GCM_SHA384:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384\"", "    elif [ \"$1\" = \"gnutls\" ]; then", "        # GnuTLS isn't forgiving of unknown values, so this may require a GnuTLS version that supports TLS 1.3 even if wget doesn't.", "        # Begin with SECURE128 (and higher) then remove/add to build cipher suites. Produces same 9 cipher suites as OpenSSL but in slightly different order.", "        echo \"SECURE128:-VERS-SSL3.0:-VERS-TLS1.0:-VERS-TLS1.1:-VERS-DTLS-ALL:-CIPHER-ALL:-MAC-ALL:-KX-ALL:+AEAD:+ECDHE-ECDSA:+ECDHE-RSA:+AES-128-GCM:+CHACHA20-POLY1305:+AES-256-GCM\"", "    fi", "}", "", "main \"$@\" || exit 1", "curl: (6) Could not resolve host: |", "curl: (6) Could not resolve host: sh"]}
2022-12-30 00:15:37,093 p=92214 u=kal n=ansible | PLAY RECAP *******************************************************************************************************************************************
2022-12-30 00:15:37,093 p=92214 u=kal n=ansible | krpz                       : ok=1    changed=0    unreachable=0    failed=1    skipped=0    rescued=0    ignored=0   
2022-12-30 00:15:45,411 p=92375 u=kal n=ansible | PLAY [localhost] *************************************************************************************************************************************
2022-12-30 00:15:45,418 p=92375 u=kal n=ansible | TASK [Gathering Facts] *******************************************************************************************************************************
2022-12-30 00:15:49,388 p=92375 u=kal n=ansible | ok: [krpz]
2022-12-30 00:15:49,410 p=92375 u=kal n=ansible | TASK [Install Rust] **********************************************************************************************************************************
2022-12-30 00:15:50,164 p=92375 u=kal n=ansible | fatal: [krpz]: FAILED! => {"changed": true, "cmd": "curl https://sh.rustup.rs | sh", "delta": "0:00:00.550186", "end": "2022-12-30 00:15:50.118154", "msg": "non-zero return code", "rc": 6, "start": "2022-12-30 00:15:49.567968", "stdout": "#!/bin/sh\r\n# shellcheck shell=dash\r\n\r\n# This is just a little script that can be downloaded from the internet to\r\n# install rustup. It just does platform detection, downloads the installer\r\n# and runs it.\r\n\r\n# It runs on Unix shells like {a,ba,da,k,z}sh. It uses the common `local`\r\n# extension. Note: Most shells limit `local` to 1 var per line, contra bash.\r\n\r\nif [ \"$KSH_VERSION\" = 'Version JM 93t+ 2010-03-05' ]; then\r\n    # The version of ksh93 that ships with many illumos systems does not\r\n    # support the \"local\" extension.  Print a message rather than fail in\r\n    # subtle ways later on:\r\n    echo 'rustup does not work with this ksh93 version; please try bash!' >&2\r\n    exit 1\r\nfi\r\n\r\n\r\nset -u\r\n\r\n# If RUSTUP_UPDATE_ROOT is unset or empty, default it.\r\nRUSTUP_UPDATE_ROOT=\"${RUSTUP_UPDATE_ROOT:-https://static.rust-lang.org/rustup}\"\r\n\r\n#XXX: If you change anything here, please make the same changes in setup_mode.rs\r\nusage() {\r\n    cat 1>&2 <<EOF\r\nrustup-init 1.25.1 (48d233f65 2022-07-12)\r\nThe installer for rustup\r\n\r\nUSAGE:\r\n    rustup-init [FLAGS] [OPTIONS]\r\n\r\nFLAGS:\r\n    -v, --verbose           Enable verbose output\r\n    -q, --quiet             Disable progress output\r\n    -y                      Disable confirmation prompt.\r\n        --no-modify-path    Don't configure the PATH environment variable\r\n    -h, --help              Prints help information\r\n    -V, --version           Prints version information\r\n\r\nOPTIONS:\r\n        --default-host <default-host>              Choose a default host triple\r\n        --default-toolchain <default-toolchain>    Choose a default toolchain to install\r\n        --default-toolchain none                   Do not install any toolchains\r\n        --profile [minimal|default|complete]       Choose a profile\r\n    -c, --component <components>...                Component name to also install\r\n    -t, --target <targets>...                      Target name to also install\r\nEOF\r\n}\r\n\r\nmain() {\r\n    downloader --check\r\n    need_cmd uname\r\n    need_cmd mktemp\r\n    need_cmd chmod\r\n    need_cmd mkdir\r\n    need_cmd rm\r\n    need_cmd rmdir\r\n\r\n    get_architecture || return 1\r\n    local _arch=\"$RETVAL\"\r\n    assert_nz \"$_arch\" \"arch\"\r\n\r\n    local _ext=\"\"\r\n    case \"$_arch\" in\r\n        *windows*)\r\n            _ext=\".exe\"\r\n            ;;\r\n    esac\r\n\r\n    local _url=\"${RUSTUP_UPDATE_ROOT}/dist/${_arch}/rustup-init${_ext}\"\r\n\r\n    local _dir\r\n    _dir=\"$(ensure mktemp -d)\"\r\n    local _file=\"${_dir}/rustup-init${_ext}\"\r\n\r\n    local _ansi_escapes_are_valid=false\r\n    if [ -t 2 ]; then\r\n        if [ \"${TERM+set}\" = 'set' ]; then\r\n            case \"$TERM\" in\r\n                xterm*|rxvt*|urxvt*|linux*|vt*)\r\n                    _ansi_escapes_are_valid=true\r\n                ;;\r\n            esac\r\n        fi\r\n    fi\r\n\r\n    # check if we have to use /dev/tty to prompt the user\r\n    local need_tty=yes\r\n    for arg in \"$@\"; do\r\n        case \"$arg\" in\r\n            --help)\r\n                usage\r\n                exit 0\r\n                ;;\r\n            *)\r\n                OPTIND=1\r\n                if [ \"${arg%%--*}\" = \"\" ]; then\r\n                    # Long option (other than --help);\r\n                    # don't attempt to interpret it.\r\n                    continue\r\n                fi\r\n                while getopts :hy sub_arg \"$arg\"; do\r\n                    case \"$sub_arg\" in\r\n                        h)\r\n                            usage\r\n                            exit 0\r\n                            ;;\r\n                        y)\r\n                            # user wants to skip the prompt --\r\n                            # we don't need /dev/tty\r\n                            need_tty=no\r\n                            ;;\r\n                        *)\r\n                            ;;\r\n                        esac\r\n                done\r\n                ;;\r\n        esac\r\n    done\r\n\r\n    if $_ansi_escapes_are_valid; then\r\n        printf \"\\33[1minfo:\\33[0m downloading installer\\n\" 1>&2\r\n    else\r\n        printf '%s\\n' 'info: downloading installer' 1>&2\r\n    fi\r\n\r\n    ensure mkdir -p \"$_dir\"\r\n    ensure downloader \"$_url\" \"$_file\" \"$_arch\"\r\n    ensure chmod u+x \"$_file\"\r\n    if [ ! -x \"$_file\" ]; then\r\n        printf '%s\\n' \"Cannot execute $_file (likely because of mounting /tmp as noexec).\" 1>&2\r\n        printf '%s\\n' \"Please copy the file to a location where you can execute binaries and run ./rustup-init${_ext}.\" 1>&2\r\n        exit 1\r\n    fi\r\n\r\n    if [ \"$need_tty\" = \"yes\" ] && [ ! -t 0 ]; then\r\n        # The installer is going to want to ask for confirmation by\r\n        # reading stdin.  This script was piped into `sh` though and\r\n        # doesn't have stdin to pass to its children. Instead we're going\r\n        # to explicitly connect /dev/tty to the installer's stdin.\r\n        if [ ! -t 1 ]; then\r\n            err \"Unable to run interactively. Run with -y to accept defaults, --help for additional options\"\r\n        fi\r\n\r\n        ignore \"$_file\" \"$@\" < /dev/tty\r\n    else\r\n        ignore \"$_file\" \"$@\"\r\n    fi\r\n\r\n    local _retval=$?\r\n\r\n    ignore rm \"$_file\"\r\n    ignore rmdir \"$_dir\"\r\n\r\n    return \"$_retval\"\r\n}\r\n\r\ncheck_proc() {\r\n    # Check for /proc by looking for the /proc/self/exe link\r\n    # This is only run on Linux\r\n    if ! test -L /proc/self/exe ; then\r\n        err \"fatal: Unable to find /proc/self/exe.  Is /proc mounted?  Installation cannot proceed without /proc.\"\r\n    fi\r\n}\r\n\r\nget_bitness() {\r\n    need_cmd head\r\n    # Architecture detection without dependencies beyond coreutils.\r\n    # ELF files start out \"\\x7fELF\", and the following byte is\r\n    #   0x01 for 32-bit and\r\n    #   0x02 for 64-bit.\r\n    # The printf builtin on some shells like dash only supports octal\r\n    # escape sequences, so we use those.\r\n    local _current_exe_head\r\n    _current_exe_head=$(head -c 5 /proc/self/exe )\r\n    if [ \"$_current_exe_head\" = \"$(printf '\\177ELF\\001')\" ]; then\r\n        echo 32\r\n    elif [ \"$_current_exe_head\" = \"$(printf '\\177ELF\\002')\" ]; then\r\n        echo 64\r\n    else\r\n        err \"unknown platform bitness\"\r\n    fi\r\n}\r\n\r\nis_host_amd64_elf() {\r\n    need_cmd head\r\n    need_cmd tail\r\n    # ELF e_machine detection without dependencies beyond coreutils.\r\n    # Two-byte field at offset 0x12 indicates the CPU,\r\n    # but we're interested in it being 0x3E to indicate amd64, or not that.\r\n    local _current_exe_machine\r\n    _current_exe_machine=$(head -c 19 /proc/self/exe | tail -c 1)\r\n    [ \"$_current_exe_machine\" = \"$(printf '\\076')\" ]\r\n}\r\n\r\nget_endianness() {\r\n    local cputype=$1\r\n    local suffix_eb=$2\r\n    local suffix_el=$3\r\n\r\n    # detect endianness without od/hexdump, like get_bitness() does.\r\n    need_cmd head\r\n    need_cmd tail\r\n\r\n    local _current_exe_endianness\r\n    _current_exe_endianness=\"$(head -c 6 /proc/self/exe | tail -c 1)\"\r\n    if [ \"$_current_exe_endianness\" = \"$(printf '\\001')\" ]; then\r\n        echo \"${cputype}${suffix_el}\"\r\n    elif [ \"$_current_exe_endianness\" = \"$(printf '\\002')\" ]; then\r\n        echo \"${cputype}${suffix_eb}\"\r\n    else\r\n        err \"unknown platform endianness\"\r\n    fi\r\n}\r\n\r\nget_architecture() {\r\n    local _ostype _cputype _bitness _arch _clibtype\r\n    _ostype=\"$(uname -s)\"\r\n    _cputype=\"$(uname -m)\"\r\n    _clibtype=\"gnu\"\r\n\r\n    if [ \"$_ostype\" = Linux ]; then\r\n        if [ \"$(uname -o)\" = Android ]; then\r\n            _ostype=Android\r\n        fi\r\n        if ldd --version 2>&1 | grep -q 'musl'; then\r\n            _clibtype=\"musl\"\r\n        fi\r\n    fi\r\n\r\n    if [ \"$_ostype\" = Darwin ] && [ \"$_cputype\" = i386 ]; then\r\n        # Darwin `uname -m` lies\r\n        if sysctl hw.optional.x86_64 | grep -q ': 1'; then\r\n            _cputype=x86_64\r\n        fi\r\n    fi\r\n\r\n    if [ \"$_ostype\" = SunOS ]; then\r\n        # Both Solaris and illumos presently announce as \"SunOS\" in \"uname -s\"\r\n        # so use \"uname -o\" to disambiguate.  We use the full path to the\r\n        # system uname in case the user has coreutils uname first in PATH,\r\n        # which has historically sometimes printed the wrong value here.\r\n        if [ \"$(/usr/bin/uname -o)\" = illumos ]; then\r\n            _ostype=illumos\r\n        fi\r\n\r\n        # illumos systems have multi-arch userlands, and \"uname -m\" reports the\r\n        # machine hardware name; e.g., \"i86pc\" on both 32- and 64-bit x86\r\n        # systems.  Check for the native (widest) instruction set on the\r\n        # running kernel:\r\n        if [ \"$_cputype\" = i86pc ]; then\r\n            _cputype=\"$(isainfo -n)\"\r\n        fi\r\n    fi\r\n\r\n    case \"$_ostype\" in\r\n\r\n        Android)\r\n            _ostype=linux-android\r\n            ;;\r\n\r\n        Linux)\r\n            check_proc\r\n            _ostype=unknown-linux-$_clibtype\r\n            _bitness=$(get_bitness)\r\n            ;;\r\n\r\n        FreeBSD)\r\n            _ostype=unknown-freebsd\r\n            ;;\r\n\r\n        NetBSD)\r\n            _ostype=unknown-netbsd\r\n            ;;\r\n\r\n        DragonFly)\r\n            _ostype=unknown-dragonfly\r\n            ;;\r\n\r\n        Darwin)\r\n            _ostype=apple-darwin\r\n            ;;\r\n\r\n        illumos)\r\n            _ostype=unknown-illumos\r\n            ;;\r\n\r\n        MINGW* | MSYS* | CYGWIN* | Windows_NT)\r\n            _ostype=pc-windows-gnu\r\n            ;;\r\n\r\n        *)\r\n            err \"unrecognized OS type: $_ostype\"\r\n            ;;\r\n\r\n    esac\r\n\r\n    case \"$_cputype\" in\r\n\r\n        i386 | i486 | i686 | i786 | x86)\r\n            _cputype=i686\r\n            ;;\r\n\r\n        xscale | arm)\r\n            _cputype=arm\r\n            if [ \"$_ostype\" = \"linux-android\" ]; then\r\n                _ostype=linux-androideabi\r\n            fi\r\n            ;;\r\n\r\n        armv6l)\r\n            _cputype=arm\r\n            if [ \"$_ostype\" = \"linux-android\" ]; then\r\n                _ostype=linux-androideabi\r\n            else\r\n                _ostype=\"${_ostype}eabihf\"\r\n            fi\r\n            ;;\r\n\r\n        armv7l | armv8l)\r\n            _cputype=armv7\r\n            if [ \"$_ostype\" = \"linux-android\" ]; then\r\n                _ostype=linux-androideabi\r\n            else\r\n                _ostype=\"${_ostype}eabihf\"\r\n            fi\r\n            ;;\r\n\r\n        aarch64 | arm64)\r\n            _cputype=aarch64\r\n            ;;\r\n\r\n        x86_64 | x86-64 | x64 | amd64)\r\n            _cputype=x86_64\r\n            ;;\r\n\r\n        mips)\r\n            _cputype=$(get_endianness mips '' el)\r\n            ;;\r\n\r\n        mips64)\r\n            if [ \"$_bitness\" -eq 64 ]; then\r\n                # only n64 ABI is supported for now\r\n                _ostype=\"${_ostype}abi64\"\r\n                _cputype=$(get_endianness mips64 '' el)\r\n            fi\r\n            ;;\r\n\r\n        ppc)\r\n            _cputype=powerpc\r\n            ;;\r\n\r\n        ppc64)\r\n            _cputype=powerpc64\r\n            ;;\r\n\r\n        ppc64le)\r\n            _cputype=powerpc64le\r\n            ;;\r\n\r\n        s390x)\r\n            _cputype=s390x\r\n            ;;\r\n        riscv64)\r\n            _cputype=riscv64gc\r\n            ;;\r\n        *)\r\n            err \"unknown CPU type: $_cputype\"\r\n\r\n    esac\r\n\r\n    # Detect 64-bit linux with 32-bit userland\r\n    if [ \"${_ostype}\" = unknown-linux-gnu ] && [ \"${_bitness}\" -eq 32 ]; then\r\n        case $_cputype in\r\n            x86_64)\r\n                if [ -n \"${RUSTUP_CPUTYPE:-}\" ]; then\r\n                    _cputype=\"$RUSTUP_CPUTYPE\"\r\n                else {\r\n                    # 32-bit executable for amd64 = x32\r\n                    if is_host_amd64_elf; then {\r\n                         echo \"This host is running an x32 userland; as it stands, x32 support is poor,\" 1>&2\r\n                         echo \"and there isn't a native toolchain -- you will have to install\" 1>&2\r\n                         echo \"multiarch compatibility with i686 and/or amd64, then select one\" 1>&2\r\n                         echo \"by re-running this script with the RUSTUP_CPUTYPE environment variable\" 1>&2\r\n                         echo \"set to i686 or x86_64, respectively.\" 1>&2\r\n                         echo 1>&2\r\n                         echo \"You will be able to add an x32 target after installation by running\" 1>&2\r\n                         echo \"  rustup target add x86_64-unknown-linux-gnux32\" 1>&2\r\n                         exit 1\r\n                    }; else\r\n                        _cputype=i686\r\n                    fi\r\n                }; fi\r\n                ;;\r\n            mips64)\r\n                _cputype=$(get_endianness mips '' el)\r\n                ;;\r\n            powerpc64)\r\n                _cputype=powerpc\r\n                ;;\r\n            aarch64)\r\n                _cputype=armv7\r\n                if [ \"$_ostype\" = \"linux-android\" ]; then\r\n                    _ostype=linux-androideabi\r\n                else\r\n                    _ostype=\"${_ostype}eabihf\"\r\n                fi\r\n                ;;\r\n            riscv64gc)\r\n                err \"riscv64 with 32-bit userland unsupported\"\r\n                ;;\r\n        esac\r\n    fi\r\n\r\n    # Detect armv7 but without the CPU features Rust needs in that build,\r\n    # and fall back to arm.\r\n    # See https://github.com/rust-lang/rustup.rs/issues/587.\r\n    if [ \"$_ostype\" = \"unknown-linux-gnueabihf\" ] && [ \"$_cputype\" = armv7 ]; then\r\n        if ensure grep '^Features' /proc/cpuinfo | grep -q -v neon; then\r\n            # At least one processor does not have NEON.\r\n            _cputype=arm\r\n        fi\r\n    fi\r\n\r\n    _arch=\"${_cputype}-${_ostype}\"\r\n\r\n    RETVAL=\"$_arch\"\r\n}\r\n\r\nsay() {\r\n    printf 'rustup: %s\\n' \"$1\"\r\n}\r\n\r\nerr() {\r\n    say \"$1\" >&2\r\n    exit 1\r\n}\r\n\r\nneed_cmd() {\r\n    if ! check_cmd \"$1\"; then\r\n        err \"need '$1' (command not found)\"\r\n    fi\r\n}\r\n\r\ncheck_cmd() {\r\n    command -v \"$1\" > /dev/null 2>&1\r\n}\r\n\r\nassert_nz() {\r\n    if [ -z \"$1\" ]; then err \"assert_nz $2\"; fi\r\n}\r\n\r\n# Run a command that should never fail. If the command fails execution\r\n# will immediately terminate with an error showing the failing\r\n# command.\r\nensure() {\r\n    if ! \"$@\"; then err \"command failed: $*\"; fi\r\n}\r\n\r\n# This is just for indicating that commands' results are being\r\n# intentionally ignored. Usually, because it's being executed\r\n# as part of error handling.\r\nignore() {\r\n    \"$@\"\r\n}\r\n\r\n# This wraps curl or wget. Try curl first, if not installed,\r\n# use wget instead.\r\ndownloader() {\r\n    local _dld\r\n    local _ciphersuites\r\n    local _err\r\n    local _status\r\n    local _retry\r\n    if check_cmd curl; then\r\n        _dld=curl\r\n    elif check_cmd wget; then\r\n        _dld=wget\r\n    else\r\n        _dld='curl or wget' # to be used in error message of need_cmd\r\n    fi\r\n\r\n    if [ \"$1\" = --check ]; then\r\n        need_cmd \"$_dld\"\r\n    elif [ \"$_dld\" = curl ]; then\r\n        check_curl_for_retry_support\r\n        _retry=\"$RETVAL\"\r\n        get_ciphersuites_for_curl\r\n        _ciphersuites=\"$RETVAL\"\r\n        if [ -n \"$_ciphersuites\" ]; then\r\n            _err=$(curl $_retry --proto '=https' --tlsv1.2 --ciphers \"$_ciphersuites\" --silent --show-error --fail --location \"$1\" --output \"$2\" 2>&1)\r\n            _status=$?\r\n        else\r\n            echo \"Warning: Not enforcing strong cipher suites for TLS, this is potentially less secure\"\r\n            if ! check_help_for \"$3\" curl --proto --tlsv1.2; then\r\n                echo \"Warning: Not enforcing TLS v1.2, this is potentially less secure\"\r\n                _err=$(curl $_retry --silent --show-error --fail --location \"$1\" --output \"$2\" 2>&1)\r\n                _status=$?\r\n            else\r\n                _err=$(curl $_retry --proto '=https' --tlsv1.2 --silent --show-error --fail --location \"$1\" --output \"$2\" 2>&1)\r\n                _status=$?\r\n            fi\r\n        fi\r\n        if [ -n \"$_err\" ]; then\r\n            echo \"$_err\" >&2\r\n            if echo \"$_err\" | grep -q 404$; then\r\n                err \"installer for platform '$3' not found, this may be unsupported\"\r\n            fi\r\n        fi\r\n        return $_status\r\n    elif [ \"$_dld\" = wget ]; then\r\n        if [ \"$(wget -V 2>&1|head -2|tail -1|cut -f1 -d\" \")\" = \"BusyBox\" ]; then\r\n            echo \"Warning: using the BusyBox version of wget.  Not enforcing strong cipher suites for TLS or TLS v1.2, this is potentially less secure\"\r\n            _err=$(wget \"$1\" -O \"$2\" 2>&1)\r\n            _status=$?\r\n        else\r\n            get_ciphersuites_for_wget\r\n            _ciphersuites=\"$RETVAL\"\r\n            if [ -n \"$_ciphersuites\" ]; then\r\n                _err=$(wget --https-only --secure-protocol=TLSv1_2 --ciphers \"$_ciphersuites\" \"$1\" -O \"$2\" 2>&1)\r\n                _status=$?\r\n            else\r\n                echo \"Warning: Not enforcing strong cipher suites for TLS, this is potentially less secure\"\r\n                if ! check_help_for \"$3\" wget --https-only --secure-protocol; then\r\n                    echo \"Warning: Not enforcing TLS v1.2, this is potentially less secure\"\r\n                    _err=$(wget \"$1\" -O \"$2\" 2>&1)\r\n                    _status=$?\r\n                else\r\n                    _err=$(wget --https-only --secure-protocol=TLSv1_2 \"$1\" -O \"$2\" 2>&1)\r\n                    _status=$?\r\n                fi\r\n            fi\r\n        fi\r\n        if [ -n \"$_err\" ]; then\r\n            echo \"$_err\" >&2\r\n            if echo \"$_err\" | grep -q ' 404 Not Found$'; then\r\n                err \"installer for platform '$3' not found, this may be unsupported\"\r\n            fi\r\n        fi\r\n        return $_status\r\n    else\r\n        err \"Unknown downloader\"   # should not reach here\r\n    fi\r\n}\r\n\r\ncheck_help_for() {\r\n    local _arch\r\n    local _cmd\r\n    local _arg\r\n    _arch=\"$1\"\r\n    shift\r\n    _cmd=\"$1\"\r\n    shift\r\n\r\n    local _category\r\n    if \"$_cmd\" --help | grep -q 'For all options use the manual or \"--help all\".'; then\r\n      _category=\"all\"\r\n    else\r\n      _category=\"\"\r\n    fi\r\n\r\n    case \"$_arch\" in\r\n\r\n        *darwin*)\r\n        if check_cmd sw_vers; then\r\n            case $(sw_vers -productVersion) in\r\n                10.*)\r\n                    # If we're running on macOS, older than 10.13, then we always\r\n                    # fail to find these options to force fallback\r\n                    if [ \"$(sw_vers -productVersion | cut -d. -f2)\" -lt 13 ]; then\r\n                        # Older than 10.13\r\n                        echo \"Warning: Detected macOS platform older than 10.13\"\r\n                        return 1\r\n                    fi\r\n                    ;;\r\n                11.*)\r\n                    # We assume Big Sur will be OK for now\r\n                    ;;\r\n                *)\r\n                    # Unknown product version, warn and continue\r\n                    echo \"Warning: Detected unknown macOS major version: $(sw_vers -productVersion)\"\r\n                    echo \"Warning TLS capabilities detection may fail\"\r\n                    ;;\r\n            esac\r\n        fi\r\n        ;;\r\n\r\n    esac\r\n\r\n    for _arg in \"$@\"; do\r\n        if ! \"$_cmd\" --help $_category | grep -q -- \"$_arg\"; then\r\n            return 1\r\n        fi\r\n    done\r\n\r\n    true # not strictly needed\r\n}\r\n\r\n# Check if curl supports the --retry flag, then pass it to the curl invocation.\r\ncheck_curl_for_retry_support() {\r\n  local _retry_supported=\"\"\r\n  # \"unspecified\" is for arch, allows for possibility old OS using macports, homebrew, etc.\r\n  if check_help_for \"notspecified\" \"curl\" \"--retry\"; then\r\n    _retry_supported=\"--retry 3\"\r\n  fi\r\n\r\n  RETVAL=\"$_retry_supported\"\r\n\r\n}\r\n\r\n# Return cipher suite string specified by user, otherwise return strong TLS 1.2-1.3 cipher suites\r\n# if support by local tools is detected. Detection currently supports these curl backends:\r\n# GnuTLS and OpenSSL (possibly also LibreSSL and BoringSSL). Return value can be empty.\r\nget_ciphersuites_for_curl() {\r\n    if [ -n \"${RUSTUP_TLS_CIPHERSUITES-}\" ]; then\r\n        # user specified custom cipher suites, assume they know what they're doing\r\n        RETVAL=\"$RUSTUP_TLS_CIPHERSUITES\"\r\n        return\r\n    fi\r\n\r\n    local _openssl_syntax=\"no\"\r\n    local _gnutls_syntax=\"no\"\r\n    local _backend_supported=\"yes\"\r\n    if curl -V | grep -q ' OpenSSL/'; then\r\n        _openssl_syntax=\"yes\"\r\n    elif curl -V | grep -iq ' LibreSSL/'; then\r\n        _openssl_syntax=\"yes\"\r\n    elif curl -V | grep -iq ' BoringSSL/'; then\r\n        _openssl_syntax=\"yes\"\r\n    elif curl -V | grep -iq ' GnuTLS/'; then\r\n        _gnutls_syntax=\"yes\"\r\n    else\r\n        _backend_supported=\"no\"\r\n    fi\r\n\r\n    local _args_supported=\"no\"\r\n    if [ \"$_backend_supported\" = \"yes\" ]; then\r\n        # \"unspecified\" is for arch, allows for possibility old OS using macports, homebrew, etc.\r\n        if check_help_for \"notspecified\" \"curl\" \"--tlsv1.2\" \"--ciphers\" \"--proto\"; then\r\n            _args_supported=\"yes\"\r\n        fi\r\n    fi\r\n\r\n    local _cs=\"\"\r\n    if [ \"$_args_supported\" = \"yes\" ]; then\r\n        if [ \"$_openssl_syntax\" = \"yes\" ]; then\r\n            _cs=$(get_strong_ciphersuites_for \"openssl\")\r\n        elif [ \"$_gnutls_syntax\" = \"yes\" ]; then\r\n            _cs=$(get_strong_ciphersuites_for \"gnutls\")\r\n        fi\r\n    fi\r\n\r\n    RETVAL=\"$_cs\"\r\n}\r\n\r\n# Return cipher suite string specified by user, otherwise return strong TLS 1.2-1.3 cipher suites\r\n# if support by local tools is detected. Detection currently supports these wget backends:\r\n# GnuTLS and OpenSSL (possibly also LibreSSL and BoringSSL). Return value can be empty.\r\nget_ciphersuites_for_wget() {\r\n    if [ -n \"${RUSTUP_TLS_CIPHERSUITES-}\" ]; then\r\n        # user specified custom cipher suites, assume they know what they're doing\r\n        RETVAL=\"$RUSTUP_TLS_CIPHERSUITES\"\r\n        return\r\n    fi\r\n\r\n    local _cs=\"\"\r\n    if wget -V | grep -q '\\-DHAVE_LIBSSL'; then\r\n        # \"unspecified\" is for arch, allows for possibility old OS using macports, homebrew, etc.\r\n        if check_help_for \"notspecified\" \"wget\" \"TLSv1_2\" \"--ciphers\" \"--https-only\" \"--secure-protocol\"; then\r\n            _cs=$(get_strong_ciphersuites_for \"openssl\")\r\n        fi\r\n    elif wget -V | grep -q '\\-DHAVE_LIBGNUTLS'; then\r\n        # \"unspecified\" is for arch, allows for possibility old OS using macports, homebrew, etc.\r\n        if check_help_for \"notspecified\" \"wget\" \"TLSv1_2\" \"--ciphers\" \"--https-only\" \"--secure-protocol\"; then\r\n            _cs=$(get_strong_ciphersuites_for \"gnutls\")\r\n        fi\r\n    fi\r\n\r\n    RETVAL=\"$_cs\"\r\n}\r\n\r\n# Return strong TLS 1.2-1.3 cipher suites in OpenSSL or GnuTLS syntax. TLS 1.2\r\n# excludes non-ECDHE and non-AEAD cipher suites. DHE is excluded due to bad\r\n# DH params often found on servers (see RFC 7919). Sequence matches or is\r\n# similar to Firefox 68 ESR with weak cipher suites disabled via about:config.\r\n# $1 must be openssl or gnutls.\r\nget_strong_ciphersuites_for() {\r\n    if [ \"$1\" = \"openssl\" ]; then\r\n        # OpenSSL is forgiving of unknown values, no problems with TLS 1.3 values on versions that don't support it yet.\r\n        echo \"TLS_AES_128_GCM_SHA256:TLS_CHACHA20_POLY1305_SHA256:TLS_AES_256_GCM_SHA384:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384\"\r\n    elif [ \"$1\" = \"gnutls\" ]; then\r\n        # GnuTLS isn't forgiving of unknown values, so this may require a GnuTLS version that supports TLS 1.3 even if wget doesn't.\r\n        # Begin with SECURE128 (and higher) then remove/add to build cipher suites. Produces same 9 cipher suites as OpenSSL but in slightly different order.\r\n        echo \"SECURE128:-VERS-SSL3.0:-VERS-TLS1.0:-VERS-TLS1.1:-VERS-DTLS-ALL:-CIPHER-ALL:-MAC-ALL:-KX-ALL:+AEAD:+ECDHE-ECDSA:+ECDHE-RSA:+AES-128-GCM:+CHACHA20-POLY1305:+AES-256-GCM\"\r\n    fi\r\n}\r\n\r\nmain \"$@\" || exit 1\r\ncurl: (6) Could not resolve host: |\r\ncurl: (6) Could not resolve host: sh", "stdout_lines": ["#!/bin/sh", "# shellcheck shell=dash", "", "# This is just a little script that can be downloaded from the internet to", "# install rustup. It just does platform detection, downloads the installer", "# and runs it.", "", "# It runs on Unix shells like {a,ba,da,k,z}sh. It uses the common `local`", "# extension. Note: Most shells limit `local` to 1 var per line, contra bash.", "", "if [ \"$KSH_VERSION\" = 'Version JM 93t+ 2010-03-05' ]; then", "    # The version of ksh93 that ships with many illumos systems does not", "    # support the \"local\" extension.  Print a message rather than fail in", "    # subtle ways later on:", "    echo 'rustup does not work with this ksh93 version; please try bash!' >&2", "    exit 1", "fi", "", "", "set -u", "", "# If RUSTUP_UPDATE_ROOT is unset or empty, default it.", "RUSTUP_UPDATE_ROOT=\"${RUSTUP_UPDATE_ROOT:-https://static.rust-lang.org/rustup}\"", "", "#XXX: If you change anything here, please make the same changes in setup_mode.rs", "usage() {", "    cat 1>&2 <<EOF", "rustup-init 1.25.1 (48d233f65 2022-07-12)", "The installer for rustup", "", "USAGE:", "    rustup-init [FLAGS] [OPTIONS]", "", "FLAGS:", "    -v, --verbose           Enable verbose output", "    -q, --quiet             Disable progress output", "    -y                      Disable confirmation prompt.", "        --no-modify-path    Don't configure the PATH environment variable", "    -h, --help              Prints help information", "    -V, --version           Prints version information", "", "OPTIONS:", "        --default-host <default-host>              Choose a default host triple", "        --default-toolchain <default-toolchain>    Choose a default toolchain to install", "        --default-toolchain none                   Do not install any toolchains", "        --profile [minimal|default|complete]       Choose a profile", "    -c, --component <components>...                Component name to also install", "    -t, --target <targets>...                      Target name to also install", "EOF", "}", "", "main() {", "    downloader --check", "    need_cmd uname", "    need_cmd mktemp", "    need_cmd chmod", "    need_cmd mkdir", "    need_cmd rm", "    need_cmd rmdir", "", "    get_architecture || return 1", "    local _arch=\"$RETVAL\"", "    assert_nz \"$_arch\" \"arch\"", "", "    local _ext=\"\"", "    case \"$_arch\" in", "        *windows*)", "            _ext=\".exe\"", "            ;;", "    esac", "", "    local _url=\"${RUSTUP_UPDATE_ROOT}/dist/${_arch}/rustup-init${_ext}\"", "", "    local _dir", "    _dir=\"$(ensure mktemp -d)\"", "    local _file=\"${_dir}/rustup-init${_ext}\"", "", "    local _ansi_escapes_are_valid=false", "    if [ -t 2 ]; then", "        if [ \"${TERM+set}\" = 'set' ]; then", "            case \"$TERM\" in", "                xterm*|rxvt*|urxvt*|linux*|vt*)", "                    _ansi_escapes_are_valid=true", "                ;;", "            esac", "        fi", "    fi", "", "    # check if we have to use /dev/tty to prompt the user", "    local need_tty=yes", "    for arg in \"$@\"; do", "        case \"$arg\" in", "            --help)", "                usage", "                exit 0", "                ;;", "            *)", "                OPTIND=1", "                if [ \"${arg%%--*}\" = \"\" ]; then", "                    # Long option (other than --help);", "                    # don't attempt to interpret it.", "                    continue", "                fi", "                while getopts :hy sub_arg \"$arg\"; do", "                    case \"$sub_arg\" in", "                        h)", "                            usage", "                            exit 0", "                            ;;", "                        y)", "                            # user wants to skip the prompt --", "                            # we don't need /dev/tty", "                            need_tty=no", "                            ;;", "                        *)", "                            ;;", "                        esac", "                done", "                ;;", "        esac", "    done", "", "    if $_ansi_escapes_are_valid; then", "        printf \"\\33[1minfo:\\33[0m downloading installer\\n\" 1>&2", "    else", "        printf '%s\\n' 'info: downloading installer' 1>&2", "    fi", "", "    ensure mkdir -p \"$_dir\"", "    ensure downloader \"$_url\" \"$_file\" \"$_arch\"", "    ensure chmod u+x \"$_file\"", "    if [ ! -x \"$_file\" ]; then", "        printf '%s\\n' \"Cannot execute $_file (likely because of mounting /tmp as noexec).\" 1>&2", "        printf '%s\\n' \"Please copy the file to a location where you can execute binaries and run ./rustup-init${_ext}.\" 1>&2", "        exit 1", "    fi", "", "    if [ \"$need_tty\" = \"yes\" ] && [ ! -t 0 ]; then", "        # The installer is going to want to ask for confirmation by", "        # reading stdin.  This script was piped into `sh` though and", "        # doesn't have stdin to pass to its children. Instead we're going", "        # to explicitly connect /dev/tty to the installer's stdin.", "        if [ ! -t 1 ]; then", "            err \"Unable to run interactively. Run with -y to accept defaults, --help for additional options\"", "        fi", "", "        ignore \"$_file\" \"$@\" < /dev/tty", "    else", "        ignore \"$_file\" \"$@\"", "    fi", "", "    local _retval=$?", "", "    ignore rm \"$_file\"", "    ignore rmdir \"$_dir\"", "", "    return \"$_retval\"", "}", "", "check_proc() {", "    # Check for /proc by looking for the /proc/self/exe link", "    # This is only run on Linux", "    if ! test -L /proc/self/exe ; then", "        err \"fatal: Unable to find /proc/self/exe.  Is /proc mounted?  Installation cannot proceed without /proc.\"", "    fi", "}", "", "get_bitness() {", "    need_cmd head", "    # Architecture detection without dependencies beyond coreutils.", "    # ELF files start out \"\\x7fELF\", and the following byte is", "    #   0x01 for 32-bit and", "    #   0x02 for 64-bit.", "    # The printf builtin on some shells like dash only supports octal", "    # escape sequences, so we use those.", "    local _current_exe_head", "    _current_exe_head=$(head -c 5 /proc/self/exe )", "    if [ \"$_current_exe_head\" = \"$(printf '\\177ELF\\001')\" ]; then", "        echo 32", "    elif [ \"$_current_exe_head\" = \"$(printf '\\177ELF\\002')\" ]; then", "        echo 64", "    else", "        err \"unknown platform bitness\"", "    fi", "}", "", "is_host_amd64_elf() {", "    need_cmd head", "    need_cmd tail", "    # ELF e_machine detection without dependencies beyond coreutils.", "    # Two-byte field at offset 0x12 indicates the CPU,", "    # but we're interested in it being 0x3E to indicate amd64, or not that.", "    local _current_exe_machine", "    _current_exe_machine=$(head -c 19 /proc/self/exe | tail -c 1)", "    [ \"$_current_exe_machine\" = \"$(printf '\\076')\" ]", "}", "", "get_endianness() {", "    local cputype=$1", "    local suffix_eb=$2", "    local suffix_el=$3", "", "    # detect endianness without od/hexdump, like get_bitness() does.", "    need_cmd head", "    need_cmd tail", "", "    local _current_exe_endianness", "    _current_exe_endianness=\"$(head -c 6 /proc/self/exe | tail -c 1)\"", "    if [ \"$_current_exe_endianness\" = \"$(printf '\\001')\" ]; then", "        echo \"${cputype}${suffix_el}\"", "    elif [ \"$_current_exe_endianness\" = \"$(printf '\\002')\" ]; then", "        echo \"${cputype}${suffix_eb}\"", "    else", "        err \"unknown platform endianness\"", "    fi", "}", "", "get_architecture() {", "    local _ostype _cputype _bitness _arch _clibtype", "    _ostype=\"$(uname -s)\"", "    _cputype=\"$(uname -m)\"", "    _clibtype=\"gnu\"", "", "    if [ \"$_ostype\" = Linux ]; then", "        if [ \"$(uname -o)\" = Android ]; then", "            _ostype=Android", "        fi", "        if ldd --version 2>&1 | grep -q 'musl'; then", "            _clibtype=\"musl\"", "        fi", "    fi", "", "    if [ \"$_ostype\" = Darwin ] && [ \"$_cputype\" = i386 ]; then", "        # Darwin `uname -m` lies", "        if sysctl hw.optional.x86_64 | grep -q ': 1'; then", "            _cputype=x86_64", "        fi", "    fi", "", "    if [ \"$_ostype\" = SunOS ]; then", "        # Both Solaris and illumos presently announce as \"SunOS\" in \"uname -s\"", "        # so use \"uname -o\" to disambiguate.  We use the full path to the", "        # system uname in case the user has coreutils uname first in PATH,", "        # which has historically sometimes printed the wrong value here.", "        if [ \"$(/usr/bin/uname -o)\" = illumos ]; then", "            _ostype=illumos", "        fi", "", "        # illumos systems have multi-arch userlands, and \"uname -m\" reports the", "        # machine hardware name; e.g., \"i86pc\" on both 32- and 64-bit x86", "        # systems.  Check for the native (widest) instruction set on the", "        # running kernel:", "        if [ \"$_cputype\" = i86pc ]; then", "            _cputype=\"$(isainfo -n)\"", "        fi", "    fi", "", "    case \"$_ostype\" in", "", "        Android)", "            _ostype=linux-android", "            ;;", "", "        Linux)", "            check_proc", "            _ostype=unknown-linux-$_clibtype", "            _bitness=$(get_bitness)", "            ;;", "", "        FreeBSD)", "            _ostype=unknown-freebsd", "            ;;", "", "        NetBSD)", "            _ostype=unknown-netbsd", "            ;;", "", "        DragonFly)", "            _ostype=unknown-dragonfly", "            ;;", "", "        Darwin)", "            _ostype=apple-darwin", "            ;;", "", "        illumos)", "            _ostype=unknown-illumos", "            ;;", "", "        MINGW* | MSYS* | CYGWIN* | Windows_NT)", "            _ostype=pc-windows-gnu", "            ;;", "", "        *)", "            err \"unrecognized OS type: $_ostype\"", "            ;;", "", "    esac", "", "    case \"$_cputype\" in", "", "        i386 | i486 | i686 | i786 | x86)", "            _cputype=i686", "            ;;", "", "        xscale | arm)", "            _cputype=arm", "            if [ \"$_ostype\" = \"linux-android\" ]; then", "                _ostype=linux-androideabi", "            fi", "            ;;", "", "        armv6l)", "            _cputype=arm", "            if [ \"$_ostype\" = \"linux-android\" ]; then", "                _ostype=linux-androideabi", "            else", "                _ostype=\"${_ostype}eabihf\"", "            fi", "            ;;", "", "        armv7l | armv8l)", "            _cputype=armv7", "            if [ \"$_ostype\" = \"linux-android\" ]; then", "                _ostype=linux-androideabi", "            else", "                _ostype=\"${_ostype}eabihf\"", "            fi", "            ;;", "", "        aarch64 | arm64)", "            _cputype=aarch64", "            ;;", "", "        x86_64 | x86-64 | x64 | amd64)", "            _cputype=x86_64", "            ;;", "", "        mips)", "            _cputype=$(get_endianness mips '' el)", "            ;;", "", "        mips64)", "            if [ \"$_bitness\" -eq 64 ]; then", "                # only n64 ABI is supported for now", "                _ostype=\"${_ostype}abi64\"", "                _cputype=$(get_endianness mips64 '' el)", "            fi", "            ;;", "", "        ppc)", "            _cputype=powerpc", "            ;;", "", "        ppc64)", "            _cputype=powerpc64", "            ;;", "", "        ppc64le)", "            _cputype=powerpc64le", "            ;;", "", "        s390x)", "            _cputype=s390x", "            ;;", "        riscv64)", "            _cputype=riscv64gc", "            ;;", "        *)", "            err \"unknown CPU type: $_cputype\"", "", "    esac", "", "    # Detect 64-bit linux with 32-bit userland", "    if [ \"${_ostype}\" = unknown-linux-gnu ] && [ \"${_bitness}\" -eq 32 ]; then", "        case $_cputype in", "            x86_64)", "                if [ -n \"${RUSTUP_CPUTYPE:-}\" ]; then", "                    _cputype=\"$RUSTUP_CPUTYPE\"", "                else {", "                    # 32-bit executable for amd64 = x32", "                    if is_host_amd64_elf; then {", "                         echo \"This host is running an x32 userland; as it stands, x32 support is poor,\" 1>&2", "                         echo \"and there isn't a native toolchain -- you will have to install\" 1>&2", "                         echo \"multiarch compatibility with i686 and/or amd64, then select one\" 1>&2", "                         echo \"by re-running this script with the RUSTUP_CPUTYPE environment variable\" 1>&2", "                         echo \"set to i686 or x86_64, respectively.\" 1>&2", "                         echo 1>&2", "                         echo \"You will be able to add an x32 target after installation by running\" 1>&2", "                         echo \"  rustup target add x86_64-unknown-linux-gnux32\" 1>&2", "                         exit 1", "                    }; else", "                        _cputype=i686", "                    fi", "                }; fi", "                ;;", "            mips64)", "                _cputype=$(get_endianness mips '' el)", "                ;;", "            powerpc64)", "                _cputype=powerpc", "                ;;", "            aarch64)", "                _cputype=armv7", "                if [ \"$_ostype\" = \"linux-android\" ]; then", "                    _ostype=linux-androideabi", "                else", "                    _ostype=\"${_ostype}eabihf\"", "                fi", "                ;;", "            riscv64gc)", "                err \"riscv64 with 32-bit userland unsupported\"", "                ;;", "        esac", "    fi", "", "    # Detect armv7 but without the CPU features Rust needs in that build,", "    # and fall back to arm.", "    # See https://github.com/rust-lang/rustup.rs/issues/587.", "    if [ \"$_ostype\" = \"unknown-linux-gnueabihf\" ] && [ \"$_cputype\" = armv7 ]; then", "        if ensure grep '^Features' /proc/cpuinfo | grep -q -v neon; then", "            # At least one processor does not have NEON.", "            _cputype=arm", "        fi", "    fi", "", "    _arch=\"${_cputype}-${_ostype}\"", "", "    RETVAL=\"$_arch\"", "}", "", "say() {", "    printf 'rustup: %s\\n' \"$1\"", "}", "", "err() {", "    say \"$1\" >&2", "    exit 1", "}", "", "need_cmd() {", "    if ! check_cmd \"$1\"; then", "        err \"need '$1' (command not found)\"", "    fi", "}", "", "check_cmd() {", "    command -v \"$1\" > /dev/null 2>&1", "}", "", "assert_nz() {", "    if [ -z \"$1\" ]; then err \"assert_nz $2\"; fi", "}", "", "# Run a command that should never fail. If the command fails execution", "# will immediately terminate with an error showing the failing", "# command.", "ensure() {", "    if ! \"$@\"; then err \"command failed: $*\"; fi", "}", "", "# This is just for indicating that commands' results are being", "# intentionally ignored. Usually, because it's being executed", "# as part of error handling.", "ignore() {", "    \"$@\"", "}", "", "# This wraps curl or wget. Try curl first, if not installed,", "# use wget instead.", "downloader() {", "    local _dld", "    local _ciphersuites", "    local _err", "    local _status", "    local _retry", "    if check_cmd curl; then", "        _dld=curl", "    elif check_cmd wget; then", "        _dld=wget", "    else", "        _dld='curl or wget' # to be used in error message of need_cmd", "    fi", "", "    if [ \"$1\" = --check ]; then", "        need_cmd \"$_dld\"", "    elif [ \"$_dld\" = curl ]; then", "        check_curl_for_retry_support", "        _retry=\"$RETVAL\"", "        get_ciphersuites_for_curl", "        _ciphersuites=\"$RETVAL\"", "        if [ -n \"$_ciphersuites\" ]; then", "            _err=$(curl $_retry --proto '=https' --tlsv1.2 --ciphers \"$_ciphersuites\" --silent --show-error --fail --location \"$1\" --output \"$2\" 2>&1)", "            _status=$?", "        else", "            echo \"Warning: Not enforcing strong cipher suites for TLS, this is potentially less secure\"", "            if ! check_help_for \"$3\" curl --proto --tlsv1.2; then", "                echo \"Warning: Not enforcing TLS v1.2, this is potentially less secure\"", "                _err=$(curl $_retry --silent --show-error --fail --location \"$1\" --output \"$2\" 2>&1)", "                _status=$?", "            else", "                _err=$(curl $_retry --proto '=https' --tlsv1.2 --silent --show-error --fail --location \"$1\" --output \"$2\" 2>&1)", "                _status=$?", "            fi", "        fi", "        if [ -n \"$_err\" ]; then", "            echo \"$_err\" >&2", "            if echo \"$_err\" | grep -q 404$; then", "                err \"installer for platform '$3' not found, this may be unsupported\"", "            fi", "        fi", "        return $_status", "    elif [ \"$_dld\" = wget ]; then", "        if [ \"$(wget -V 2>&1|head -2|tail -1|cut -f1 -d\" \")\" = \"BusyBox\" ]; then", "            echo \"Warning: using the BusyBox version of wget.  Not enforcing strong cipher suites for TLS or TLS v1.2, this is potentially less secure\"", "            _err=$(wget \"$1\" -O \"$2\" 2>&1)", "            _status=$?", "        else", "            get_ciphersuites_for_wget", "            _ciphersuites=\"$RETVAL\"", "            if [ -n \"$_ciphersuites\" ]; then", "                _err=$(wget --https-only --secure-protocol=TLSv1_2 --ciphers \"$_ciphersuites\" \"$1\" -O \"$2\" 2>&1)", "                _status=$?", "            else", "                echo \"Warning: Not enforcing strong cipher suites for TLS, this is potentially less secure\"", "                if ! check_help_for \"$3\" wget --https-only --secure-protocol; then", "                    echo \"Warning: Not enforcing TLS v1.2, this is potentially less secure\"", "                    _err=$(wget \"$1\" -O \"$2\" 2>&1)", "                    _status=$?", "                else", "                    _err=$(wget --https-only --secure-protocol=TLSv1_2 \"$1\" -O \"$2\" 2>&1)", "                    _status=$?", "                fi", "            fi", "        fi", "        if [ -n \"$_err\" ]; then", "            echo \"$_err\" >&2", "            if echo \"$_err\" | grep -q ' 404 Not Found$'; then", "                err \"installer for platform '$3' not found, this may be unsupported\"", "            fi", "        fi", "        return $_status", "    else", "        err \"Unknown downloader\"   # should not reach here", "    fi", "}", "", "check_help_for() {", "    local _arch", "    local _cmd", "    local _arg", "    _arch=\"$1\"", "    shift", "    _cmd=\"$1\"", "    shift", "", "    local _category", "    if \"$_cmd\" --help | grep -q 'For all options use the manual or \"--help all\".'; then", "      _category=\"all\"", "    else", "      _category=\"\"", "    fi", "", "    case \"$_arch\" in", "", "        *darwin*)", "        if check_cmd sw_vers; then", "            case $(sw_vers -productVersion) in", "                10.*)", "                    # If we're running on macOS, older than 10.13, then we always", "                    # fail to find these options to force fallback", "                    if [ \"$(sw_vers -productVersion | cut -d. -f2)\" -lt 13 ]; then", "                        # Older than 10.13", "                        echo \"Warning: Detected macOS platform older than 10.13\"", "                        return 1", "                    fi", "                    ;;", "                11.*)", "                    # We assume Big Sur will be OK for now", "                    ;;", "                *)", "                    # Unknown product version, warn and continue", "                    echo \"Warning: Detected unknown macOS major version: $(sw_vers -productVersion)\"", "                    echo \"Warning TLS capabilities detection may fail\"", "                    ;;", "            esac", "        fi", "        ;;", "", "    esac", "", "    for _arg in \"$@\"; do", "        if ! \"$_cmd\" --help $_category | grep -q -- \"$_arg\"; then", "            return 1", "        fi", "    done", "", "    true # not strictly needed", "}", "", "# Check if curl supports the --retry flag, then pass it to the curl invocation.", "check_curl_for_retry_support() {", "  local _retry_supported=\"\"", "  # \"unspecified\" is for arch, allows for possibility old OS using macports, homebrew, etc.", "  if check_help_for \"notspecified\" \"curl\" \"--retry\"; then", "    _retry_supported=\"--retry 3\"", "  fi", "", "  RETVAL=\"$_retry_supported\"", "", "}", "", "# Return cipher suite string specified by user, otherwise return strong TLS 1.2-1.3 cipher suites", "# if support by local tools is detected. Detection currently supports these curl backends:", "# GnuTLS and OpenSSL (possibly also LibreSSL and BoringSSL). Return value can be empty.", "get_ciphersuites_for_curl() {", "    if [ -n \"${RUSTUP_TLS_CIPHERSUITES-}\" ]; then", "        # user specified custom cipher suites, assume they know what they're doing", "        RETVAL=\"$RUSTUP_TLS_CIPHERSUITES\"", "        return", "    fi", "", "    local _openssl_syntax=\"no\"", "    local _gnutls_syntax=\"no\"", "    local _backend_supported=\"yes\"", "    if curl -V | grep -q ' OpenSSL/'; then", "        _openssl_syntax=\"yes\"", "    elif curl -V | grep -iq ' LibreSSL/'; then", "        _openssl_syntax=\"yes\"", "    elif curl -V | grep -iq ' BoringSSL/'; then", "        _openssl_syntax=\"yes\"", "    elif curl -V | grep -iq ' GnuTLS/'; then", "        _gnutls_syntax=\"yes\"", "    else", "        _backend_supported=\"no\"", "    fi", "", "    local _args_supported=\"no\"", "    if [ \"$_backend_supported\" = \"yes\" ]; then", "        # \"unspecified\" is for arch, allows for possibility old OS using macports, homebrew, etc.", "        if check_help_for \"notspecified\" \"curl\" \"--tlsv1.2\" \"--ciphers\" \"--proto\"; then", "            _args_supported=\"yes\"", "        fi", "    fi", "", "    local _cs=\"\"", "    if [ \"$_args_supported\" = \"yes\" ]; then", "        if [ \"$_openssl_syntax\" = \"yes\" ]; then", "            _cs=$(get_strong_ciphersuites_for \"openssl\")", "        elif [ \"$_gnutls_syntax\" = \"yes\" ]; then", "            _cs=$(get_strong_ciphersuites_for \"gnutls\")", "        fi", "    fi", "", "    RETVAL=\"$_cs\"", "}", "", "# Return cipher suite string specified by user, otherwise return strong TLS 1.2-1.3 cipher suites", "# if support by local tools is detected. Detection currently supports these wget backends:", "# GnuTLS and OpenSSL (possibly also LibreSSL and BoringSSL). Return value can be empty.", "get_ciphersuites_for_wget() {", "    if [ -n \"${RUSTUP_TLS_CIPHERSUITES-}\" ]; then", "        # user specified custom cipher suites, assume they know what they're doing", "        RETVAL=\"$RUSTUP_TLS_CIPHERSUITES\"", "        return", "    fi", "", "    local _cs=\"\"", "    if wget -V | grep -q '\\-DHAVE_LIBSSL'; then", "        # \"unspecified\" is for arch, allows for possibility old OS using macports, homebrew, etc.", "        if check_help_for \"notspecified\" \"wget\" \"TLSv1_2\" \"--ciphers\" \"--https-only\" \"--secure-protocol\"; then", "            _cs=$(get_strong_ciphersuites_for \"openssl\")", "        fi", "    elif wget -V | grep -q '\\-DHAVE_LIBGNUTLS'; then", "        # \"unspecified\" is for arch, allows for possibility old OS using macports, homebrew, etc.", "        if check_help_for \"notspecified\" \"wget\" \"TLSv1_2\" \"--ciphers\" \"--https-only\" \"--secure-protocol\"; then", "            _cs=$(get_strong_ciphersuites_for \"gnutls\")", "        fi", "    fi", "", "    RETVAL=\"$_cs\"", "}", "", "# Return strong TLS 1.2-1.3 cipher suites in OpenSSL or GnuTLS syntax. TLS 1.2", "# excludes non-ECDHE and non-AEAD cipher suites. DHE is excluded due to bad", "# DH params often found on servers (see RFC 7919). Sequence matches or is", "# similar to Firefox 68 ESR with weak cipher suites disabled via about:config.", "# $1 must be openssl or gnutls.", "get_strong_ciphersuites_for() {", "    if [ \"$1\" = \"openssl\" ]; then", "        # OpenSSL is forgiving of unknown values, no problems with TLS 1.3 values on versions that don't support it yet.", "        echo \"TLS_AES_128_GCM_SHA256:TLS_CHACHA20_POLY1305_SHA256:TLS_AES_256_GCM_SHA384:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384\"", "    elif [ \"$1\" = \"gnutls\" ]; then", "        # GnuTLS isn't forgiving of unknown values, so this may require a GnuTLS version that supports TLS 1.3 even if wget doesn't.", "        # Begin with SECURE128 (and higher) then remove/add to build cipher suites. Produces same 9 cipher suites as OpenSSL but in slightly different order.", "        echo \"SECURE128:-VERS-SSL3.0:-VERS-TLS1.0:-VERS-TLS1.1:-VERS-DTLS-ALL:-CIPHER-ALL:-MAC-ALL:-KX-ALL:+AEAD:+ECDHE-ECDSA:+ECDHE-RSA:+AES-128-GCM:+CHACHA20-POLY1305:+AES-256-GCM\"", "    fi", "}", "", "main \"$@\" || exit 1", "curl: (6) Could not resolve host: |", "curl: (6) Could not resolve host: sh"]}
2022-12-30 00:15:50,165 p=92375 u=kal n=ansible | PLAY RECAP *******************************************************************************************************************************************
2022-12-30 00:15:50,165 p=92375 u=kal n=ansible | krpz                       : ok=1    changed=0    unreachable=0    failed=1    skipped=0    rescued=0    ignored=0   
2022-12-31 00:06:06,367 p=10293 u=kal n=ansible | PLAY [localhost] ***************************************************************
2022-12-31 00:06:06,375 p=10293 u=kal n=ansible | TASK [Gathering Facts] *********************************************************
2022-12-31 00:06:06,599 p=10293 u=kal n=ansible | fatal: [krpz]: FAILED! => {"ansible_facts": {}, "changed": false, "failed_modules": {"ansible.legacy.setup": {"failed": true, "module_stderr": "sudo: a password is required\n", "module_stdout": "", "msg": "MODULE FAILURE\nSee stdout/stderr for the exact error", "rc": 1}}, "msg": "The following modules failed to execute: ansible.legacy.setup\n"}
2022-12-31 00:06:06,599 p=10293 u=kal n=ansible | PLAY RECAP *********************************************************************
2022-12-31 00:06:06,599 p=10293 u=kal n=ansible | krpz                       : ok=0    changed=0    unreachable=0    failed=1    skipped=0    rescued=0    ignored=0   
2022-12-31 00:06:20,026 p=11103 u=kal n=ansible | PLAY [localhost] ***************************************************************
2022-12-31 00:06:20,033 p=11103 u=kal n=ansible | TASK [Gathering Facts] *********************************************************
2022-12-31 00:06:24,008 p=11103 u=kal n=ansible | ok: [krpz]
2022-12-31 00:06:24,029 p=11103 u=kal n=ansible | TASK [Download Rust] ***********************************************************
2022-12-31 00:06:25,505 p=11103 u=kal n=ansible | ok: [krpz]
2022-12-31 00:06:25,518 p=11103 u=kal n=ansible | TASK [Install Rust] ************************************************************
2022-12-31 00:08:36,332 p=11103 u=kal n=ansible |  [ERROR]: User interrupted execution

2022-12-31 00:08:37,600 p=11591 u=kal n=ansible | ERROR! We were unable to read either as JSON nor YAML, these are the errors we got from each:
JSON: Expecting value: line 1 column 1 (char 0)

Syntax Error while loading YAML.
  did not find expected key

The error appears to be in '/home/kal/MyApplications/dotfiles/playbooks/all.yaml': line 80, column 5, but may
be elsewhere in the file depending on the exact syntax problem.

The offending line appears to be:

  - name: Install Rust
    - shell:
    ^ here

2022-12-31 00:08:46,229 p=11609 u=kal n=ansible | ERROR! We were unable to read either as JSON nor YAML, these are the errors we got from each:
JSON: Expecting value: line 1 column 1 (char 0)

Syntax Error while loading YAML.
  did not find expected key

The error appears to be in '/home/kal/MyApplications/dotfiles/playbooks/all.yaml': line 83, column 5, but may
be elsewhere in the file depending on the exact syntax problem.

The offending line appears to be:

      register: rust-inst
    - debug: var=rust-inst.stdout_lines
    ^ here

2022-12-31 00:08:55,815 p=11626 u=kal n=ansible | ERROR! We were unable to read either as JSON nor YAML, these are the errors we got from each:
JSON: Expecting value: line 1 column 1 (char 0)

Syntax Error while loading YAML.
  did not find expected key

The error appears to be in '/home/kal/MyApplications/dotfiles/playbooks/all.yaml': line 86, column 5, but may
be elsewhere in the file depending on the exact syntax problem.

The offending line appears to be:


    - debug: var=ps.stdout_lines
    ^ here

2022-12-31 00:09:12,502 p=11653 u=kal n=ansible | ERROR! We were unable to read either as JSON nor YAML, these are the errors we got from each:
JSON: Expecting value: line 1 column 1 (char 0)

Syntax Error while loading YAML.
  did not find expected key

The error appears to be in '/home/kal/MyApplications/dotfiles/playbooks/all.yaml': line 83, column 5, but may
be elsewhere in the file depending on the exact syntax problem.

The offending line appears to be:

      register: rust-inst
    - debug: var=rust-inst.stdout_lines
    ^ here

2022-12-31 00:09:24,636 p=11670 u=kal n=ansible | ERROR! conflicting action statements: shell, debug

The error appears to be in '/home/kal/MyApplications/dotfiles/playbooks/all.yaml': line 79, column 5, but may
be elsewhere in the file depending on the exact syntax problem.

The offending line appears to be:

      mode: '0774'
  - name: Install Rust
    ^ here

2022-12-31 00:09:30,796 p=11686 u=kal n=ansible | PLAY [localhost] ***************************************************************
2022-12-31 00:09:30,803 p=11686 u=kal n=ansible | TASK [Gathering Facts] *********************************************************
2022-12-31 00:09:34,749 p=11686 u=kal n=ansible | ok: [krpz]
2022-12-31 00:09:34,771 p=11686 u=kal n=ansible | TASK [Download Rust] ***********************************************************
2022-12-31 00:09:41,195 p=11686 u=kal n=ansible | ok: [krpz]
2022-12-31 00:09:41,210 p=11686 u=kal n=ansible | TASK [Install Rust] ************************************************************
2022-12-31 00:09:41,407 p=11686 u=kal n=ansible | fatal: [krpz]: FAILED! => {"changed": false, "msg": "Unsupported parameters for (ansible.legacy.command) module: debug, register. Supported parameters include: executable, chdir, strip_empty_ends, _raw_params, removes, argv, creates, _uses_shell, stdin_add_newline, stdin."}
2022-12-31 00:09:41,407 p=11686 u=kal n=ansible | PLAY RECAP *********************************************************************
2022-12-31 00:09:41,407 p=11686 u=kal n=ansible | krpz                       : ok=2    changed=0    unreachable=0    failed=1    skipped=0    rescued=0    ignored=0   
2022-12-31 00:10:46,375 p=11945 u=kal n=ansible | ERROR! We were unable to read either as JSON nor YAML, these are the errors we got from each:
JSON: Expecting value: line 1 column 1 (char 0)

Syntax Error while loading YAML.
  did not find expected key

The error appears to be in '/home/kal/MyApplications/dotfiles/playbooks/all.yaml': line 80, column 5, but may
be elsewhere in the file depending on the exact syntax problem.

The offending line appears to be:

  - name: Install Rust
    - shell: ps -eo pcpu,user,args | sort -r -k1 | head -n5
    ^ here

2022-12-31 00:10:52,950 p=11962 u=kal n=ansible | ERROR! We were unable to read either as JSON nor YAML, these are the errors we got from each:
JSON: Expecting value: line 1 column 1 (char 0)

Syntax Error while loading YAML.
  mapping values are not allowed in this context

The error appears to be in '/home/kal/MyApplications/dotfiles/playbooks/all.yaml': line 81, column 15, but may
be elsewhere in the file depending on the exact syntax problem.

The offending line appears to be:

    shell: ps -eo pcpu,user,args | sort -r -k1 | head -n5
      register: ps
              ^ here

2022-12-31 00:10:58,322 p=11975 u=kal n=ansible | ERROR! We were unable to read either as JSON nor YAML, these are the errors we got from each:
JSON: Expecting value: line 1 column 1 (char 0)

Syntax Error while loading YAML.
  did not find expected key

The error appears to be in '/home/kal/MyApplications/dotfiles/playbooks/all.yaml': line 83, column 5, but may
be elsewhere in the file depending on the exact syntax problem.

The offending line appears to be:


    - debug: var=ps.stdout_lines
    ^ here

2022-12-31 00:11:05,346 p=11993 u=kal n=ansible | ERROR! conflicting action statements: shell, debug

The error appears to be in '/home/kal/MyApplications/dotfiles/playbooks/all.yaml': line 79, column 5, but may
be elsewhere in the file depending on the exact syntax problem.

The offending line appears to be:

      mode: '0774'
  - name: Install Rust
    ^ here

2022-12-31 00:11:35,948 p=12039 u=kal n=ansible | PLAY [localhost] ***************************************************************
2022-12-31 00:11:35,955 p=12039 u=kal n=ansible | TASK [Gathering Facts] *********************************************************
2022-12-31 00:11:39,912 p=12039 u=kal n=ansible | ok: [krpz]
2022-12-31 00:11:39,939 p=12039 u=kal n=ansible | TASK [Download Rust] ***********************************************************
2022-12-31 00:11:46,451 p=12039 u=kal n=ansible | ok: [krpz]
2022-12-31 00:11:46,484 p=12039 u=kal n=ansible | TASK [Install Rust] ************************************************************
2022-12-31 00:11:46,677 p=12039 u=kal n=ansible | fatal: [krpz]: FAILED! => {"changed": false, "msg": "Unsupported parameters for (ansible.legacy.command) module: debug, register. Supported parameters include: executable, chdir, strip_empty_ends, _raw_params, removes, argv, creates, _uses_shell, stdin_add_newline, stdin."}
2022-12-31 00:11:46,677 p=12039 u=kal n=ansible | PLAY RECAP *********************************************************************
2022-12-31 00:11:46,678 p=12039 u=kal n=ansible | krpz                       : ok=2    changed=0    unreachable=0    failed=1    skipped=0    rescued=0    ignored=0   
2022-12-31 00:12:02,087 p=12251 u=kal n=ansible | PLAY [localhost] ***************************************************************
2022-12-31 00:12:02,094 p=12251 u=kal n=ansible | TASK [Gathering Facts] *********************************************************
2022-12-31 00:12:06,026 p=12251 u=kal n=ansible | ok: [krpz]
2022-12-31 00:12:06,047 p=12251 u=kal n=ansible | TASK [Download Rust] ***********************************************************
2022-12-31 00:12:11,515 p=12251 u=kal n=ansible | ok: [krpz]
2022-12-31 00:12:11,523 p=12251 u=kal n=ansible | TASK [Install Rust] ************************************************************
2022-12-31 00:12:11,699 p=12251 u=kal n=ansible | fatal: [krpz]: FAILED! => {"changed": false, "msg": "Unsupported parameters for (ansible.legacy.command) module: register. Supported parameters include: executable, chdir, strip_empty_ends, _raw_params, removes, argv, creates, _uses_shell, stdin_add_newline, stdin."}
2022-12-31 00:12:11,700 p=12251 u=kal n=ansible | PLAY RECAP *********************************************************************
2022-12-31 00:12:11,700 p=12251 u=kal n=ansible | krpz                       : ok=2    changed=0    unreachable=0    failed=1    skipped=0    rescued=0    ignored=0   
2022-12-31 00:12:23,614 p=12458 u=kal n=ansible | PLAY [localhost] ***************************************************************
2022-12-31 00:12:23,621 p=12458 u=kal n=ansible | TASK [Gathering Facts] *********************************************************
2022-12-31 00:12:27,520 p=12458 u=kal n=ansible | ok: [krpz]
2022-12-31 00:12:27,544 p=12458 u=kal n=ansible | TASK [Download Rust] ***********************************************************
2022-12-31 00:12:29,869 p=12458 u=kal n=ansible | ok: [krpz]
2022-12-31 00:12:29,877 p=12458 u=kal n=ansible | TASK [Install Rust] ************************************************************
2022-12-31 00:12:30,072 p=12458 u=kal n=ansible | changed: [krpz]
2022-12-31 00:12:30,081 p=12458 u=kal n=ansible | TASK [See Rust installations] **************************************************
2022-12-31 00:12:30,095 p=12458 u=kal n=ansible | ok: [krpz] => {
    "ps.stdout_lines": "VARIABLE IS NOT DEFINED!"
}
2022-12-31 00:12:30,102 p=12458 u=kal n=ansible | TASK [Source Rust] *************************************************************
2022-12-31 00:12:30,189 p=12458 u=kal n=ansible | fatal: [krpz]: FAILED! => {"changed": true, "cmd": "source \"$HOME/.cargo/bin\"", "delta": "0:00:00.001455", "end": "2022-12-31 00:12:30.177556", "msg": "non-zero return code", "rc": 127, "start": "2022-12-31 00:12:30.176101", "stderr": "/bin/sh: 1: source: not found", "stderr_lines": ["/bin/sh: 1: source: not found"], "stdout": "", "stdout_lines": []}
2022-12-31 00:12:30,190 p=12458 u=kal n=ansible | PLAY RECAP *********************************************************************
2022-12-31 00:12:30,190 p=12458 u=kal n=ansible | krpz                       : ok=4    changed=1    unreachable=0    failed=1    skipped=0    rescued=0    ignored=0   
2022-12-31 00:13:14,485 p=12739 u=kal n=ansible | PLAY [localhost] ***************************************************************
2022-12-31 00:13:14,492 p=12739 u=kal n=ansible | TASK [Gathering Facts] *********************************************************
2022-12-31 00:13:18,399 p=12739 u=kal n=ansible | ok: [krpz]
2022-12-31 00:13:18,421 p=12739 u=kal n=ansible | TASK [Download Rust] ***********************************************************
2022-12-31 00:13:33,331 p=12739 u=kal n=ansible | ok: [krpz]
2022-12-31 00:13:33,342 p=12739 u=kal n=ansible | TASK [Install Rust] ************************************************************
2022-12-31 00:13:33,530 p=12739 u=kal n=ansible | changed: [krpz]
2022-12-31 00:13:33,537 p=12739 u=kal n=ansible | TASK [See Rust installations] **************************************************
2022-12-31 00:13:33,551 p=12739 u=kal n=ansible | ok: [krpz] => {
    "ps.stdout_lines": [
        "%CPU USER     COMMAND",
        " 4.2 kal      /usr/share/code/code --type=renderer --enable-crashpad --crashpad-handler-pid=6333 --enable-crash-reporter=bb7bdbe8-da8c-4174-8a55-1bef2416e066,no_channel --user-data-dir=/home/kal/.config/Code --standard-schemes=vscode-webview,vscode-file --secure-schemes=vscode-webview,vscode-file --bypasscsp-schemes --cors-schemes=vscode-webview,vscode-file --fetch-schemes=vscode-webview,vscode-file --service-worker-schemes=vscode-webview --streaming-schemes --app-path=/usr/share/code/resources/app --no-sandbox --no-zygote --enable-blink-features=HighlightAPI --lang=en-US --num-raster-threads=4 --enable-main-frame-before-activation --renderer-client-id=4 --launch-time-ticks=78338872 --shared-files=v8_context_snapshot_data:100 --field-trial-handle=0,i,16315905182003681463,18033888280813323940,131072 --disable-features=CalculateNativeWinOcclusion,SpareRendererForSitePerProcess --vscode-window-config=vscode:04f77814-3810-4b0d-99ec-ec0ce775ad7f --enable-crashpad",
        " 3.9 kal      /usr/bin/gnome-shell",
        " 3.7 kal      /usr/lib/xorg/Xorg vt2 -displayfd 3 -auth /run/user/1000/gdm/Xauthority -nolisten tcp -background none -noreset -keeptty -novtswitch -verbose 3",
        " 3.1 root     [kworker/10:1-events]"
    ]
}
2022-12-31 00:13:33,559 p=12739 u=kal n=ansible | TASK [Source Rust] *************************************************************
2022-12-31 00:13:33,646 p=12739 u=kal n=ansible | fatal: [krpz]: FAILED! => {"changed": true, "cmd": "source \"$HOME/.cargo/bin\"", "delta": "0:00:00.001449", "end": "2022-12-31 00:13:33.633532", "msg": "non-zero return code", "rc": 127, "start": "2022-12-31 00:13:33.632083", "stderr": "/bin/sh: 1: source: not found", "stderr_lines": ["/bin/sh: 1: source: not found"], "stdout": "", "stdout_lines": []}
2022-12-31 00:13:33,646 p=12739 u=kal n=ansible | PLAY RECAP *********************************************************************
2022-12-31 00:13:33,647 p=12739 u=kal n=ansible | krpz                       : ok=4    changed=1    unreachable=0    failed=1    skipped=0    rescued=0    ignored=0   
2022-12-31 00:14:37,516 p=13061 u=kal n=ansible | PLAY [localhost] ***************************************************************
2022-12-31 00:14:37,523 p=13061 u=kal n=ansible | TASK [Gathering Facts] *********************************************************
2022-12-31 00:14:41,394 p=13061 u=kal n=ansible | ok: [krpz]
2022-12-31 00:14:41,416 p=13061 u=kal n=ansible | TASK [Download Rust] ***********************************************************
2022-12-31 00:14:46,777 p=13061 u=kal n=ansible | ok: [krpz]
2022-12-31 00:14:46,786 p=13061 u=kal n=ansible | TASK [Install Rust] ************************************************************
2022-12-31 00:15:04,579 p=13061 u=kal n=ansible | changed: [krpz]
2022-12-31 00:15:04,586 p=13061 u=kal n=ansible | TASK [See Rust installations] **************************************************
2022-12-31 00:15:04,601 p=13061 u=kal n=ansible | ok: [krpz] => {
    "r.stdout_lines": [
        "",
        "  stable-x86_64-unknown-linux-gnu installed - rustc 1.66.0 (69f9c33d7 2022-12-12)",
        "",
        "",
        "Rust is installed now. Great!",
        "",
        "To get started you may need to restart your current shell.",
        "This would reload your PATH environment variable to include",
        "Cargo's bin directory ($HOME/.cargo/bin).",
        "",
        "To configure your current shell, run:",
        "source \"$HOME/.cargo/env\""
    ]
}
2022-12-31 00:15:04,629 p=13061 u=kal n=ansible | PLAY RECAP *********************************************************************
2022-12-31 00:15:04,629 p=13061 u=kal n=ansible | krpz                       : ok=4    changed=1    unreachable=0    failed=0    skipped=0    rescued=0    ignored=0   
2022-12-31 00:16:25,850 p=13460 u=kal n=ansible | PLAY [localhost] *************************************************************************************************************************************
2022-12-31 00:16:25,856 p=13460 u=kal n=ansible | TASK [Gathering Facts] *******************************************************************************************************************************
2022-12-31 00:16:29,784 p=13460 u=kal n=ansible | ok: [krpz]
2022-12-31 00:16:29,805 p=13460 u=kal n=ansible | TASK [Creates directory] *****************************************************************************************************************************
2022-12-31 00:16:29,815 p=13460 u=kal n=ansible | fatal: [krpz]: FAILED! => {"msg": "the field 'become' has an invalid value ({{ ansible_user }}), and could not be converted to an bool.The error was: The value 'kal' is not a valid boolean.  Valid booleans include: 0, 1, 'no', 'n', 'f', 'yes', 'true', '1', 't', 'off', 'false', 'y', '0', 'on'. The value 'kal' is not a valid boolean.  Valid booleans include: 0, 1, 'no', 'n', 'f', 'yes', 'true', '1', 't', 'off', 'false', 'y', '0', 'on'"}
2022-12-31 00:16:29,816 p=13460 u=kal n=ansible | PLAY RECAP *******************************************************************************************************************************************
2022-12-31 00:16:29,816 p=13460 u=kal n=ansible | krpz                       : ok=1    changed=0    unreachable=0    failed=1    skipped=0    rescued=0    ignored=0   
2022-12-31 00:16:42,621 p=13603 u=kal n=ansible | PLAY [localhost] *************************************************************************************************************************************
2022-12-31 00:16:42,628 p=13603 u=kal n=ansible | TASK [Gathering Facts] *******************************************************************************************************************************
2022-12-31 00:16:46,572 p=13603 u=kal n=ansible | ok: [krpz]
2022-12-31 00:16:46,593 p=13603 u=kal n=ansible | TASK [Creates directory] *****************************************************************************************************************************
2022-12-31 00:16:46,603 p=13603 u=kal n=ansible | fatal: [krpz]: FAILED! => {"msg": "the field 'become' has an invalid value ({{ ansible_user }}), and could not be converted to an bool.The error was: The value 'kal' is not a valid boolean.  Valid booleans include: 0, 'yes', 'true', 1, 'n', 'y', 'no', 't', 'f', '0', '1', 'false', 'off', 'on'. The value 'kal' is not a valid boolean.  Valid booleans include: 0, 'yes', 'true', 1, 'n', 'y', 'no', 't', 'f', '0', '1', 'false', 'off', 'on'"}
2022-12-31 00:16:46,604 p=13603 u=kal n=ansible | PLAY RECAP *******************************************************************************************************************************************
2022-12-31 00:16:46,604 p=13603 u=kal n=ansible | krpz                       : ok=1    changed=0    unreachable=0    failed=1    skipped=0    rescued=0    ignored=0   
2022-12-31 00:17:13,066 p=13766 u=kal n=ansible | PLAY [localhost] *************************************************************************************************************************************
2022-12-31 00:17:13,072 p=13766 u=kal n=ansible | TASK [Gathering Facts] *******************************************************************************************************************************
2022-12-31 00:17:18,252 p=13766 u=kal n=ansible | ok: [krpz]
2022-12-31 00:17:18,273 p=13766 u=kal n=ansible | TASK [Creates directory] *****************************************************************************************************************************
2022-12-31 00:17:18,449 p=13766 u=kal n=ansible | fatal: [krpz]: FAILED! => {"changed": false, "msg": "There was an issue creating /home/\"kal\" as requested: [Errno 13] Permission denied: '/home/\"kal\"'", "path": "/home/\"kal\"/MyApplications/bin"}
2022-12-31 00:17:18,450 p=13766 u=kal n=ansible | PLAY RECAP *******************************************************************************************************************************************
2022-12-31 00:17:18,450 p=13766 u=kal n=ansible | krpz                       : ok=1    changed=0    unreachable=0    failed=1    skipped=0    rescued=0    ignored=0   
2022-12-31 00:17:31,176 p=13921 u=kal n=ansible | PLAY [localhost] *************************************************************************************************************************************
2022-12-31 00:17:31,183 p=13921 u=kal n=ansible | TASK [Gathering Facts] *******************************************************************************************************************************
2022-12-31 00:17:33,663 p=13921 u=kal n=ansible | ok: [krpz]
2022-12-31 00:17:33,684 p=13921 u=kal n=ansible | TASK [Creates directory] *****************************************************************************************************************************
2022-12-31 00:17:33,861 p=13921 u=kal n=ansible | changed: [krpz]
2022-12-31 00:17:33,888 p=13921 u=kal n=ansible | PLAY RECAP *******************************************************************************************************************************************
2022-12-31 00:17:33,889 p=13921 u=kal n=ansible | krpz                       : ok=2    changed=1    unreachable=0    failed=0    skipped=0    rescued=0    ignored=0   
2022-12-31 00:18:36,188 p=14163 u=kal n=ansible | PLAY [localhost] *************************************************************************************************************************************
2022-12-31 00:18:36,195 p=14163 u=kal n=ansible | TASK [Gathering Facts] *******************************************************************************************************************************
2022-12-31 00:18:40,166 p=14163 u=kal n=ansible | ok: [krpz]
2022-12-31 00:18:40,190 p=14163 u=kal n=ansible | TASK [Creates directory] *****************************************************************************************************************************
2022-12-31 00:18:40,365 p=14163 u=kal n=ansible | changed: [krpz]
2022-12-31 00:18:40,393 p=14163 u=kal n=ansible | PLAY RECAP *******************************************************************************************************************************************
2022-12-31 00:18:40,393 p=14163 u=kal n=ansible | krpz                       : ok=2    changed=1    unreachable=0    failed=0    skipped=0    rescued=0    ignored=0   
2022-12-31 00:41:44,496 p=20388 u=kal n=ansible | [WARNING]: While constructing a mapping from /home/kal/MyApplications/dotfiles/playbooks/test.yaml, line 4, column 5, found a duplicate dict key
(name). Using last defined value only.

2022-12-31 00:41:44,545 p=20388 u=kal n=ansible | ERROR! The field 'name' is supposed to be a string type, however the incoming data structure is a <class 'ansible.parsing.yaml.objects.AnsibleSequence'>

The error appears to be in '/home/kal/MyApplications/dotfiles/playbooks/test.yaml': line 4, column 5, but may
be elsewhere in the file depending on the exact syntax problem.

The offending line appears to be:

  tasks:
  - name: Install linux cargo packages
    ^ here

2022-12-31 00:42:19,389 p=20439 u=kal n=ansible | [WARNING]: While constructing a mapping from /home/kal/MyApplications/dotfiles/playbooks/test.yaml, line 4, column 5, found a duplicate dict key
(name). Using last defined value only.

2022-12-31 00:42:19,432 p=20439 u=kal n=ansible | PLAY [localhost] *************************************************************************************************************************************
2022-12-31 00:42:19,458 p=20439 u=kal n=ansible | TASK [Gathering Facts] *******************************************************************************************************************************
2022-12-31 00:42:23,473 p=20439 u=kal n=ansible | ok: [krpz]
2022-12-31 00:42:23,496 p=20439 u=kal n=ansible | TASK [exa] *******************************************************************************************************************************************
2022-12-31 00:42:23,671 p=20439 u=kal n=ansible | fatal: [krpz]: FAILED! => {"changed": false, "msg": "missing required arguments: name"}
2022-12-31 00:42:23,672 p=20439 u=kal n=ansible | PLAY RECAP *******************************************************************************************************************************************
2022-12-31 00:42:23,672 p=20439 u=kal n=ansible | krpz                       : ok=1    changed=0    unreachable=0    failed=1    skipped=0    rescued=0    ignored=0   
2022-12-31 00:42:47,930 p=20642 u=kal n=ansible | PLAY [localhost] *************************************************************************************************************************************
2022-12-31 00:42:47,955 p=20642 u=kal n=ansible | TASK [Gathering Facts] *******************************************************************************************************************************
2022-12-31 00:42:51,951 p=20642 u=kal n=ansible | ok: [krpz]
2022-12-31 00:42:51,972 p=20642 u=kal n=ansible | TASK [Install linux cargo packages] ******************************************************************************************************************
2022-12-31 00:42:52,144 p=20642 u=kal n=ansible | fatal: [krpz]: FAILED! => {"changed": false, "msg": "Failed to find required executable \"cargo\" in paths: /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/snap/bin"}
2022-12-31 00:42:52,144 p=20642 u=kal n=ansible | PLAY RECAP *******************************************************************************************************************************************
2022-12-31 00:42:52,144 p=20642 u=kal n=ansible | krpz                       : ok=1    changed=0    unreachable=0    failed=1    skipped=0    rescued=0    ignored=0   
2022-12-31 00:43:40,744 p=20845 u=kal n=ansible | PLAY [localhost] *************************************************************************************************************************************
2022-12-31 00:43:40,769 p=20845 u=kal n=ansible | TASK [Gathering Facts] *******************************************************************************************************************************
2022-12-31 00:43:44,843 p=20845 u=kal n=ansible | ok: [krpz]
2022-12-31 00:43:44,866 p=20845 u=kal n=ansible | TASK [Install linux cargo packages] ******************************************************************************************************************
2022-12-31 00:43:45,034 p=20845 u=kal n=ansible | fatal: [krpz]: FAILED! => {"changed": false, "msg": "Failed to find required executable \"cargo\" in paths: /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/snap/bin"}
2022-12-31 00:43:45,035 p=20845 u=kal n=ansible | PLAY RECAP *******************************************************************************************************************************************
2022-12-31 00:43:45,035 p=20845 u=kal n=ansible | krpz                       : ok=1    changed=0    unreachable=0    failed=1    skipped=0    rescued=0    ignored=0   
2022-12-31 00:47:19,174 p=21341 u=kal n=ansible | ERROR! We were unable to read either as JSON nor YAML, these are the errors we got from each:
JSON: Expecting value: line 1 column 1 (char 0)

Syntax Error while loading YAML.
  did not find expected key

The error appears to be in '/home/kal/MyApplications/dotfiles/playbooks/all.yaml': line 48, column 3, but may
be elsewhere in the file depending on the exact syntax problem.

The offending line appears to be:

    - fd-find # alternative to find
  - name: Set environment managers (direnv, npm, conda)
  ^ here

2022-12-31 00:47:35,397 p=21372 u=kal n=ansible | PLAY [localhost] *************************************************************************************************************************************
2022-12-31 00:47:35,405 p=21372 u=kal n=ansible | TASK [Gathering Facts] *******************************************************************************************************************************
2022-12-31 00:47:39,331 p=21372 u=kal n=ansible | ok: [krpz]
2022-12-31 00:47:39,352 p=21372 u=kal n=ansible | TASK [Install shell utilities w/ apt] ****************************************************************************************************************
2022-12-31 00:47:40,483 p=21372 u=kal n=ansible | ok: [krpz]
2022-12-31 00:47:40,491 p=21372 u=kal n=ansible | TASK [Ensure the user has a zsh shell.] **************************************************************************************************************
2022-12-31 00:47:40,710 p=21372 u=kal n=ansible | ok: [krpz]
2022-12-31 00:47:40,717 p=21372 u=kal n=ansible | TASK [Download default .zshrc] ***********************************************************************************************************************
2022-12-31 00:47:48,375 p=21372 u=kal n=ansible | ok: [krpz]
2022-12-31 00:47:48,403 p=21372 u=kal n=ansible | TASK [Install shell utilities w/ apt] ****************************************************************************************************************
2022-12-31 00:47:49,451 p=21372 u=kal n=ansible | ok: [krpz]
2022-12-31 00:47:49,460 p=21372 u=kal n=ansible | TASK [Install other utilities (wget, curl, git, etc.)] ***********************************************************************************************
2022-12-31 00:47:50,527 p=21372 u=kal n=ansible | ok: [krpz]
2022-12-31 00:47:50,535 p=21372 u=kal n=ansible | TASK [Set environment managers (direnv, npm, conda)] *************************************************************************************************
2022-12-31 00:47:51,575 p=21372 u=kal n=ansible | ok: [krpz]
2022-12-31 00:47:51,584 p=21372 u=kal n=ansible | TASK [Install NVM] ***********************************************************************************************************************************
2022-12-31 00:47:51,770 p=21372 u=kal n=ansible | ok: [krpz]
2022-12-31 00:47:51,778 p=21372 u=kal n=ansible | TASK [Install utilities (htop, tree, pstree, etc.)] **************************************************************************************************
2022-12-31 00:47:52,869 p=21372 u=kal n=ansible | ok: [krpz]
2022-12-31 00:47:52,878 p=21372 u=kal n=ansible | TASK [Install VM techs] ******************************************************************************************************************************
2022-12-31 00:47:53,952 p=21372 u=kal n=ansible | ok: [krpz]
2022-12-31 00:47:53,960 p=21372 u=kal n=ansible | TASK [Download Rust] *********************************************************************************************************************************
2022-12-31 00:47:59,251 p=21372 u=kal n=ansible | ok: [krpz]
2022-12-31 00:47:59,259 p=21372 u=kal n=ansible | TASK [Install Rust] **********************************************************************************************************************************
2022-12-31 00:48:01,090 p=21372 u=kal n=ansible | changed: [krpz]
2022-12-31 00:48:01,103 p=21372 u=kal n=ansible | TASK [See Rust installations] ************************************************************************************************************************
2022-12-31 00:48:01,125 p=21372 u=kal n=ansible | ok: [krpz] => {
    "r.stdout_lines": [
        "",
        "  stable-x86_64-unknown-linux-gnu unchanged - rustc 1.66.0 (69f9c33d7 2022-12-12)",
        "",
        "",
        "Rust is installed now. Great!",
        "",
        "To get started you may need to restart your current shell.",
        "This would reload your PATH environment variable to include",
        "Cargo's bin directory ($HOME/.cargo/bin).",
        "",
        "To configure your current shell, run:",
        "source \"$HOME/.cargo/env\""
    ]
}
2022-12-31 00:48:01,138 p=21372 u=kal n=ansible | TASK [Softlink cargo] ********************************************************************************************************************************
2022-12-31 00:48:01,319 p=21372 u=kal n=ansible | changed: [krpz]
2022-12-31 00:48:01,327 p=21372 u=kal n=ansible | TASK [Install tailscale] *****************************************************************************************************************************
2022-12-31 00:48:10,118 p=21372 u=kal n=ansible | changed: [krpz]
2022-12-31 00:48:10,127 p=21372 u=kal n=ansible | TASK [Install editor, markdown tools, etc. (pandoc, lynx, etc.)] *************************************************************************************
2022-12-31 00:48:11,205 p=21372 u=kal n=ansible | ok: [krpz]
2022-12-31 00:48:11,213 p=21372 u=kal n=ansible | TASK [Creates directory] *****************************************************************************************************************************
2022-12-31 00:48:11,301 p=21372 u=kal n=ansible | ok: [krpz]
2022-12-31 00:48:11,328 p=21372 u=kal n=ansible | PLAY RECAP *******************************************************************************************************************************************
2022-12-31 00:48:11,328 p=21372 u=kal n=ansible | krpz                       : ok=17   changed=3    unreachable=0    failed=0    skipped=0    rescued=0    ignored=0   
2022-12-31 00:48:14,736 p=22897 u=kal n=ansible | PLAY [localhost] *************************************************************************************************************************************
2022-12-31 00:48:14,761 p=22897 u=kal n=ansible | TASK [Gathering Facts] *******************************************************************************************************************************
2022-12-31 00:48:18,709 p=22897 u=kal n=ansible | ok: [krpz]
2022-12-31 00:48:18,731 p=22897 u=kal n=ansible | TASK [Install linux cargo packages] ******************************************************************************************************************
2022-12-31 00:48:18,899 p=22897 u=kal n=ansible | fatal: [krpz]: FAILED! => {"changed": false, "msg": "Failed to find required executable \"cargo\" in paths: /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/snap/bin"}
2022-12-31 00:48:18,899 p=22897 u=kal n=ansible | PLAY RECAP *******************************************************************************************************************************************
2022-12-31 00:48:18,899 p=22897 u=kal n=ansible | krpz                       : ok=1    changed=0    unreachable=0    failed=1    skipped=0    rescued=0    ignored=0   
